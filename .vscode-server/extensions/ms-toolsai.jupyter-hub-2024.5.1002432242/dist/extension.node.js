"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@lumino/algorithm/dist/index.js
var require_dist = __commonJS({
  "node_modules/@lumino/algorithm/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_algorithm = {}));
    })(exports2, function(exports3) {
      "use strict";
      exports3.ArrayExt = void 0;
      (function(ArrayExt) {
        function firstIndexOf(array, value, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return -1;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let span;
          if (stop < start) {
            span = stop + 1 + (n - start);
          } else {
            span = stop - start + 1;
          }
          for (let i = 0; i < span; ++i) {
            let j = (start + i) % n;
            if (array[j] === value) {
              return j;
            }
          }
          return -1;
        }
        ArrayExt.firstIndexOf = firstIndexOf;
        function lastIndexOf(array, value, start = -1, stop = 0) {
          let n = array.length;
          if (n === 0) {
            return -1;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let span;
          if (start < stop) {
            span = start + 1 + (n - stop);
          } else {
            span = start - stop + 1;
          }
          for (let i = 0; i < span; ++i) {
            let j = (start - i + n) % n;
            if (array[j] === value) {
              return j;
            }
          }
          return -1;
        }
        ArrayExt.lastIndexOf = lastIndexOf;
        function findFirstIndex(array, fn, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return -1;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let span;
          if (stop < start) {
            span = stop + 1 + (n - start);
          } else {
            span = stop - start + 1;
          }
          for (let i = 0; i < span; ++i) {
            let j = (start + i) % n;
            if (fn(array[j], j)) {
              return j;
            }
          }
          return -1;
        }
        ArrayExt.findFirstIndex = findFirstIndex;
        function findLastIndex(array, fn, start = -1, stop = 0) {
          let n = array.length;
          if (n === 0) {
            return -1;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let d;
          if (start < stop) {
            d = start + 1 + (n - stop);
          } else {
            d = start - stop + 1;
          }
          for (let i = 0; i < d; ++i) {
            let j = (start - i + n) % n;
            if (fn(array[j], j)) {
              return j;
            }
          }
          return -1;
        }
        ArrayExt.findLastIndex = findLastIndex;
        function findFirstValue(array, fn, start = 0, stop = -1) {
          let index = findFirstIndex(array, fn, start, stop);
          return index !== -1 ? array[index] : void 0;
        }
        ArrayExt.findFirstValue = findFirstValue;
        function findLastValue(array, fn, start = -1, stop = 0) {
          let index = findLastIndex(array, fn, start, stop);
          return index !== -1 ? array[index] : void 0;
        }
        ArrayExt.findLastValue = findLastValue;
        function lowerBound(array, value, fn, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return 0;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let begin = start;
          let span = stop - start + 1;
          while (span > 0) {
            let half = span >> 1;
            let middle = begin + half;
            if (fn(array[middle], value) < 0) {
              begin = middle + 1;
              span -= half + 1;
            } else {
              span = half;
            }
          }
          return begin;
        }
        ArrayExt.lowerBound = lowerBound;
        function upperBound(array, value, fn, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return 0;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let begin = start;
          let span = stop - start + 1;
          while (span > 0) {
            let half = span >> 1;
            let middle = begin + half;
            if (fn(array[middle], value) > 0) {
              span = half;
            } else {
              begin = middle + 1;
              span -= half + 1;
            }
          }
          return begin;
        }
        ArrayExt.upperBound = upperBound;
        function shallowEqual(a, b, fn) {
          if (a === b) {
            return true;
          }
          if (a.length !== b.length) {
            return false;
          }
          for (let i = 0, n = a.length; i < n; ++i) {
            if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        ArrayExt.shallowEqual = shallowEqual;
        function slice(array, options = {}) {
          let { start, stop, step } = options;
          if (step === void 0) {
            step = 1;
          }
          if (step === 0) {
            throw new Error("Slice `step` cannot be zero.");
          }
          let n = array.length;
          if (start === void 0) {
            start = step < 0 ? n - 1 : 0;
          } else if (start < 0) {
            start = Math.max(start + n, step < 0 ? -1 : 0);
          } else if (start >= n) {
            start = step < 0 ? n - 1 : n;
          }
          if (stop === void 0) {
            stop = step < 0 ? -1 : n;
          } else if (stop < 0) {
            stop = Math.max(stop + n, step < 0 ? -1 : 0);
          } else if (stop >= n) {
            stop = step < 0 ? n - 1 : n;
          }
          let length;
          if (step < 0 && stop >= start || step > 0 && start >= stop) {
            length = 0;
          } else if (step < 0) {
            length = Math.floor((stop - start + 1) / step + 1);
          } else {
            length = Math.floor((stop - start - 1) / step + 1);
          }
          let result = [];
          for (let i = 0; i < length; ++i) {
            result[i] = array[start + i * step];
          }
          return result;
        }
        ArrayExt.slice = slice;
        function move(array, fromIndex, toIndex) {
          let n = array.length;
          if (n <= 1) {
            return;
          }
          if (fromIndex < 0) {
            fromIndex = Math.max(0, fromIndex + n);
          } else {
            fromIndex = Math.min(fromIndex, n - 1);
          }
          if (toIndex < 0) {
            toIndex = Math.max(0, toIndex + n);
          } else {
            toIndex = Math.min(toIndex, n - 1);
          }
          if (fromIndex === toIndex) {
            return;
          }
          let value = array[fromIndex];
          let d = fromIndex < toIndex ? 1 : -1;
          for (let i = fromIndex; i !== toIndex; i += d) {
            array[i] = array[i + d];
          }
          array[toIndex] = value;
        }
        ArrayExt.move = move;
        function reverse(array, start = 0, stop = -1) {
          let n = array.length;
          if (n <= 1) {
            return;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          while (start < stop) {
            let a = array[start];
            let b = array[stop];
            array[start++] = b;
            array[stop--] = a;
          }
        }
        ArrayExt.reverse = reverse;
        function rotate(array, delta, start = 0, stop = -1) {
          let n = array.length;
          if (n <= 1) {
            return;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          if (start >= stop) {
            return;
          }
          let length = stop - start + 1;
          if (delta > 0) {
            delta = delta % length;
          } else if (delta < 0) {
            delta = (delta % length + length) % length;
          }
          if (delta === 0) {
            return;
          }
          let pivot = start + delta;
          reverse(array, start, pivot - 1);
          reverse(array, pivot, stop);
          reverse(array, start, stop);
        }
        ArrayExt.rotate = rotate;
        function fill(array, value, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let span;
          if (stop < start) {
            span = stop + 1 + (n - start);
          } else {
            span = stop - start + 1;
          }
          for (let i = 0; i < span; ++i) {
            array[(start + i) % n] = value;
          }
        }
        ArrayExt.fill = fill;
        function insert(array, index, value) {
          let n = array.length;
          if (index < 0) {
            index = Math.max(0, index + n);
          } else {
            index = Math.min(index, n);
          }
          for (let i = n; i > index; --i) {
            array[i] = array[i - 1];
          }
          array[index] = value;
        }
        ArrayExt.insert = insert;
        function removeAt(array, index) {
          let n = array.length;
          if (index < 0) {
            index += n;
          }
          if (index < 0 || index >= n) {
            return void 0;
          }
          let value = array[index];
          for (let i = index + 1; i < n; ++i) {
            array[i - 1] = array[i];
          }
          array.length = n - 1;
          return value;
        }
        ArrayExt.removeAt = removeAt;
        function removeFirstOf(array, value, start = 0, stop = -1) {
          let index = firstIndexOf(array, value, start, stop);
          if (index !== -1) {
            removeAt(array, index);
          }
          return index;
        }
        ArrayExt.removeFirstOf = removeFirstOf;
        function removeLastOf(array, value, start = -1, stop = 0) {
          let index = lastIndexOf(array, value, start, stop);
          if (index !== -1) {
            removeAt(array, index);
          }
          return index;
        }
        ArrayExt.removeLastOf = removeLastOf;
        function removeAllOf(array, value, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return 0;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let count = 0;
          for (let i = 0; i < n; ++i) {
            if (start <= stop && i >= start && i <= stop && array[i] === value) {
              count++;
            } else if (stop < start && (i <= stop || i >= start) && array[i] === value) {
              count++;
            } else if (count > 0) {
              array[i - count] = array[i];
            }
          }
          if (count > 0) {
            array.length = n - count;
          }
          return count;
        }
        ArrayExt.removeAllOf = removeAllOf;
        function removeFirstWhere(array, fn, start = 0, stop = -1) {
          let value;
          let index = findFirstIndex(array, fn, start, stop);
          if (index !== -1) {
            value = removeAt(array, index);
          }
          return { index, value };
        }
        ArrayExt.removeFirstWhere = removeFirstWhere;
        function removeLastWhere(array, fn, start = -1, stop = 0) {
          let value;
          let index = findLastIndex(array, fn, start, stop);
          if (index !== -1) {
            value = removeAt(array, index);
          }
          return { index, value };
        }
        ArrayExt.removeLastWhere = removeLastWhere;
        function removeAllWhere(array, fn, start = 0, stop = -1) {
          let n = array.length;
          if (n === 0) {
            return 0;
          }
          if (start < 0) {
            start = Math.max(0, start + n);
          } else {
            start = Math.min(start, n - 1);
          }
          if (stop < 0) {
            stop = Math.max(0, stop + n);
          } else {
            stop = Math.min(stop, n - 1);
          }
          let count = 0;
          for (let i = 0; i < n; ++i) {
            if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {
              count++;
            } else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {
              count++;
            } else if (count > 0) {
              array[i - count] = array[i];
            }
          }
          if (count > 0) {
            array.length = n - count;
          }
          return count;
        }
        ArrayExt.removeAllWhere = removeAllWhere;
      })(exports3.ArrayExt || (exports3.ArrayExt = {}));
      function* chain(...objects) {
        for (const object of objects) {
          yield* object;
        }
      }
      function* empty() {
        return;
      }
      function* enumerate(object, start = 0) {
        for (const value of object) {
          yield [start++, value];
        }
      }
      function* filter(object, fn) {
        let index = 0;
        for (const value of object) {
          if (fn(value, index++)) {
            yield value;
          }
        }
      }
      function find(object, fn) {
        let index = 0;
        for (const value of object) {
          if (fn(value, index++)) {
            return value;
          }
        }
        return void 0;
      }
      function findIndex(object, fn) {
        let index = 0;
        for (const value of object) {
          if (fn(value, index++)) {
            return index - 1;
          }
        }
        return -1;
      }
      function min(object, fn) {
        let result = void 0;
        for (const value of object) {
          if (result === void 0) {
            result = value;
            continue;
          }
          if (fn(value, result) < 0) {
            result = value;
          }
        }
        return result;
      }
      function max(object, fn) {
        let result = void 0;
        for (const value of object) {
          if (result === void 0) {
            result = value;
            continue;
          }
          if (fn(value, result) > 0) {
            result = value;
          }
        }
        return result;
      }
      function minmax(object, fn) {
        let empty2 = true;
        let vmin;
        let vmax;
        for (const value of object) {
          if (empty2) {
            vmin = value;
            vmax = value;
            empty2 = false;
          } else if (fn(value, vmin) < 0) {
            vmin = value;
          } else if (fn(value, vmax) > 0) {
            vmax = value;
          }
        }
        return empty2 ? void 0 : [vmin, vmax];
      }
      function toArray(object) {
        return Array.from(object);
      }
      function toObject(object) {
        const result = {};
        for (const [key, value] of object) {
          result[key] = value;
        }
        return result;
      }
      function each(object, fn) {
        let index = 0;
        for (const value of object) {
          if (false === fn(value, index++)) {
            return;
          }
        }
      }
      function every(object, fn) {
        let index = 0;
        for (const value of object) {
          if (false === fn(value, index++)) {
            return false;
          }
        }
        return true;
      }
      function some(object, fn) {
        let index = 0;
        for (const value of object) {
          if (fn(value, index++)) {
            return true;
          }
        }
        return false;
      }
      function* map(object, fn) {
        let index = 0;
        for (const value of object) {
          yield fn(value, index++);
        }
      }
      function* range(start, stop, step) {
        if (stop === void 0) {
          stop = start;
          start = 0;
          step = 1;
        } else if (step === void 0) {
          step = 1;
        }
        const length = Private.rangeLength(start, stop, step);
        for (let index = 0; index < length; index++) {
          yield start + step * index;
        }
      }
      var Private;
      (function(Private2) {
        function rangeLength(start, stop, step) {
          if (step === 0) {
            return Infinity;
          }
          if (start > stop && step > 0) {
            return 0;
          }
          if (start < stop && step < 0) {
            return 0;
          }
          return Math.ceil((stop - start) / step);
        }
        Private2.rangeLength = rangeLength;
      })(Private || (Private = {}));
      function reduce(object, fn, initial) {
        const it = object[Symbol.iterator]();
        let index = 0;
        let first = it.next();
        if (first.done && initial === void 0) {
          throw new TypeError("Reduce of empty iterable with no initial value.");
        }
        if (first.done) {
          return initial;
        }
        let second = it.next();
        if (second.done && initial === void 0) {
          return first.value;
        }
        if (second.done) {
          return fn(initial, first.value, index++);
        }
        let accumulator;
        if (initial === void 0) {
          accumulator = fn(first.value, second.value, index++);
        } else {
          accumulator = fn(fn(initial, first.value, index++), second.value, index++);
        }
        let next;
        while (!(next = it.next()).done) {
          accumulator = fn(accumulator, next.value, index++);
        }
        return accumulator;
      }
      function* repeat(value, count) {
        while (0 < count--) {
          yield value;
        }
      }
      function* once(value) {
        yield value;
      }
      function* retro(object) {
        if (typeof object.retro === "function") {
          yield* object.retro();
        } else {
          for (let index = object.length - 1; index > -1; index--) {
            yield object[index];
          }
        }
      }
      function topologicSort(edges) {
        let sorted = [];
        let visited = /* @__PURE__ */ new Set();
        let graph = /* @__PURE__ */ new Map();
        for (const edge of edges) {
          addEdge(edge);
        }
        for (const [k] of graph) {
          visit(k);
        }
        return sorted;
        function addEdge(edge) {
          let [fromNode, toNode] = edge;
          let children = graph.get(toNode);
          if (children) {
            children.push(fromNode);
          } else {
            graph.set(toNode, [fromNode]);
          }
        }
        function visit(node) {
          if (visited.has(node)) {
            return;
          }
          visited.add(node);
          let children = graph.get(node);
          if (children) {
            for (const child of children) {
              visit(child);
            }
          }
          sorted.push(node);
        }
      }
      function* stride(object, step) {
        let count = 0;
        for (const value of object) {
          if (0 === count++ % step) {
            yield value;
          }
        }
      }
      exports3.StringExt = void 0;
      (function(StringExt) {
        function findIndices(source, query, start = 0) {
          let indices = new Array(query.length);
          for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {
            j = source.indexOf(query[i], j);
            if (j === -1) {
              return null;
            }
            indices[i] = j;
          }
          return indices;
        }
        StringExt.findIndices = findIndices;
        function matchSumOfSquares(source, query, start = 0) {
          let indices = findIndices(source, query, start);
          if (!indices) {
            return null;
          }
          let score = 0;
          for (let i = 0, n = indices.length; i < n; ++i) {
            let j = indices[i] - start;
            score += j * j;
          }
          return { score, indices };
        }
        StringExt.matchSumOfSquares = matchSumOfSquares;
        function matchSumOfDeltas(source, query, start = 0) {
          let indices = findIndices(source, query, start);
          if (!indices) {
            return null;
          }
          let score = 0;
          let last = start - 1;
          for (let i = 0, n = indices.length; i < n; ++i) {
            let j = indices[i];
            score += j - last - 1;
            last = j;
          }
          return { score, indices };
        }
        StringExt.matchSumOfDeltas = matchSumOfDeltas;
        function highlight(source, indices, fn) {
          let result = [];
          let k = 0;
          let last = 0;
          let n = indices.length;
          while (k < n) {
            let i = indices[k];
            let j = indices[k];
            while (++k < n && indices[k] === j + 1) {
              j++;
            }
            if (last < i) {
              result.push(source.slice(last, i));
            }
            if (i < j + 1) {
              result.push(fn(source.slice(i, j + 1)));
            }
            last = j + 1;
          }
          if (last < source.length) {
            result.push(source.slice(last));
          }
          return result;
        }
        StringExt.highlight = highlight;
        function cmp(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        StringExt.cmp = cmp;
      })(exports3.StringExt || (exports3.StringExt = {}));
      function* take(object, count) {
        if (count < 1) {
          return;
        }
        const it = object[Symbol.iterator]();
        let item;
        while (0 < count-- && !(item = it.next()).done) {
          yield item.value;
        }
      }
      function* zip(...objects) {
        const iters = objects.map((obj) => obj[Symbol.iterator]());
        let tuple = iters.map((it) => it.next());
        for (; every(tuple, (item) => !item.done); tuple = iters.map((it) => it.next())) {
          yield tuple.map((item) => item.value);
        }
      }
      exports3.chain = chain;
      exports3.each = each;
      exports3.empty = empty;
      exports3.enumerate = enumerate;
      exports3.every = every;
      exports3.filter = filter;
      exports3.find = find;
      exports3.findIndex = findIndex;
      exports3.map = map;
      exports3.max = max;
      exports3.min = min;
      exports3.minmax = minmax;
      exports3.once = once;
      exports3.range = range;
      exports3.reduce = reduce;
      exports3.repeat = repeat;
      exports3.retro = retro;
      exports3.some = some;
      exports3.stride = stride;
      exports3.take = take;
      exports3.toArray = toArray;
      exports3.toObject = toObject;
      exports3.topologicSort = topologicSort;
      exports3.zip = zip;
    });
  }
});

// node_modules/@lumino/coreutils/dist/index.node.js
var require_index_node = __commonJS({
  "node_modules/@lumino/coreutils/dist/index.node.js"(exports2) {
    "use strict";
    var algorithm = require_dist();
    exports2.JSONExt = void 0;
    (function(JSONExt) {
      JSONExt.emptyObject = Object.freeze({});
      JSONExt.emptyArray = Object.freeze([]);
      function isPrimitive(value) {
        return value === null || typeof value === "boolean" || typeof value === "number" || typeof value === "string";
      }
      JSONExt.isPrimitive = isPrimitive;
      function isArray(value) {
        return Array.isArray(value);
      }
      JSONExt.isArray = isArray;
      function isObject(value) {
        return !isPrimitive(value) && !isArray(value);
      }
      JSONExt.isObject = isObject;
      function deepEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (isPrimitive(first) || isPrimitive(second)) {
          return false;
        }
        let a1 = isArray(first);
        let a2 = isArray(second);
        if (a1 !== a2) {
          return false;
        }
        if (a1 && a2) {
          return deepArrayEqual(first, second);
        }
        return deepObjectEqual(first, second);
      }
      JSONExt.deepEqual = deepEqual;
      function deepCopy(value) {
        if (isPrimitive(value)) {
          return value;
        }
        if (isArray(value)) {
          return deepArrayCopy(value);
        }
        return deepObjectCopy(value);
      }
      JSONExt.deepCopy = deepCopy;
      function deepArrayEqual(first, second) {
        if (first === second) {
          return true;
        }
        if (first.length !== second.length) {
          return false;
        }
        for (let i = 0, n = first.length; i < n; ++i) {
          if (!deepEqual(first[i], second[i])) {
            return false;
          }
        }
        return true;
      }
      function deepObjectEqual(first, second) {
        if (first === second) {
          return true;
        }
        for (let key in first) {
          if (first[key] !== void 0 && !(key in second)) {
            return false;
          }
        }
        for (let key in second) {
          if (second[key] !== void 0 && !(key in first)) {
            return false;
          }
        }
        for (let key in first) {
          let firstValue = first[key];
          let secondValue = second[key];
          if (firstValue === void 0 && secondValue === void 0) {
            continue;
          }
          if (firstValue === void 0 || secondValue === void 0) {
            return false;
          }
          if (!deepEqual(firstValue, secondValue)) {
            return false;
          }
        }
        return true;
      }
      function deepArrayCopy(value) {
        let result = new Array(value.length);
        for (let i = 0, n = value.length; i < n; ++i) {
          result[i] = deepCopy(value[i]);
        }
        return result;
      }
      function deepObjectCopy(value) {
        let result = {};
        for (let key in value) {
          let subvalue = value[key];
          if (subvalue === void 0) {
            continue;
          }
          result[key] = deepCopy(subvalue);
        }
        return result;
      }
    })(exports2.JSONExt || (exports2.JSONExt = {}));
    var MimeData = class {
      constructor() {
        this._types = [];
        this._values = [];
      }
      /**
       * Get an array of the MIME types contained within the dataset.
       *
       * @returns A new array of the MIME types, in order of insertion.
       */
      types() {
        return this._types.slice();
      }
      /**
       * Test whether the dataset has an entry for the given type.
       *
       * @param mime - The MIME type of interest.
       *
       * @returns `true` if the dataset contains a value for the given
       *   MIME type, `false` otherwise.
       */
      hasData(mime) {
        return this._types.indexOf(mime) !== -1;
      }
      /**
       * Get the data value for the given MIME type.
       *
       * @param mime - The MIME type of interest.
       *
       * @returns The value for the given MIME type, or `undefined` if
       *   the dataset does not contain a value for the type.
       */
      getData(mime) {
        let i = this._types.indexOf(mime);
        return i !== -1 ? this._values[i] : void 0;
      }
      /**
       * Set the data value for the given MIME type.
       *
       * @param mime - The MIME type of interest.
       *
       * @param data - The data value for the given MIME type.
       *
       * #### Notes
       * This will overwrite any previous entry for the MIME type.
       */
      setData(mime, data) {
        this.clearData(mime);
        this._types.push(mime);
        this._values.push(data);
      }
      /**
       * Remove the data entry for the given MIME type.
       *
       * @param mime - The MIME type of interest.
       *
       * #### Notes
       * This is a no-op if there is no entry for the given MIME type.
       */
      clearData(mime) {
        let i = this._types.indexOf(mime);
        if (i !== -1) {
          this._types.splice(i, 1);
          this._values.splice(i, 1);
        }
      }
      /**
       * Remove all data entries from the dataset.
       */
      clear() {
        this._types.length = 0;
        this._values.length = 0;
      }
    };
    var PluginRegistry = class {
      constructor(options = {}) {
        this._application = null;
        this._validatePlugin = () => true;
        this._plugins = /* @__PURE__ */ new Map();
        this._services = /* @__PURE__ */ new Map();
        if (options.validatePlugin) {
          console.info("Plugins may be rejected by the custom validation plugin method.");
          this._validatePlugin = options.validatePlugin;
        }
      }
      /**
       * The application object.
       *
       * It will be provided as first argument to the
       * plugins activation and deactivation functions.
       *
       * It can only be set once.
       *
       * By default, it is `null`.
       */
      get application() {
        return this._application;
      }
      set application(v) {
        if (this._application !== null) {
          throw Error("PluginRegistry.application is already set. It cannot be overridden.");
        }
        this._application = v;
      }
      /**
       * The list of all the deferred plugins.
       */
      get deferredPlugins() {
        return Array.from(this._plugins).filter(([id, plugin]) => plugin.autoStart === "defer").map(([id, plugin]) => id);
      }
      /**
       * Get a plugin description.
       *
       * @param id - The ID of the plugin of interest.
       *
       * @returns The plugin description.
       */
      getPluginDescription(id) {
        var _a, _b;
        return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Test whether a plugin is registered with the application.
       *
       * @param id - The ID of the plugin of interest.
       *
       * @returns `true` if the plugin is registered, `false` otherwise.
       */
      hasPlugin(id) {
        return this._plugins.has(id);
      }
      /**
       * Test whether a plugin is activated with the application.
       *
       * @param id - The ID of the plugin of interest.
       *
       * @returns `true` if the plugin is activated, `false` otherwise.
       */
      isPluginActivated(id) {
        var _a, _b;
        return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.activated) !== null && _b !== void 0 ? _b : false;
      }
      /**
       * List the IDs of the plugins registered with the application.
       *
       * @returns A new array of the registered plugin IDs.
       */
      listPlugins() {
        return Array.from(this._plugins.keys());
      }
      /**
       * Register a plugin with the application.
       *
       * @param plugin - The plugin to register.
       *
       * #### Notes
       * An error will be thrown if a plugin with the same ID is already
       * registered, or if the plugin has a circular dependency.
       *
       * If the plugin provides a service which has already been provided
       * by another plugin, the new service will override the old service.
       */
      registerPlugin(plugin) {
        if (this._plugins.has(plugin.id)) {
          throw new TypeError(`Plugin '${plugin.id}' is already registered.`);
        }
        if (!this._validatePlugin(plugin)) {
          throw new Error(`Plugin '${plugin.id}' is not valid.`);
        }
        const data = Private.createPluginData(plugin);
        Private.ensureNoCycle(data, this._plugins, this._services);
        if (data.provides) {
          this._services.set(data.provides, data.id);
        }
        this._plugins.set(data.id, data);
      }
      /**
       * Register multiple plugins with the application.
       *
       * @param plugins - The plugins to register.
       *
       * #### Notes
       * This calls `registerPlugin()` for each of the given plugins.
       */
      registerPlugins(plugins) {
        for (const plugin of plugins) {
          this.registerPlugin(plugin);
        }
      }
      /**
       * Deregister a plugin with the application.
       *
       * @param id - The ID of the plugin of interest.
       *
       * @param force - Whether to deregister the plugin even if it is active.
       */
      deregisterPlugin(id, force) {
        const plugin = this._plugins.get(id);
        if (!plugin) {
          return;
        }
        if (plugin.activated && !force) {
          throw new Error(`Plugin '${id}' is still active.`);
        }
        this._plugins.delete(id);
      }
      /**
       * Activate the plugin with the given ID.
       *
       * @param id - The ID of the plugin of interest.
       *
       * @returns A promise which resolves when the plugin is activated
       *   or rejects with an error if it cannot be activated.
       */
      async activatePlugin(id) {
        const plugin = this._plugins.get(id);
        if (!plugin) {
          throw new ReferenceError(`Plugin '${id}' is not registered.`);
        }
        if (plugin.activated) {
          return;
        }
        if (plugin.promise) {
          return plugin.promise;
        }
        const required = plugin.requires.map((t) => this.resolveRequiredService(t));
        const optional = plugin.optional.map((t) => this.resolveOptionalService(t));
        plugin.promise = Promise.all([...required, ...optional]).then((services) => plugin.activate.apply(void 0, [this.application, ...services])).then((service) => {
          plugin.service = service;
          plugin.activated = true;
          plugin.promise = null;
        }).catch((error) => {
          plugin.promise = null;
          throw error;
        });
        return plugin.promise;
      }
      /**
       * Activate all the deferred plugins.
       *
       * @returns A promise which will resolve when each plugin is activated
       * or rejects with an error if one cannot be activated.
       */
      async activatePlugins(kind, options = {}) {
        switch (kind) {
          case "defer": {
            const promises = this.deferredPlugins.filter((pluginId) => this._plugins.get(pluginId).autoStart).map((pluginId) => {
              return this.activatePlugin(pluginId);
            });
            await Promise.all(promises);
            break;
          }
          case "startUp": {
            const startups = Private.collectStartupPlugins(this._plugins, options);
            const promises = startups.map(async (id) => {
              try {
                return await this.activatePlugin(id);
              } catch (error) {
                console.error(`Plugin '${id}' failed to activate.`, error);
              }
            });
            await Promise.all(promises);
            break;
          }
        }
      }
      /**
       * Deactivate the plugin and its downstream dependents if and only if the
       * plugin and its dependents all support `deactivate`.
       *
       * @param id - The ID of the plugin of interest.
       *
       * @returns A list of IDs of downstream plugins deactivated with this one.
       */
      async deactivatePlugin(id) {
        const plugin = this._plugins.get(id);
        if (!plugin) {
          throw new ReferenceError(`Plugin '${id}' is not registered.`);
        }
        if (!plugin.activated) {
          return [];
        }
        if (!plugin.deactivate) {
          throw new TypeError(`Plugin '${id}'#deactivate() method missing`);
        }
        const manifest = Private.findDependents(id, this._plugins, this._services);
        const downstream = manifest.map((id2) => this._plugins.get(id2));
        for (const plugin2 of downstream) {
          if (!plugin2.deactivate) {
            throw new TypeError(`Plugin ${plugin2.id}#deactivate() method missing (depends on ${id})`);
          }
        }
        for (const plugin2 of downstream) {
          const services = [...plugin2.requires, ...plugin2.optional].map((service) => {
            const id2 = this._services.get(service);
            return id2 ? this._plugins.get(id2).service : null;
          });
          await plugin2.deactivate(this.application, ...services);
          plugin2.service = null;
          plugin2.activated = false;
        }
        manifest.pop();
        return manifest;
      }
      /**
       * Resolve a required service of a given type.
       *
       * @param token - The token for the service type of interest.
       *
       * @returns A promise which resolves to an instance of the requested
       *   service, or rejects with an error if it cannot be resolved.
       *
       * #### Notes
       * Services are singletons. The same instance will be returned each
       * time a given service token is resolved.
       *
       * If the plugin which provides the service has not been activated,
       * resolving the service will automatically activate the plugin.
       *
       * User code will not typically call this method directly. Instead,
       * the required services for the user's plugins will be resolved
       * automatically when the plugin is activated.
       */
      async resolveRequiredService(token) {
        const id = this._services.get(token);
        if (!id) {
          throw new TypeError(`No provider for: ${token.name}.`);
        }
        const plugin = this._plugins.get(id);
        if (!plugin.activated) {
          await this.activatePlugin(id);
        }
        return plugin.service;
      }
      /**
       * Resolve an optional service of a given type.
       *
       * @param token - The token for the service type of interest.
       *
       * @returns A promise which resolves to an instance of the requested
       *   service, or `null` if it cannot be resolved.
       *
       * #### Notes
       * Services are singletons. The same instance will be returned each
       * time a given service token is resolved.
       *
       * If the plugin which provides the service has not been activated,
       * resolving the service will automatically activate the plugin.
       *
       * User code will not typically call this method directly. Instead,
       * the optional services for the user's plugins will be resolved
       * automatically when the plugin is activated.
       */
      async resolveOptionalService(token) {
        const id = this._services.get(token);
        if (!id) {
          return null;
        }
        const plugin = this._plugins.get(id);
        if (!plugin.activated) {
          try {
            await this.activatePlugin(id);
          } catch (reason) {
            console.error(reason);
            return null;
          }
        }
        return plugin.service;
      }
    };
    var Private;
    (function(Private2) {
      class PluginData {
        constructor(plugin) {
          var _a, _b, _c, _d;
          this._activated = false;
          this._promise = null;
          this._service = null;
          this.id = plugin.id;
          this.description = (_a = plugin.description) !== null && _a !== void 0 ? _a : "";
          this.activate = plugin.activate;
          this.deactivate = (_b = plugin.deactivate) !== null && _b !== void 0 ? _b : null;
          this.provides = (_c = plugin.provides) !== null && _c !== void 0 ? _c : null;
          this.autoStart = (_d = plugin.autoStart) !== null && _d !== void 0 ? _d : false;
          this.requires = plugin.requires ? plugin.requires.slice() : [];
          this.optional = plugin.optional ? plugin.optional.slice() : [];
        }
        /**
         * Whether the plugin has been activated.
         */
        get activated() {
          return this._activated;
        }
        set activated(a) {
          this._activated = a;
        }
        /**
         * The resolved service for the plugin, or `null`.
         */
        get service() {
          return this._service;
        }
        set service(s) {
          this._service = s;
        }
        /**
         * The pending resolver promise, or `null`.
         */
        get promise() {
          return this._promise;
        }
        set promise(p) {
          this._promise = p;
        }
      }
      function createPluginData(plugin) {
        return new PluginData(plugin);
      }
      Private2.createPluginData = createPluginData;
      function ensureNoCycle(plugin, plugins, services) {
        const dependencies = [...plugin.requires, ...plugin.optional];
        const visit = (token) => {
          if (token === plugin.provides) {
            return true;
          }
          const id = services.get(token);
          if (!id) {
            return false;
          }
          const visited = plugins.get(id);
          const dependencies2 = [...visited.requires, ...visited.optional];
          if (dependencies2.length === 0) {
            return false;
          }
          trace.push(id);
          if (dependencies2.some(visit)) {
            return true;
          }
          trace.pop();
          return false;
        };
        if (!plugin.provides || dependencies.length === 0) {
          return;
        }
        const trace = [plugin.id];
        if (dependencies.some(visit)) {
          throw new ReferenceError(`Cycle detected: ${trace.join(" -> ")}.`);
        }
      }
      Private2.ensureNoCycle = ensureNoCycle;
      function findDependents(id, plugins, services) {
        const edges = new Array();
        const add = (id2) => {
          const plugin = plugins.get(id2);
          const dependencies = [...plugin.requires, ...plugin.optional];
          edges.push(...dependencies.reduce((acc, dep) => {
            const service = services.get(dep);
            if (service) {
              acc.push([id2, service]);
            }
            return acc;
          }, []));
        };
        for (const id2 of plugins.keys()) {
          add(id2);
        }
        const newEdges = edges.filter((edge) => edge[1] === id);
        let oldSize = 0;
        while (newEdges.length > oldSize) {
          const previousSize = newEdges.length;
          const packagesOfInterest = new Set(newEdges.map((edge) => edge[0]));
          for (const poi of packagesOfInterest) {
            edges.filter((edge) => edge[1] === poi).forEach((edge) => {
              if (!newEdges.includes(edge)) {
                newEdges.push(edge);
              }
            });
          }
          oldSize = previousSize;
        }
        const sorted = algorithm.topologicSort(newEdges);
        const index = sorted.findIndex((candidate) => candidate === id);
        if (index === -1) {
          return [id];
        }
        return sorted.slice(0, index + 1);
      }
      Private2.findDependents = findDependents;
      function collectStartupPlugins(plugins, options) {
        const collection = /* @__PURE__ */ new Set();
        for (const id of plugins.keys()) {
          if (plugins.get(id).autoStart === true) {
            collection.add(id);
          }
        }
        if (options.startPlugins) {
          for (const id of options.startPlugins) {
            collection.add(id);
          }
        }
        if (options.ignorePlugins) {
          for (const id of options.ignorePlugins) {
            collection.delete(id);
          }
        }
        return Array.from(collection);
      }
      Private2.collectStartupPlugins = collectStartupPlugins;
    })(Private || (Private = {}));
    var PromiseDelegate = class {
      /**
       * Construct a new promise delegate.
       */
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      /**
       * Resolve the wrapped promise with the given value.
       *
       * @param value - The value to use for resolving the promise.
       */
      resolve(value) {
        let resolve = this._resolve;
        resolve(value);
      }
      /**
       * Reject the wrapped promise with the given value.
       *
       * @reason - The reason for rejecting the promise.
       */
      reject(reason) {
        let reject = this._reject;
        reject(reason);
      }
    };
    var Token = class {
      /**
       * Construct a new token.
       *
       * @param name - A human readable name for the token.
       * @param description - Token purpose description for documentation.
       */
      constructor(name2, description) {
        this.name = name2;
        this.description = description !== null && description !== void 0 ? description : "";
        this._tokenStructuralPropertyT = null;
      }
    };
    function fallbackRandomValues(buffer) {
      let value = 0;
      for (let i = 0, n = buffer.length; i < n; ++i) {
        if (i % 4 === 0) {
          value = Math.random() * 4294967295 >>> 0;
        }
        buffer[i] = value & 255;
        value >>>= 8;
      }
    }
    exports2.Random = void 0;
    (function(Random) {
      Random.getRandomValues = (() => {
        const crypto = typeof require !== "undefined" && require("crypto") || null;
        if (crypto && typeof crypto.randomFillSync === "function") {
          return function getRandomValues(buffer) {
            return crypto.randomFillSync(buffer);
          };
        }
        if (crypto && typeof crypto.randomBytes === "function") {
          return function getRandomValues(buffer) {
            let bytes = crypto.randomBytes(buffer.length);
            for (let i = 0, n = bytes.length; i < n; ++i) {
              buffer[i] = bytes[i];
            }
          };
        }
        return fallbackRandomValues;
      })();
    })(exports2.Random || (exports2.Random = {}));
    function uuid4Factory(getRandomValues) {
      const bytes = new Uint8Array(16);
      const lut = new Array(256);
      for (let i = 0; i < 16; ++i) {
        lut[i] = "0" + i.toString(16);
      }
      for (let i = 16; i < 256; ++i) {
        lut[i] = i.toString(16);
      }
      return function uuid4() {
        getRandomValues(bytes);
        bytes[6] = 64 | bytes[6] & 15;
        bytes[8] = 128 | bytes[8] & 63;
        return lut[bytes[0]] + lut[bytes[1]] + lut[bytes[2]] + lut[bytes[3]] + "-" + lut[bytes[4]] + lut[bytes[5]] + "-" + lut[bytes[6]] + lut[bytes[7]] + "-" + lut[bytes[8]] + lut[bytes[9]] + "-" + lut[bytes[10]] + lut[bytes[11]] + lut[bytes[12]] + lut[bytes[13]] + lut[bytes[14]] + lut[bytes[15]];
      };
    }
    exports2.UUID = void 0;
    (function(UUID) {
      UUID.uuid4 = uuid4Factory(exports2.Random.getRandomValues);
    })(exports2.UUID || (exports2.UUID = {}));
    exports2.MimeData = MimeData;
    exports2.PluginRegistry = PluginRegistry;
    exports2.PromiseDelegate = PromiseDelegate;
    exports2.Token = Token;
  }
});

// node_modules/@lumino/signaling/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@lumino/signaling/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_dist(), require_index_node()) : typeof define === "function" && define.amd ? define(["exports", "@lumino/algorithm", "@lumino/coreutils"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_signaling = {}, global2.lumino_algorithm, global2.lumino_coreutils));
    })(exports2, function(exports3, algorithm, coreutils) {
      "use strict";
      class Signal {
        /**
         * Construct a new signal.
         *
         * @param sender - The sender which owns the signal.
         */
        constructor(sender) {
          this.sender = sender;
        }
        /**
         * Connect a slot to the signal.
         *
         * @param slot - The slot to invoke when the signal is emitted.
         *
         * @param thisArg - The `this` context for the slot. If provided,
         *   this must be a non-primitive object.
         *
         * @returns `true` if the connection succeeds, `false` otherwise.
         */
        connect(slot, thisArg) {
          return Private.connect(this, slot, thisArg);
        }
        /**
         * Disconnect a slot from the signal.
         *
         * @param slot - The slot to disconnect from the signal.
         *
         * @param thisArg - The `this` context for the slot. If provided,
         *   this must be a non-primitive object.
         *
         * @returns `true` if the connection is removed, `false` otherwise.
         */
        disconnect(slot, thisArg) {
          return Private.disconnect(this, slot, thisArg);
        }
        /**
         * Emit the signal and invoke the connected slots.
         *
         * @param args - The args to pass to the connected slots.
         *
         * #### Notes
         * Slots are invoked synchronously in connection order.
         *
         * Exceptions thrown by connected slots will be caught and logged.
         */
        emit(args) {
          Private.emit(this, args);
        }
      }
      (function(Signal2) {
        function disconnectBetween(sender, receiver) {
          Private.disconnectBetween(sender, receiver);
        }
        Signal2.disconnectBetween = disconnectBetween;
        function disconnectSender(sender) {
          Private.disconnectSender(sender);
        }
        Signal2.disconnectSender = disconnectSender;
        function disconnectReceiver(receiver) {
          Private.disconnectReceiver(receiver);
        }
        Signal2.disconnectReceiver = disconnectReceiver;
        function disconnectAll(object) {
          Private.disconnectAll(object);
        }
        Signal2.disconnectAll = disconnectAll;
        function clearData(object) {
          Private.disconnectAll(object);
        }
        Signal2.clearData = clearData;
        function getExceptionHandler() {
          return Private.exceptionHandler;
        }
        Signal2.getExceptionHandler = getExceptionHandler;
        function setExceptionHandler(handler) {
          let old = Private.exceptionHandler;
          Private.exceptionHandler = handler;
          return old;
        }
        Signal2.setExceptionHandler = setExceptionHandler;
      })(Signal || (Signal = {}));
      class Stream extends Signal {
        constructor() {
          super(...arguments);
          this._pending = new coreutils.PromiseDelegate();
        }
        /**
         * Return an async iterator that yields every emission.
         */
        async *[Symbol.asyncIterator]() {
          let pending = this._pending;
          while (true) {
            try {
              const { args, next } = await pending.promise;
              pending = next;
              yield args;
            } catch (_) {
              return;
            }
          }
        }
        /**
         * Emit the signal, invoke the connected slots, and yield the emission.
         *
         * @param args - The args to pass to the connected slots.
         */
        emit(args) {
          const pending = this._pending;
          const next = this._pending = new coreutils.PromiseDelegate();
          pending.resolve({ args, next });
          super.emit(args);
        }
        /**
         * Stop the stream's async iteration.
         */
        stop() {
          this._pending.promise.catch(() => void 0);
          this._pending.reject("stop");
          this._pending = new coreutils.PromiseDelegate();
        }
      }
      var Private;
      (function(Private2) {
        Private2.exceptionHandler = (err) => {
          console.error(err);
        };
        function connect(signal, slot, thisArg) {
          thisArg = thisArg || void 0;
          let receivers = receiversForSender.get(signal.sender);
          if (!receivers) {
            receivers = [];
            receiversForSender.set(signal.sender, receivers);
          }
          if (findConnection(receivers, signal, slot, thisArg)) {
            return false;
          }
          let receiver = thisArg || slot;
          let senders = sendersForReceiver.get(receiver);
          if (!senders) {
            senders = [];
            sendersForReceiver.set(receiver, senders);
          }
          let connection = { signal, slot, thisArg };
          receivers.push(connection);
          senders.push(connection);
          return true;
        }
        Private2.connect = connect;
        function disconnect(signal, slot, thisArg) {
          thisArg = thisArg || void 0;
          let receivers = receiversForSender.get(signal.sender);
          if (!receivers || receivers.length === 0) {
            return false;
          }
          let connection = findConnection(receivers, signal, slot, thisArg);
          if (!connection) {
            return false;
          }
          let receiver = thisArg || slot;
          let senders = sendersForReceiver.get(receiver);
          connection.signal = null;
          scheduleCleanup(receivers);
          scheduleCleanup(senders);
          return true;
        }
        Private2.disconnect = disconnect;
        function disconnectBetween(sender, receiver) {
          let receivers = receiversForSender.get(sender);
          if (!receivers || receivers.length === 0) {
            return;
          }
          let senders = sendersForReceiver.get(receiver);
          if (!senders || senders.length === 0) {
            return;
          }
          for (const connection of senders) {
            if (!connection.signal) {
              continue;
            }
            if (connection.signal.sender === sender) {
              connection.signal = null;
            }
          }
          scheduleCleanup(receivers);
          scheduleCleanup(senders);
        }
        Private2.disconnectBetween = disconnectBetween;
        function disconnectSender(sender) {
          let receivers = receiversForSender.get(sender);
          if (!receivers || receivers.length === 0) {
            return;
          }
          for (const connection of receivers) {
            if (!connection.signal) {
              continue;
            }
            let receiver = connection.thisArg || connection.slot;
            connection.signal = null;
            scheduleCleanup(sendersForReceiver.get(receiver));
          }
          scheduleCleanup(receivers);
        }
        Private2.disconnectSender = disconnectSender;
        function disconnectReceiver(receiver) {
          let senders = sendersForReceiver.get(receiver);
          if (!senders || senders.length === 0) {
            return;
          }
          for (const connection of senders) {
            if (!connection.signal) {
              continue;
            }
            let sender = connection.signal.sender;
            connection.signal = null;
            scheduleCleanup(receiversForSender.get(sender));
          }
          scheduleCleanup(senders);
        }
        Private2.disconnectReceiver = disconnectReceiver;
        function disconnectAll(object) {
          disconnectSender(object);
          disconnectReceiver(object);
        }
        Private2.disconnectAll = disconnectAll;
        function emit(signal, args) {
          let receivers = receiversForSender.get(signal.sender);
          if (!receivers || receivers.length === 0) {
            return;
          }
          for (let i = 0, n = receivers.length; i < n; ++i) {
            let connection = receivers[i];
            if (connection.signal === signal) {
              invokeSlot(connection, args);
            }
          }
        }
        Private2.emit = emit;
        const receiversForSender = /* @__PURE__ */ new WeakMap();
        const sendersForReceiver = /* @__PURE__ */ new WeakMap();
        const dirtySet = /* @__PURE__ */ new Set();
        const schedule = (() => {
          let ok = typeof requestAnimationFrame === "function";
          return ok ? requestAnimationFrame : setImmediate;
        })();
        function findConnection(connections, signal, slot, thisArg) {
          return algorithm.find(connections, (connection) => connection.signal === signal && connection.slot === slot && connection.thisArg === thisArg);
        }
        function invokeSlot(connection, args) {
          let { signal, slot, thisArg } = connection;
          try {
            slot.call(thisArg, signal.sender, args);
          } catch (err) {
            Private2.exceptionHandler(err);
          }
        }
        function scheduleCleanup(array) {
          if (dirtySet.size === 0) {
            schedule(cleanupDirtySet);
          }
          dirtySet.add(array);
        }
        function cleanupDirtySet() {
          dirtySet.forEach(cleanupConnections);
          dirtySet.clear();
        }
        function cleanupConnections(connections) {
          algorithm.ArrayExt.removeAllWhere(connections, isDeadConnection);
        }
        function isDeadConnection(connection) {
          return connection.signal === null;
        }
      })(Private || (Private = {}));
      exports3.Signal = Signal;
      exports3.Stream = Stream;
    });
  }
});

// node_modules/@jupyterlab/coreutils/lib/activitymonitor.js
var require_activitymonitor = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/activitymonitor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityMonitor = void 0;
    var signaling_1 = require_dist2();
    var ActivityMonitor = class {
      /**
       * Construct a new activity monitor.
       */
      constructor(options) {
        this._timer = -1;
        this._timeout = -1;
        this._isDisposed = false;
        this._activityStopped = new signaling_1.Signal(this);
        options.signal.connect(this._onSignalFired, this);
        this._timeout = options.timeout || 1e3;
      }
      /**
       * A signal emitted when activity has ceased.
       */
      get activityStopped() {
        return this._activityStopped;
      }
      /**
       * The timeout associated with the monitor, in milliseconds.
       */
      get timeout() {
        return this._timeout;
      }
      set timeout(value) {
        this._timeout = value;
      }
      /**
       * Test whether the monitor has been disposed.
       *
       * #### Notes
       * This is a read-only property.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the activity monitor.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * A signal handler for the monitored signal.
       */
      _onSignalFired(sender, args) {
        clearTimeout(this._timer);
        this._sender = sender;
        this._args = args;
        this._timer = setTimeout(() => {
          this._activityStopped.emit({
            sender: this._sender,
            args: this._args
          });
        }, this._timeout);
      }
    };
    exports2.ActivityMonitor = ActivityMonitor;
  }
});

// node_modules/@jupyterlab/coreutils/lib/interfaces.js
var require_interfaces = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@jupyterlab/coreutils/lib/lru.js
var require_lru = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LruCache = void 0;
    var DEFAULT_MAX_SIZE = 128;
    var LruCache = class {
      constructor(options = {}) {
        this._map = /* @__PURE__ */ new Map();
        this._maxSize = (options === null || options === void 0 ? void 0 : options.maxSize) || DEFAULT_MAX_SIZE;
      }
      /**
       * Return the current size of the cache.
       */
      get size() {
        return this._map.size;
      }
      /**
       * Clear the values in the cache.
       */
      clear() {
        this._map.clear();
      }
      /**
       * Get a value (or null) from the cache, pushing the item to the front of the cache.
       */
      get(key) {
        const item = this._map.get(key) || null;
        if (item != null) {
          this._map.delete(key);
          this._map.set(key, item);
        }
        return item;
      }
      /**
       * Set a value in the cache, potentially evicting an old item.
       */
      set(key, value) {
        if (this._map.size >= this._maxSize) {
          this._map.delete(this._map.keys().next().value);
        }
        this._map.set(key, value);
      }
    };
    exports2.LruCache = LruCache;
  }
});

// node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js
var require_markdowncodeblocks = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/markdowncodeblocks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MarkdownCodeBlocks = void 0;
    var MarkdownCodeBlocks;
    (function(MarkdownCodeBlocks2) {
      MarkdownCodeBlocks2.CODE_BLOCK_MARKER = "```";
      const markdownExtensions = [
        ".markdown",
        ".mdown",
        ".mkdn",
        ".md",
        ".mkd",
        ".mdwn",
        ".mdtxt",
        ".mdtext",
        ".text",
        ".txt",
        ".Rmd"
      ];
      class MarkdownCodeBlock {
        constructor(startLine) {
          this.startLine = startLine;
          this.code = "";
          this.endLine = -1;
        }
      }
      MarkdownCodeBlocks2.MarkdownCodeBlock = MarkdownCodeBlock;
      function isMarkdown(extension) {
        return markdownExtensions.indexOf(extension) > -1;
      }
      MarkdownCodeBlocks2.isMarkdown = isMarkdown;
      function findMarkdownCodeBlocks(text) {
        if (!text || text === "") {
          return [];
        }
        const lines = text.split("\n");
        const codeBlocks = [];
        let currentBlock = null;
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          const lineContainsMarker = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER) === 0;
          const constructingBlock = currentBlock != null;
          if (!lineContainsMarker && !constructingBlock) {
            continue;
          }
          if (!constructingBlock) {
            currentBlock = new MarkdownCodeBlock(lineIndex);
            const firstIndex = line.indexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const lastIndex = line.lastIndexOf(MarkdownCodeBlocks2.CODE_BLOCK_MARKER);
            const isSingleLine = firstIndex !== lastIndex;
            if (isSingleLine) {
              currentBlock.code = line.substring(firstIndex + MarkdownCodeBlocks2.CODE_BLOCK_MARKER.length, lastIndex);
              currentBlock.endLine = lineIndex;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            }
          } else if (currentBlock) {
            if (lineContainsMarker) {
              currentBlock.endLine = lineIndex - 1;
              codeBlocks.push(currentBlock);
              currentBlock = null;
            } else {
              currentBlock.code += line + "\n";
            }
          }
        }
        return codeBlocks;
      }
      MarkdownCodeBlocks2.findMarkdownCodeBlocks = findMarkdownCodeBlocks;
    })(MarkdownCodeBlocks || (exports2.MarkdownCodeBlocks = MarkdownCodeBlocks = {}));
  }
});

// node_modules/minimist/index.js
var require_minimist = __commonJS({
  "node_modules/minimist/index.js"(exports2, module2) {
    "use strict";
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number") {
        return true;
      }
      if (/^0x[0-9a-f]+$/i.test(x)) {
        return true;
      }
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function isConstructorOrProto(obj, key) {
      return key === "constructor" && typeof obj[key] === "function" || key === "__proto__";
    }
    module2.exports = function(args, opts) {
      if (!opts) {
        opts = {};
      }
      var flags = {
        bools: {},
        strings: {},
        unknownFn: null
      };
      if (typeof opts.unknown === "function") {
        flags.unknownFn = opts.unknown;
      }
      if (typeof opts.boolean === "boolean" && opts.boolean) {
        flags.allBools = true;
      } else {
        [].concat(opts.boolean).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          [].concat(aliases[key2]).forEach(function(k) {
            flags.strings[k] = true;
          });
        }
      });
      var defaults = opts.default || {};
      var argv = { _: [] };
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (isConstructorOrProto(o, key2)) {
            return;
          }
          if (o[key2] === void 0) {
            o[key2] = {};
          }
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype) {
            o[key2] = {};
          }
          if (o[key2] === Array.prototype) {
            o[key2] = [];
          }
          o = o[key2];
        }
        var lastKey = keys[keys.length - 1];
        if (isConstructorOrProto(o, lastKey)) {
          return;
        }
        if (o === Object.prototype || o === Number.prototype || o === String.prototype) {
          o = {};
        }
        if (o === Array.prototype) {
          o = [];
        }
        if (o[lastKey] === void 0 || flags.bools[lastKey] || typeof o[lastKey] === "boolean") {
          o[lastKey] = value2;
        } else if (Array.isArray(o[lastKey])) {
          o[lastKey].push(value2);
        } else {
          o[lastKey] = [o[lastKey], value2];
        }
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false) {
            return;
          }
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var key;
        var next;
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          key = arg.match(/^--(.+)/)[1];
          next = args[i + 1];
          if (next !== void 0 && !/^(-|--)[^-]/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i += 1;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i += 1;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && next[0] === "=") {
              setArg(letters[j], next.slice(1), arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i += 1;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i += 1;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(k) {
        if (!hasKey(argv, k.split("."))) {
          setKey(argv, k.split("."), defaults[k]);
          (aliases[k] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[k]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = notFlags.slice();
      } else {
        notFlags.forEach(function(k) {
          argv._.push(k);
        });
      }
      return argv;
    };
  }
});

// node_modules/requires-port/index.js
var require_requires_port = __commonJS({
  "node_modules/requires-port/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port)
        return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
  }
});

// node_modules/querystringify/index.js
var require_querystringify = __commonJS({
  "node_modules/querystringify/index.js"(exports2) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var undef;
    function decode(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, " "));
      } catch (e) {
        return null;
      }
    }
    function encode(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
      while (part = parser.exec(query)) {
        var key = decode(part[1]), value = decode(part[2]);
        if (key === null || value === null || key in result)
          continue;
        result[key] = value;
      }
      return result;
    }
    function querystringify(obj, prefix) {
      prefix = prefix || "";
      var pairs = [], value, key;
      if ("string" !== typeof prefix)
        prefix = "?";
      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = "";
          }
          key = encode(key);
          value = encode(value);
          if (key === null || value === null)
            continue;
          pairs.push(key + "=" + value);
        }
      }
      return pairs.length ? prefix + pairs.join("&") : "";
    }
    exports2.stringify = querystringify;
    exports2.parse = querystring;
  }
});

// node_modules/url-parse/index.js
var require_url_parse = __commonJS({
  "node_modules/url-parse/index.js"(exports2, module2) {
    "use strict";
    var required = require_requires_port();
    var qs = require_querystringify();
    var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
    var CRHTLF = /[\n\r\t]/g;
    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
    var port = /:\d+$/;
    var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
    var windowsDriveLetter = /^[a-zA-Z]:/;
    function trimLeft(str) {
      return (str ? str : "").toString().replace(controlOrWhitespace, "");
    }
    var rules = [
      ["#", "hash"],
      // Extract from the back.
      ["?", "query"],
      // Extract from the back.
      function sanitize(address, url) {
        return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
      },
      ["/", "pathname"],
      // Extract from the back.
      ["@", "auth", 1],
      // Extract from the front.
      [NaN, "host", void 0, 1, 1],
      // Set left over value.
      [/:(\d*)$/, "port", void 0, 1],
      // RegExp the back.
      [NaN, "hostname", void 0, 1, 1]
      // Set left over.
    ];
    var ignore = { hash: 1, query: 1 };
    function lolcation(loc) {
      var globalVar;
      if (typeof window !== "undefined")
        globalVar = window;
      else if (typeof global !== "undefined")
        globalVar = global;
      else if (typeof self !== "undefined")
        globalVar = self;
      else
        globalVar = {};
      var location2 = globalVar.location || {};
      loc = loc || location2;
      var finaldestination = {}, type = typeof loc, key;
      if ("blob:" === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ("string" === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore)
          delete finaldestination[key];
      } else if ("object" === type) {
        for (key in loc) {
          if (key in ignore)
            continue;
          finaldestination[key] = loc[key];
        }
        if (finaldestination.slashes === void 0) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }
      return finaldestination;
    }
    function isSpecial(scheme) {
      return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
    }
    function extractProtocol(address, location2) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      location2 = location2 || {};
      var match = protocolre.exec(address);
      var protocol = match[1] ? match[1].toLowerCase() : "";
      var forwardSlashes = !!match[2];
      var otherSlashes = !!match[3];
      var slashesCount = 0;
      var rest;
      if (forwardSlashes) {
        if (otherSlashes) {
          rest = match[2] + match[3] + match[4];
          slashesCount = match[2].length + match[3].length;
        } else {
          rest = match[2] + match[4];
          slashesCount = match[2].length;
        }
      } else {
        if (otherSlashes) {
          rest = match[3] + match[4];
          slashesCount = match[3].length;
        } else {
          rest = match[4];
        }
      }
      if (protocol === "file:") {
        if (slashesCount >= 2) {
          rest = rest.slice(2);
        }
      } else if (isSpecial(protocol)) {
        rest = match[4];
      } else if (protocol) {
        if (forwardSlashes) {
          rest = rest.slice(2);
        }
      } else if (slashesCount >= 2 && isSpecial(location2.protocol)) {
        rest = match[4];
      }
      return {
        protocol,
        slashes: forwardSlashes || isSpecial(protocol),
        slashesCount,
        rest
      };
    }
    function resolve(relative, base) {
      if (relative === "")
        return base;
      var path2 = (base || "/").split("/").slice(0, -1).concat(relative.split("/")), i = path2.length, last = path2[i - 1], unshift = false, up = 0;
      while (i--) {
        if (path2[i] === ".") {
          path2.splice(i, 1);
        } else if (path2[i] === "..") {
          path2.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0)
            unshift = true;
          path2.splice(i, 1);
          up--;
        }
      }
      if (unshift)
        path2.unshift("");
      if (last === "." || last === "..")
        path2.push("");
      return path2.join("/");
    }
    function Url(address, location2, parser) {
      address = trimLeft(address);
      address = address.replace(CRHTLF, "");
      if (!(this instanceof Url)) {
        return new Url(address, location2, parser);
      }
      var relative, extracted, parse, instruction, index, key, instructions = rules.slice(), type = typeof location2, url = this, i = 0;
      if ("object" !== type && "string" !== type) {
        parser = location2;
        location2 = null;
      }
      if (parser && "function" !== typeof parser)
        parser = qs.parse;
      location2 = lolcation(location2);
      extracted = extractProtocol(address || "", location2);
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location2.slashes;
      url.protocol = extracted.protocol || location2.protocol || "";
      address = extracted.rest;
      if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
        instructions[3] = [/(.*)/, "pathname"];
      }
      for (; i < instructions.length; i++) {
        instruction = instructions[i];
        if (typeof instruction === "function") {
          address = instruction(address, url);
          continue;
        }
        parse = instruction[0];
        key = instruction[1];
        if (parse !== parse) {
          url[key] = address;
        } else if ("string" === typeof parse) {
          index = parse === "@" ? address.lastIndexOf(parse) : address.indexOf(parse);
          if (~index) {
            if ("number" === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if (index = parse.exec(address)) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }
        url[key] = url[key] || (relative && instruction[3] ? location2[key] || "" : "");
        if (instruction[4])
          url[key] = url[key].toLowerCase();
      }
      if (parser)
        url.query = parser(url.query);
      if (relative && location2.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location2.pathname !== "")) {
        url.pathname = resolve(url.pathname, location2.pathname);
      }
      if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
        url.pathname = "/" + url.pathname;
      }
      if (!required(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = "";
      }
      url.username = url.password = "";
      if (url.auth) {
        index = url.auth.indexOf(":");
        if (~index) {
          url.username = url.auth.slice(0, index);
          url.username = encodeURIComponent(decodeURIComponent(url.username));
          url.password = url.auth.slice(index + 1);
          url.password = encodeURIComponent(decodeURIComponent(url.password));
        } else {
          url.username = encodeURIComponent(decodeURIComponent(url.auth));
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
      }
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
    }
    function set(part, value, fn) {
      var url = this;
      switch (part) {
        case "query":
          if ("string" === typeof value && value.length) {
            value = (fn || qs.parse)(value);
          }
          url[part] = value;
          break;
        case "port":
          url[part] = value;
          if (!required(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = "";
          } else if (value) {
            url.host = url.hostname + ":" + value;
          }
          break;
        case "hostname":
          url[part] = value;
          if (url.port)
            value += ":" + url.port;
          url.host = value;
          break;
        case "host":
          url[part] = value;
          if (port.test(value)) {
            value = value.split(":");
            url.port = value.pop();
            url.hostname = value.join(":");
          } else {
            url.hostname = value;
            url.port = "";
          }
          break;
        case "protocol":
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;
        case "pathname":
        case "hash":
          if (value) {
            var char = part === "pathname" ? "/" : "#";
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;
        case "username":
        case "password":
          url[part] = encodeURIComponent(value);
          break;
        case "auth":
          var index = value.indexOf(":");
          if (~index) {
            url.username = value.slice(0, index);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = value.slice(index + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(value));
          }
      }
      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];
        if (ins[4])
          url[ins[1]] = url[ins[1]].toLowerCase();
      }
      url.auth = url.password ? url.username + ":" + url.password : url.username;
      url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
      url.href = url.toString();
      return url;
    }
    function toString(stringify) {
      if (!stringify || "function" !== typeof stringify)
        stringify = qs.stringify;
      var query, url = this, host = url.host, protocol = url.protocol;
      if (protocol && protocol.charAt(protocol.length - 1) !== ":")
        protocol += ":";
      var result = protocol + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
      if (url.username) {
        result += url.username;
        if (url.password)
          result += ":" + url.password;
        result += "@";
      } else if (url.password) {
        result += ":" + url.password;
        result += "@";
      } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
        result += "@";
      }
      if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
        host += ":";
      }
      result += host + url.pathname;
      query = "object" === typeof url.query ? stringify(url.query) : url.query;
      if (query)
        result += "?" !== query.charAt(0) ? "?" + query : query;
      if (url.hash)
        result += url.hash;
      return result;
    }
    Url.prototype = { set, toString };
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = qs;
    module2.exports = Url;
  }
});

// node_modules/@jupyterlab/coreutils/lib/url.js
var require_url = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/url.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.URLExt = void 0;
    var path_1 = require("path");
    var url_parse_1 = __importDefault2(require_url_parse());
    var URLExt;
    (function(URLExt2) {
      function parse(url) {
        if (typeof document !== "undefined" && document) {
          const a = document.createElement("a");
          a.href = url;
          return a;
        }
        return (0, url_parse_1.default)(url);
      }
      URLExt2.parse = parse;
      function getHostName2(url) {
        return (0, url_parse_1.default)(url).hostname;
      }
      URLExt2.getHostName = getHostName2;
      function normalize(url) {
        return url && parse(url).toString();
      }
      URLExt2.normalize = normalize;
      function join(...parts) {
        let u = (0, url_parse_1.default)(parts[0], {});
        const isSchemaLess = u.protocol === "" && u.slashes;
        if (isSchemaLess) {
          u = (0, url_parse_1.default)(parts[0], "https:" + parts[0]);
        }
        const prefix = `${isSchemaLess ? "" : u.protocol}${u.slashes ? "//" : ""}${u.auth}${u.auth ? "@" : ""}${u.host}`;
        const path2 = path_1.posix.join(`${!!prefix && u.pathname[0] !== "/" ? "/" : ""}${u.pathname}`, ...parts.slice(1));
        return `${prefix}${path2 === "." ? "" : path2}`;
      }
      URLExt2.join = join;
      function encodeParts(url) {
        return join(...url.split("/").map(encodeURIComponent));
      }
      URLExt2.encodeParts = encodeParts;
      function objectToQueryString(value) {
        const keys = Object.keys(value).filter((key) => key.length > 0);
        if (!keys.length) {
          return "";
        }
        return "?" + keys.map((key) => {
          const content = encodeURIComponent(String(value[key]));
          return key + (content ? "=" + content : "");
        }).join("&");
      }
      URLExt2.objectToQueryString = objectToQueryString;
      function queryStringToObject(value) {
        return value.replace(/^\?/, "").split("&").reduce((acc, val) => {
          const [key, value2] = val.split("=");
          if (key.length > 0) {
            acc[key] = decodeURIComponent(value2 || "");
          }
          return acc;
        }, {});
      }
      URLExt2.queryStringToObject = queryStringToObject;
      function isLocal(url, allowRoot = false) {
        const { protocol } = parse(url);
        return (!protocol || url.toLowerCase().indexOf(protocol) !== 0) && (allowRoot ? url.indexOf("//") !== 0 : url.indexOf("/") !== 0);
      }
      URLExt2.isLocal = isLocal;
    })(URLExt || (exports2.URLExt = URLExt = {}));
  }
});

// node_modules/@jupyterlab/coreutils/lib/pageconfig.js
var require_pageconfig = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/pageconfig.js"(exports, module) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageConfig = void 0;
    var coreutils_1 = require_index_node();
    var minimist_1 = __importDefault(require_minimist());
    var url_1 = require_url();
    var PageConfig;
    (function(PageConfig) {
      function getOption(name) {
        if (configData) {
          return configData[name] || getBodyData(name);
        }
        configData = /* @__PURE__ */ Object.create(null);
        let found = false;
        if (typeof document !== "undefined" && document) {
          const el = document.getElementById("jupyter-config-data");
          if (el) {
            configData = JSON.parse(el.textContent || "");
            found = true;
          }
        }
        if (!found && typeof process !== "undefined" && process.argv) {
          try {
            const cli = (0, minimist_1.default)(process.argv.slice(2));
            const path = require("path");
            let fullPath = "";
            if ("jupyter-config-data" in cli) {
              fullPath = path.resolve(cli["jupyter-config-data"]);
            } else if ("JUPYTER_CONFIG_DATA" in process.env) {
              fullPath = path.resolve(process.env["JUPYTER_CONFIG_DATA"]);
            }
            if (fullPath) {
              configData = eval("require")(fullPath);
            }
          } catch (e) {
            console.error(e);
          }
        }
        if (!coreutils_1.JSONExt.isObject(configData)) {
          configData = /* @__PURE__ */ Object.create(null);
        } else {
          for (const key in configData) {
            if (typeof configData[key] !== "string") {
              configData[key] = JSON.stringify(configData[key]);
            }
          }
        }
        return configData[name] || getBodyData(name);
      }
      PageConfig.getOption = getOption;
      function setOption(name2, value) {
        const last = getOption(name2);
        configData[name2] = value;
        return last;
      }
      PageConfig.setOption = setOption;
      function getBaseUrl() {
        return url_1.URLExt.normalize(getOption("baseUrl") || "/");
      }
      PageConfig.getBaseUrl = getBaseUrl;
      function getTreeUrl() {
        return url_1.URLExt.join(getBaseUrl(), getOption("treeUrl"));
      }
      PageConfig.getTreeUrl = getTreeUrl;
      function getShareUrl() {
        return url_1.URLExt.normalize(getOption("shareUrl") || getBaseUrl());
      }
      PageConfig.getShareUrl = getShareUrl;
      function getTreeShareUrl() {
        return url_1.URLExt.normalize(url_1.URLExt.join(getShareUrl(), getOption("treeUrl")));
      }
      PageConfig.getTreeShareUrl = getTreeShareUrl;
      function getUrl(options) {
        var _a, _b, _c, _d;
        let path2 = options.toShare ? getShareUrl() : getBaseUrl();
        const mode = (_a = options.mode) !== null && _a !== void 0 ? _a : getOption("mode");
        const workspace5 = (_b = options.workspace) !== null && _b !== void 0 ? _b : getOption("workspace");
        const labOrDoc = mode === "single-document" ? "doc" : "lab";
        path2 = url_1.URLExt.join(path2, labOrDoc);
        if (workspace5 !== PageConfig.defaultWorkspace) {
          path2 = url_1.URLExt.join(path2, "workspaces", encodeURIComponent((_c = getOption("workspace")) !== null && _c !== void 0 ? _c : PageConfig.defaultWorkspace));
        }
        const treePath = (_d = options.treePath) !== null && _d !== void 0 ? _d : getOption("treePath");
        if (treePath) {
          path2 = url_1.URLExt.join(path2, "tree", url_1.URLExt.encodeParts(treePath));
        }
        return path2;
      }
      PageConfig.getUrl = getUrl;
      PageConfig.defaultWorkspace = "default";
      function getWsUrl(baseUrl) {
        let wsUrl = getOption("wsUrl");
        if (!wsUrl) {
          baseUrl = baseUrl ? url_1.URLExt.normalize(baseUrl) : getBaseUrl();
          if (baseUrl.indexOf("http") !== 0) {
            return "";
          }
          wsUrl = "ws" + baseUrl.slice(4);
        }
        return url_1.URLExt.normalize(wsUrl);
      }
      PageConfig.getWsUrl = getWsUrl;
      function getNBConvertURL({ path: path2, format, download }) {
        const notebookPath = url_1.URLExt.encodeParts(path2);
        const url = url_1.URLExt.join(getBaseUrl(), "nbconvert", format, notebookPath);
        if (download) {
          return url + "?download=true";
        }
        return url;
      }
      PageConfig.getNBConvertURL = getNBConvertURL;
      function getToken() {
        return getOption("token") || getBodyData("jupyterApiToken");
      }
      PageConfig.getToken = getToken;
      function getNotebookVersion() {
        const notebookVersion = getOption("notebookVersion");
        if (notebookVersion === "") {
          return [0, 0, 0];
        }
        return JSON.parse(notebookVersion);
      }
      PageConfig.getNotebookVersion = getNotebookVersion;
      let configData = null;
      function getBodyData(key) {
        if (typeof document === "undefined" || !document.body) {
          return "";
        }
        const val = document.body.dataset[key];
        if (typeof val === "undefined") {
          return "";
        }
        return decodeURIComponent(val);
      }
      let Extension;
      (function(Extension2) {
        function populate(key) {
          try {
            const raw = getOption(key);
            if (raw) {
              return JSON.parse(raw);
            }
          } catch (error) {
            console.warn(`Unable to parse ${key}.`, error);
          }
          return [];
        }
        Extension2.deferred = populate("deferredExtensions");
        Extension2.disabled = populate("disabledExtensions");
        function isDeferred(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.deferred.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDeferred = isDeferred;
        function isDisabled(id) {
          const separatorIndex = id.indexOf(":");
          let extName = "";
          if (separatorIndex !== -1) {
            extName = id.slice(0, separatorIndex);
          }
          return Extension2.disabled.some((val) => val === id || extName && val === extName);
        }
        Extension2.isDisabled = isDisabled;
      })(Extension = PageConfig.Extension || (PageConfig.Extension = {}));
    })(PageConfig || (exports.PageConfig = PageConfig = {}));
  }
});

// node_modules/@jupyterlab/coreutils/lib/path.js
var require_path = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PathExt = void 0;
    var path_1 = require("path");
    var PathExt;
    (function(PathExt2) {
      function join(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : removeSlash(path2);
      }
      PathExt2.join = join;
      function joinWithLeadingSlash(...paths) {
        const path2 = path_1.posix.join(...paths);
        return path2 === "." ? "" : path2;
      }
      PathExt2.joinWithLeadingSlash = joinWithLeadingSlash;
      function basename(path2, ext) {
        return path_1.posix.basename(path2, ext);
      }
      PathExt2.basename = basename;
      function dirname(path2) {
        const dir = removeSlash(path_1.posix.dirname(path2));
        return dir === "." ? "" : dir;
      }
      PathExt2.dirname = dirname;
      function extname(path2) {
        return path_1.posix.extname(path2);
      }
      PathExt2.extname = extname;
      function normalize(path2) {
        if (path2 === "") {
          return "";
        }
        return removeSlash(path_1.posix.normalize(path2));
      }
      PathExt2.normalize = normalize;
      function resolve(...parts) {
        return removeSlash(path_1.posix.resolve(...parts));
      }
      PathExt2.resolve = resolve;
      function relative(from, to) {
        return removeSlash(path_1.posix.relative(from, to));
      }
      PathExt2.relative = relative;
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      PathExt2.normalizeExtension = normalizeExtension;
      function removeSlash(path2) {
        if (path2.indexOf("/") === 0) {
          path2 = path2.slice(1);
        }
        return path2;
      }
      PathExt2.removeSlash = removeSlash;
    })(PathExt || (exports2.PathExt = PathExt = {}));
  }
});

// node_modules/@jupyterlab/coreutils/lib/signal.js
var require_signal = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/signal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.signalToPromise = void 0;
    var coreutils_12 = require_index_node();
    function signalToPromise(signal, timeout) {
      const waitForSignal = new coreutils_12.PromiseDelegate();
      function cleanup() {
        signal.disconnect(slot);
      }
      function slot(sender, args) {
        cleanup();
        waitForSignal.resolve([sender, args]);
      }
      signal.connect(slot);
      if ((timeout !== null && timeout !== void 0 ? timeout : 0) > 0) {
        setTimeout(() => {
          cleanup();
          waitForSignal.reject(`Signal not emitted within ${timeout} ms.`);
        }, timeout);
      }
      return waitForSignal.promise;
    }
    exports2.signalToPromise = signalToPromise;
  }
});

// node_modules/@jupyterlab/coreutils/lib/text.js
var require_text = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Text = void 0;
    var Text;
    (function(Text2) {
      const HAS_SURROGATES = "\u{1D41A}".length > 1;
      function jsIndexToCharIndex(jsIdx, text) {
        if (HAS_SURROGATES) {
          return jsIdx;
        }
        let charIdx = jsIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              charIdx--;
              i++;
            }
          }
        }
        return charIdx;
      }
      Text2.jsIndexToCharIndex = jsIndexToCharIndex;
      function charIndexToJsIndex(charIdx, text) {
        if (HAS_SURROGATES) {
          return charIdx;
        }
        let jsIdx = charIdx;
        for (let i = 0; i + 1 < text.length && i < jsIdx; i++) {
          const charCode = text.charCodeAt(i);
          if (charCode >= 55296 && charCode <= 56319) {
            const nextCharCode = text.charCodeAt(i + 1);
            if (nextCharCode >= 56320 && nextCharCode <= 57343) {
              jsIdx++;
              i++;
            }
          }
        }
        return jsIdx;
      }
      Text2.charIndexToJsIndex = charIndexToJsIndex;
      function camelCase(str, upper = false) {
        return str.replace(/^(\w)|[\s-_:]+(\w)/g, function(match, p1, p2) {
          if (p2) {
            return p2.toUpperCase();
          } else {
            return upper ? p1.toUpperCase() : p1.toLowerCase();
          }
        });
      }
      Text2.camelCase = camelCase;
      function titleCase(str) {
        return (str || "").toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      Text2.titleCase = titleCase;
    })(Text || (exports2.Text = Text = {}));
  }
});

// node_modules/@jupyterlab/coreutils/lib/time.js
var require_time = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Time = void 0;
    var UNITS = [
      { name: "years", milliseconds: 365 * 24 * 60 * 60 * 1e3 },
      { name: "months", milliseconds: 30 * 24 * 60 * 60 * 1e3 },
      { name: "days", milliseconds: 24 * 60 * 60 * 1e3 },
      { name: "hours", milliseconds: 60 * 60 * 1e3 },
      { name: "minutes", milliseconds: 60 * 1e3 },
      { name: "seconds", milliseconds: 1e3 }
    ];
    var Time;
    (function(Time2) {
      function formatHuman(value, format2 = "long") {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.RelativeTimeFormat(lang, {
          numeric: "auto",
          style: format2
        });
        const delta = new Date(value).getTime() - Date.now();
        for (let unit of UNITS) {
          const amount = Math.ceil(delta / unit.milliseconds);
          if (amount === 0) {
            continue;
          }
          return formatter.format(amount, unit.name);
        }
        return formatter.format(0, "seconds");
      }
      Time2.formatHuman = formatHuman;
      function format(value) {
        const lang = document.documentElement.lang || "en";
        const formatter = new Intl.DateTimeFormat(lang, {
          dateStyle: "short",
          timeStyle: "short"
        });
        return formatter.format(new Date(value));
      }
      Time2.format = format;
    })(Time || (exports2.Time = Time = {}));
  }
});

// node_modules/@jupyterlab/coreutils/lib/index.js
var require_lib = __commonJS({
  "node_modules/@jupyterlab/coreutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_activitymonitor(), exports2);
    __exportStar(require_interfaces(), exports2);
    __exportStar(require_lru(), exports2);
    __exportStar(require_markdowncodeblocks(), exports2);
    __exportStar(require_pageconfig(), exports2);
    __exportStar(require_path(), exports2);
    __exportStar(require_signal(), exports2);
    __exportStar(require_text(), exports2);
    __exportStar(require_time(), exports2);
    __exportStar(require_url(), exports2);
  }
});

// node_modules/@jupyterlab/services/lib/kernel/messages.js
var require_messages = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.supportedKernelWebSocketProtocols = exports2.isInputReplyMsg = exports2.isInputRequestMsg = exports2.isDebugReplyMsg = exports2.isDebugRequestMsg = exports2.isExecuteReplyMsg = exports2.isInfoRequestMsg = exports2.isCommMsgMsg = exports2.isCommCloseMsg = exports2.isCommOpenMsg = exports2.isDebugEventMsg = exports2.isClearOutputMsg = exports2.isStatusMsg = exports2.isErrorMsg = exports2.isExecuteResultMsg = exports2.isExecuteInputMsg = exports2.isUpdateDisplayDataMsg = exports2.isDisplayDataMsg = exports2.isStreamMsg = exports2.createMessage = void 0;
    var coreutils_12 = require_index_node();
    function createMessage(options) {
      var _a, _b, _c, _d, _e;
      return {
        buffers: (_a = options.buffers) !== null && _a !== void 0 ? _a : [],
        channel: options.channel,
        content: options.content,
        header: {
          date: (/* @__PURE__ */ new Date()).toISOString(),
          msg_id: (_b = options.msgId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4(),
          msg_type: options.msgType,
          session: options.session,
          username: (_c = options.username) !== null && _c !== void 0 ? _c : "",
          version: "5.2"
        },
        metadata: (_d = options.metadata) !== null && _d !== void 0 ? _d : {},
        parent_header: (_e = options.parentHeader) !== null && _e !== void 0 ? _e : {}
      };
    }
    exports2.createMessage = createMessage;
    function isStreamMsg(msg) {
      return msg.header.msg_type === "stream";
    }
    exports2.isStreamMsg = isStreamMsg;
    function isDisplayDataMsg(msg) {
      return msg.header.msg_type === "display_data";
    }
    exports2.isDisplayDataMsg = isDisplayDataMsg;
    function isUpdateDisplayDataMsg(msg) {
      return msg.header.msg_type === "update_display_data";
    }
    exports2.isUpdateDisplayDataMsg = isUpdateDisplayDataMsg;
    function isExecuteInputMsg(msg) {
      return msg.header.msg_type === "execute_input";
    }
    exports2.isExecuteInputMsg = isExecuteInputMsg;
    function isExecuteResultMsg(msg) {
      return msg.header.msg_type === "execute_result";
    }
    exports2.isExecuteResultMsg = isExecuteResultMsg;
    function isErrorMsg(msg) {
      return msg.header.msg_type === "error";
    }
    exports2.isErrorMsg = isErrorMsg;
    function isStatusMsg(msg) {
      return msg.header.msg_type === "status";
    }
    exports2.isStatusMsg = isStatusMsg;
    function isClearOutputMsg(msg) {
      return msg.header.msg_type === "clear_output";
    }
    exports2.isClearOutputMsg = isClearOutputMsg;
    function isDebugEventMsg(msg) {
      return msg.header.msg_type === "debug_event";
    }
    exports2.isDebugEventMsg = isDebugEventMsg;
    function isCommOpenMsg(msg) {
      return msg.header.msg_type === "comm_open";
    }
    exports2.isCommOpenMsg = isCommOpenMsg;
    function isCommCloseMsg(msg) {
      return msg.header.msg_type === "comm_close";
    }
    exports2.isCommCloseMsg = isCommCloseMsg;
    function isCommMsgMsg(msg) {
      return msg.header.msg_type === "comm_msg";
    }
    exports2.isCommMsgMsg = isCommMsgMsg;
    function isInfoRequestMsg(msg) {
      return msg.header.msg_type === "kernel_info_request";
    }
    exports2.isInfoRequestMsg = isInfoRequestMsg;
    function isExecuteReplyMsg(msg) {
      return msg.header.msg_type === "execute_reply";
    }
    exports2.isExecuteReplyMsg = isExecuteReplyMsg;
    function isDebugRequestMsg(msg) {
      return msg.header.msg_type === "debug_request";
    }
    exports2.isDebugRequestMsg = isDebugRequestMsg;
    function isDebugReplyMsg(msg) {
      return msg.header.msg_type === "debug_reply";
    }
    exports2.isDebugReplyMsg = isDebugReplyMsg;
    function isInputRequestMsg(msg) {
      return msg.header.msg_type === "input_request";
    }
    exports2.isInputRequestMsg = isInputRequestMsg;
    function isInputReplyMsg(msg) {
      return msg.header.msg_type === "input_reply";
    }
    exports2.isInputReplyMsg = isInputReplyMsg;
    var supportedKernelWebSocketProtocols;
    (function(supportedKernelWebSocketProtocols2) {
      supportedKernelWebSocketProtocols2["v1KernelWebsocketJupyterOrg"] = "v1.kernel.websocket.jupyter.org";
    })(supportedKernelWebSocketProtocols || (exports2.supportedKernelWebSocketProtocols = supportedKernelWebSocketProtocols = {}));
  }
});

// node_modules/@jupyterlab/services/lib/kernel/serialize.js
var require_serialize = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/serialize.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserialize = exports2.serialize = void 0;
    var KernelMessage = __importStar(require_messages());
    function serialize(msg, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private.serializeV1KernelWebsocketJupyterOrg(msg);
        default:
          return Private.serializeDefault(msg);
      }
    }
    exports2.serialize = serialize;
    function deserialize(data, protocol = "") {
      switch (protocol) {
        case KernelMessage.supportedKernelWebSocketProtocols.v1KernelWebsocketJupyterOrg:
          return Private.deserializeV1KernelWebsocketJupyterOrg(data);
        default:
          return Private.deserializeDefault(data);
      }
    }
    exports2.deserialize = deserialize;
    var Private;
    (function(Private2) {
      function deserializeV1KernelWebsocketJupyterOrg(binMsg) {
        let msg;
        const data = new DataView(binMsg);
        const offsetNumber = Number(data.getBigUint64(
          0,
          true
          /* littleEndian */
        ));
        let offsets = [];
        for (let i = 0; i < offsetNumber; i++) {
          offsets.push(Number(data.getBigUint64(
            8 * (i + 1),
            true
            /* littleEndian */
          )));
        }
        const decoder = new TextDecoder("utf8");
        const channel = decoder.decode(binMsg.slice(offsets[0], offsets[1]));
        const header = JSON.parse(decoder.decode(binMsg.slice(offsets[1], offsets[2])));
        const parent_header = JSON.parse(decoder.decode(binMsg.slice(offsets[2], offsets[3])));
        const metadata = JSON.parse(decoder.decode(binMsg.slice(offsets[3], offsets[4])));
        const content = JSON.parse(decoder.decode(binMsg.slice(offsets[4], offsets[5])));
        let buffers = [];
        for (let i = 5; i < offsets.length - 1; i++) {
          buffers.push(new DataView(binMsg.slice(offsets[i], offsets[i + 1])));
        }
        msg = {
          channel,
          header,
          parent_header,
          metadata,
          content,
          buffers
        };
        return msg;
      }
      Private2.deserializeV1KernelWebsocketJupyterOrg = deserializeV1KernelWebsocketJupyterOrg;
      function serializeV1KernelWebsocketJupyterOrg(msg) {
        const header = JSON.stringify(msg.header);
        const parentHeader = msg.parent_header == null ? "{}" : JSON.stringify(msg.parent_header);
        const metadata = JSON.stringify(msg.metadata);
        const content = JSON.stringify(msg.content);
        const buffers = msg.buffers !== void 0 ? msg.buffers : [];
        const offsetNumber = 1 + 4 + buffers.length + 1;
        let offsets = [];
        offsets.push(8 * (1 + offsetNumber));
        offsets.push(msg.channel.length + offsets[offsets.length - 1]);
        const encoder = new TextEncoder();
        const channelEncoded = encoder.encode(msg.channel);
        const headerEncoded = encoder.encode(header);
        const parentHeaderEncoded = encoder.encode(parentHeader);
        const metadataEncoded = encoder.encode(metadata);
        const contentEncoded = encoder.encode(content);
        const binMsgNoBuff = new Uint8Array(channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length + contentEncoded.length);
        binMsgNoBuff.set(channelEncoded);
        binMsgNoBuff.set(headerEncoded, channelEncoded.length);
        binMsgNoBuff.set(parentHeaderEncoded, channelEncoded.length + headerEncoded.length);
        binMsgNoBuff.set(metadataEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length);
        binMsgNoBuff.set(contentEncoded, channelEncoded.length + headerEncoded.length + parentHeaderEncoded.length + metadataEncoded.length);
        for (let length of [
          headerEncoded.length,
          parentHeaderEncoded.length,
          metadataEncoded.length,
          contentEncoded.length
        ]) {
          offsets.push(length + offsets[offsets.length - 1]);
        }
        let buffersByteLength = 0;
        for (let buffer of buffers) {
          let length = buffer.byteLength;
          offsets.push(length + offsets[offsets.length - 1]);
          buffersByteLength += length;
        }
        const binMsg = new Uint8Array(8 * (1 + offsetNumber) + binMsgNoBuff.byteLength + buffersByteLength);
        const word = new ArrayBuffer(8);
        const data = new DataView(word);
        data.setBigUint64(
          0,
          BigInt(offsetNumber),
          true
          /* littleEndian */
        );
        binMsg.set(new Uint8Array(word), 0);
        for (let i = 0; i < offsets.length; i++) {
          data.setBigUint64(
            0,
            BigInt(offsets[i]),
            true
            /* littleEndian */
          );
          binMsg.set(new Uint8Array(word), 8 * (i + 1));
        }
        binMsg.set(binMsgNoBuff, offsets[0]);
        for (let i = 0; i < buffers.length; i++) {
          const buffer = buffers[i];
          binMsg.set(new Uint8Array(ArrayBuffer.isView(buffer) ? buffer.buffer : buffer), offsets[5 + i]);
        }
        return binMsg.buffer;
      }
      Private2.serializeV1KernelWebsocketJupyterOrg = serializeV1KernelWebsocketJupyterOrg;
      function deserializeDefault(data) {
        let value;
        if (typeof data === "string") {
          value = JSON.parse(data);
        } else {
          value = deserializeBinary(data);
        }
        return value;
      }
      Private2.deserializeDefault = deserializeDefault;
      function serializeDefault(msg) {
        var _a;
        let value;
        if ((_a = msg.buffers) === null || _a === void 0 ? void 0 : _a.length) {
          value = serializeBinary(msg);
        } else {
          value = JSON.stringify(msg);
        }
        return value;
      }
      Private2.serializeDefault = serializeDefault;
      function deserializeBinary(buf) {
        const data = new DataView(buf);
        const nbufs = data.getUint32(0);
        const offsets = [];
        if (nbufs < 2) {
          throw new Error("Invalid incoming Kernel Message");
        }
        for (let i = 1; i <= nbufs; i++) {
          offsets.push(data.getUint32(i * 4));
        }
        const jsonBytes = new Uint8Array(buf.slice(offsets[0], offsets[1]));
        const msg = JSON.parse(new TextDecoder("utf8").decode(jsonBytes));
        msg.buffers = [];
        for (let i = 1; i < nbufs; i++) {
          const start = offsets[i];
          const stop = offsets[i + 1] || buf.byteLength;
          msg.buffers.push(new DataView(buf.slice(start, stop)));
        }
        return msg;
      }
      function serializeBinary(msg) {
        const offsets = [];
        const buffers = [];
        const encoder = new TextEncoder();
        let origBuffers = [];
        if (msg.buffers !== void 0) {
          origBuffers = msg.buffers;
          delete msg["buffers"];
        }
        const jsonUtf8 = encoder.encode(JSON.stringify(msg));
        buffers.push(jsonUtf8.buffer);
        for (let i = 0; i < origBuffers.length; i++) {
          const b = origBuffers[i];
          buffers.push(ArrayBuffer.isView(b) ? b.buffer : b);
        }
        const nbufs = buffers.length;
        offsets.push(4 * (nbufs + 1));
        for (let i = 0; i + 1 < buffers.length; i++) {
          offsets.push(offsets[offsets.length - 1] + buffers[i].byteLength);
        }
        const msgBuf = new Uint8Array(offsets[offsets.length - 1] + buffers[buffers.length - 1].byteLength);
        const view = new DataView(msgBuf.buffer);
        view.setUint32(0, nbufs);
        for (let i = 0; i < offsets.length; i++) {
          view.setUint32(4 * (i + 1), offsets[i]);
        }
        for (let i = 0; i < buffers.length; i++) {
          msgBuf.set(new Uint8Array(buffers[i]), offsets[i]);
        }
        return msgBuf.buffer;
      }
    })(Private || (Private = {}));
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored)
          cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO)
            this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            _Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name2, elem) {
      if (dest[name2] === void 0)
        dest[name2] = [elem];
      else
        dest[name2].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name2 = header.slice(start, end);
            if (code === 44) {
              push(offers, name2, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name2;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions2) {
      return Object.keys(extensions2).map((extension) => {
        let configurations = extensions2[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter4 = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter4 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        if (socket.setTimeout)
          socket.setTimeout(0);
        if (socket.setNoDelay)
          socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED)
          return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location2, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location2}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING)
          return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong)
        websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter4 = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter4 {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 8 && version !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions2, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/@jupyterlab/services/lib/serverconnection.js
var require_serverconnection = __commonJS({
  "node_modules/@jupyterlab/services/lib/serverconnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerConnection = void 0;
    var coreutils_12 = require_lib();
    var serialize_1 = require_serialize();
    var WEBSOCKET;
    if (typeof window === "undefined") {
      WEBSOCKET = require_ws();
    } else {
      WEBSOCKET = WebSocket;
    }
    var ServerConnection3;
    (function(ServerConnection4) {
      function makeSettings(options) {
        return Private.makeSettings(options);
      }
      ServerConnection4.makeSettings = makeSettings;
      function makeRequest(url, init, settings) {
        return Private.handleRequest(url, init, settings);
      }
      ServerConnection4.makeRequest = makeRequest;
      class ResponseError extends Error {
        /**
         * Create a ResponseError from a response, handling the traceback and message
         * as appropriate.
         *
         * @param response The response object.
         *
         * @returns A promise that resolves with a `ResponseError` object.
         */
        static async create(response) {
          try {
            const data = await response.json();
            const { message, traceback } = data;
            if (traceback) {
              console.error(traceback);
            }
            return new ResponseError(response, message !== null && message !== void 0 ? message : ResponseError._defaultMessage(response), traceback !== null && traceback !== void 0 ? traceback : "");
          } catch (e) {
            console.debug(e);
            return new ResponseError(response);
          }
        }
        /**
         * Create a new response error.
         */
        constructor(response, message = ResponseError._defaultMessage(response), traceback = "") {
          super(message);
          this.response = response;
          this.traceback = traceback;
        }
        static _defaultMessage(response) {
          return `Invalid response: ${response.status} ${response.statusText}`;
        }
      }
      ServerConnection4.ResponseError = ResponseError;
      class NetworkError extends TypeError {
        /**
         * Create a new network error.
         */
        constructor(original) {
          super(original.message);
          this.stack = original.stack;
        }
      }
      ServerConnection4.NetworkError = NetworkError;
    })(ServerConnection3 || (exports2.ServerConnection = ServerConnection3 = {}));
    var Private;
    (function(Private2) {
      function makeSettings(options = {}) {
        var _a;
        const pageBaseUrl = coreutils_12.PageConfig.getBaseUrl();
        const pageWsUrl = coreutils_12.PageConfig.getWsUrl();
        const baseUrl = coreutils_12.URLExt.normalize(options.baseUrl) || pageBaseUrl;
        let wsUrl = options.wsUrl;
        if (!wsUrl && baseUrl === pageBaseUrl) {
          wsUrl = pageWsUrl;
        }
        if (!wsUrl && baseUrl.indexOf("http") === 0) {
          wsUrl = "ws" + baseUrl.slice(4);
        }
        wsUrl = wsUrl !== null && wsUrl !== void 0 ? wsUrl : pageWsUrl;
        const appendTokenConfig = coreutils_12.PageConfig.getOption("appendToken").toLowerCase();
        let appendToken;
        if (appendTokenConfig === "") {
          appendToken = typeof window === "undefined" || typeof process !== "undefined" && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.JEST_WORKER_ID) !== void 0 || coreutils_12.URLExt.getHostName(pageBaseUrl) !== coreutils_12.URLExt.getHostName(wsUrl);
        } else {
          appendToken = appendTokenConfig === "true";
        }
        return {
          init: { cache: "no-store", credentials: "same-origin" },
          fetch,
          Headers,
          Request,
          WebSocket: WEBSOCKET,
          token: coreutils_12.PageConfig.getToken(),
          appUrl: coreutils_12.PageConfig.getOption("appUrl"),
          appendToken,
          serializer: { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize },
          ...options,
          baseUrl,
          wsUrl
        };
      }
      Private2.makeSettings = makeSettings;
      function handleRequest(url, init, settings) {
        var _a;
        if (url.indexOf(settings.baseUrl) !== 0) {
          throw new Error("Can only be used for notebook server requests");
        }
        const cache = (_a = init.cache) !== null && _a !== void 0 ? _a : settings.init.cache;
        if (cache === "no-store") {
          url += (/\?/.test(url) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime();
        }
        const request = new settings.Request(url, { ...settings.init, ...init });
        let authenticated = false;
        if (settings.token) {
          authenticated = true;
          request.headers.append("Authorization", `token ${settings.token}`);
        }
        if (typeof document !== "undefined") {
          const xsrfToken = getCookie("_xsrf");
          if (xsrfToken !== void 0) {
            authenticated = true;
            request.headers.append("X-XSRFToken", xsrfToken);
          }
        }
        if (!request.headers.has("Content-Type") && authenticated) {
          request.headers.set("Content-Type", "application/json");
        }
        return settings.fetch.call(null, request).catch((e) => {
          throw new ServerConnection3.NetworkError(e);
        });
      }
      Private2.handleRequest = handleRequest;
      function getCookie(name2) {
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
          return;
        }
        const matches = cookie.match("\\b" + name2 + "=([^;]*)\\b");
        return matches === null || matches === void 0 ? void 0 : matches[1];
      }
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/basemanager.js
var require_basemanager = __commonJS({
  "node_modules/@jupyterlab/services/lib/basemanager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseManager = void 0;
    var signaling_1 = require_dist2();
    var serverconnection_1 = require_serverconnection();
    var BaseManager = class {
      constructor(options) {
        var _a;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when the delegate is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * Test whether the delegate has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Whether the manager is active.
       */
      get isActive() {
        return true;
      }
      /**
       * Dispose of the delegate and invoke the callback function.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit(void 0);
        signaling_1.Signal.clearData(this);
      }
    };
    exports2.BaseManager = BaseManager;
  }
});

// node_modules/@jupyterlab/services/lib/config/index.js
var require_config = __commonJS({
  "node_modules/@jupyterlab/services/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigWithDefaults = exports2.ConfigSection = void 0;
    var coreutils_12 = require_lib();
    var __1 = require_lib3();
    var SERVICE_CONFIG_URL = "api/config";
    var ConfigSection;
    (function(ConfigSection2) {
      function create(options) {
        const section = new DefaultConfigSection(options);
        return section.load().then(() => {
          return section;
        });
      }
      ConfigSection2.create = create;
    })(ConfigSection || (exports2.ConfigSection = ConfigSection = {}));
    var DefaultConfigSection = class {
      /**
       * Construct a new config section.
       */
      constructor(options) {
        var _a;
        this._url = "unknown";
        const settings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._url = coreutils_12.URLExt.join(settings.baseUrl, SERVICE_CONFIG_URL, encodeURIComponent(options.name));
      }
      /**
       * Get the data for this section.
       */
      get data() {
        return this._data;
      }
      /**
       * Load the initial data for this section.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async load() {
        const response = await __1.ServerConnection.makeRequest(this._url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
      }
      /**
       * Modify the stored config values.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Updates the local data immediately, sends the change to the server,
       * and updates the local data with the response, and fulfils the promise
       * with that data.
       */
      async update(newdata) {
        this._data = { ...this._data, ...newdata };
        const init = {
          method: "PATCH",
          body: JSON.stringify(newdata)
        };
        const response = await __1.ServerConnection.makeRequest(this._url, init, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._data = await response.json();
        return this._data;
      }
    };
    var ConfigWithDefaults = class {
      /**
       * Create a new config with defaults.
       */
      constructor(options) {
        var _a, _b;
        this._className = "";
        this._section = options.section;
        this._defaults = (_a = options.defaults) !== null && _a !== void 0 ? _a : {};
        this._className = (_b = options.className) !== null && _b !== void 0 ? _b : "";
      }
      /**
       * Get data from the config section or fall back to defaults.
       */
      get(key) {
        const data = this._classData();
        return key in data ? data[key] : this._defaults[key];
      }
      /**
       * Set a config value.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/config).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * Sends the update to the server, and changes our local copy of the data
       * immediately.
       */
      set(key, value) {
        const d = {};
        d[key] = value;
        if (this._className) {
          const d2 = {};
          d2[this._className] = d;
          return this._section.update(d2);
        } else {
          return this._section.update(d);
        }
      }
      /**
       * Get data from the Section with our classname, if available.
       *
       * #### Notes
       * If we have no classname, get all of the data in the Section
       */
      _classData() {
        const data = this._section.data;
        if (this._className && this._className in data) {
          return data[this._className];
        }
        return data;
      }
    };
    exports2.ConfigWithDefaults = ConfigWithDefaults;
  }
});

// node_modules/@jupyterlab/services/lib/validate.js
var require_validate = __commonJS({
  "node_modules/@jupyterlab/services/lib/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateProperty = void 0;
    function validateProperty(object, name2, typeName, values = []) {
      if (!object.hasOwnProperty(name2)) {
        throw Error(`Missing property '${name2}'`);
      }
      const value = object[name2];
      if (typeName !== void 0) {
        let valid = true;
        switch (typeName) {
          case "array":
            valid = Array.isArray(value);
            break;
          case "object":
            valid = typeof value !== "undefined";
            break;
          default:
            valid = typeof value === typeName;
        }
        if (!valid) {
          throw new Error(`Property '${name2}' is not of type '${typeName}'`);
        }
        if (values.length > 0) {
          let valid2 = true;
          switch (typeName) {
            case "string":
            case "number":
            case "boolean":
              valid2 = values.includes(value);
              break;
            default:
              valid2 = values.findIndex((v) => v === value) >= 0;
              break;
          }
          if (!valid2) {
            throw new Error(`Property '${name2}' is not one of the valid values ${JSON.stringify(values)}`);
          }
        }
      }
    }
    exports2.validateProperty = validateProperty;
  }
});

// node_modules/@jupyterlab/services/lib/contents/validate.js
var require_validate2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/contents/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateCheckpointModel = exports2.validateContentsModel = void 0;
    var validate_1 = require_validate();
    function validateContentsModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "path", "string");
      (0, validate_1.validateProperty)(model, "type", "string");
      (0, validate_1.validateProperty)(model, "created", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
      (0, validate_1.validateProperty)(model, "mimetype", "object");
      (0, validate_1.validateProperty)(model, "content", "object");
      (0, validate_1.validateProperty)(model, "format", "object");
    }
    exports2.validateContentsModel = validateContentsModel;
    function validateCheckpointModel(model) {
      (0, validate_1.validateProperty)(model, "id", "string");
      (0, validate_1.validateProperty)(model, "last_modified", "string");
    }
    exports2.validateCheckpointModel = validateCheckpointModel;
  }
});

// node_modules/@jupyterlab/services/lib/contents/index.js
var require_contents = __commonJS({
  "node_modules/@jupyterlab/services/lib/contents/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Drive = exports2.ContentsManager = exports2.Contents = void 0;
    var coreutils_12 = require_lib();
    var signaling_1 = require_dist2();
    var __1 = require_lib3();
    var validate = __importStar(require_validate2());
    var SERVICE_DRIVE_URL = "api/contents";
    var FILES_URL = "files";
    var Contents;
    (function(Contents2) {
      function validateContentsModel(contents) {
        validate.validateContentsModel(contents);
      }
      Contents2.validateContentsModel = validateContentsModel;
      function validateCheckpointModel(checkpoint) {
        validate.validateCheckpointModel(checkpoint);
      }
      Contents2.validateCheckpointModel = validateCheckpointModel;
    })(Contents || (exports2.Contents = Contents = {}));
    var ContentsManager = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._additionalDrives = /* @__PURE__ */ new Map();
        this._fileChanged = new signaling_1.Signal(this);
        const serverSettings = this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._defaultDrive = (_b = options.defaultDrive) !== null && _b !== void 0 ? _b : new Drive({ serverSettings });
        this._defaultDrive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Add an `IDrive` to the manager.
       */
      addDrive(drive) {
        this._additionalDrives.set(drive.name, drive);
        drive.fileChanged.connect(this._onFileChanged, this);
      }
      /**
       * Given a path, get a shared model factory from the
       * relevant backend. Returns `null` if the backend
       * does not provide one.
       */
      getSharedModelFactory(path2) {
        var _a;
        const [drive] = this._driveForPath(path2);
        return (_a = drive === null || drive === void 0 ? void 0 : drive.sharedModelFactory) !== null && _a !== void 0 ? _a : null;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the local part of it.
       *
       * @param path the path.
       *
       * @returns The local part of the path.
       */
      localPath(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1 || !this._additionalDrives.has(firstParts[0])) {
          return coreutils_12.PathExt.removeSlash(path2);
        }
        return coreutils_12.PathExt.join(firstParts.slice(1).join(":"), ...parts.slice(1));
      }
      /**
       * Normalize a global path. Reduces '..' and '.' parts, and removes
       * leading slashes from the local part of the path, while retaining
       * the drive name if it exists.
       *
       * @param path the path.
       *
       * @returns The normalized path.
       */
      normalize(path2) {
        const parts = path2.split(":");
        if (parts.length === 1) {
          return coreutils_12.PathExt.normalize(path2);
        }
        return `${parts[0]}:${coreutils_12.PathExt.normalize(parts.slice(1).join(":"))}`;
      }
      /**
       * Resolve a global path, starting from the root path. Behaves like
       * posix-path.resolve, with 3 differences:
       *  - will never prepend cwd
       *  - if root has a drive name, the result is prefixed with "<drive>:"
       *  - before adding drive name, leading slashes are removed
       *
       * @param path the path.
       *
       * @returns The normalized path.
       */
      resolvePath(root, path2) {
        const driveName = this.driveName(root);
        const localPath = this.localPath(root);
        const resolved = coreutils_12.PathExt.resolve("/", localPath, path2);
        return driveName ? `${driveName}:${resolved}` : resolved;
      }
      /**
       * Given a path of the form `drive:local/portion/of/it.txt`
       * get the name of the drive. If the path is missing
       * a drive portion, returns an empty string.
       *
       * @param path the path.
       *
       * @returns The drive name for the path, or the empty string.
       */
      driveName(path2) {
        const parts = path2.split("/");
        const firstParts = parts[0].split(":");
        if (firstParts.length === 1) {
          return "";
        }
        if (this._additionalDrives.has(firstParts[0])) {
          return firstParts[0];
        }
        return "";
      }
      /**
       * Get a file or directory.
       *
       * @param path The path to the file.
       *
       * @param options The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       */
      get(path2, options) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.get(localPath, options).then((contentsModel) => {
          const listing = [];
          if (contentsModel.type === "directory" && contentsModel.content) {
            for (const item of contentsModel.content) {
              listing.push({ ...item, path: this._toGlobalPath(drive, item.path) });
            }
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              content: listing,
              serverPath: contentsModel.path
            };
          } else {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive, localPath),
              serverPath: contentsModel.path
            };
          }
        });
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param path - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.getDownloadUrl(localPath);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       */
      newUntitled(options = {}) {
        if (options.path) {
          const globalPath = this.normalize(options.path);
          const [drive, localPath] = this._driveForPath(globalPath);
          return drive.newUntitled({ ...options, path: localPath }).then((contentsModel) => {
            return {
              ...contentsModel,
              path: coreutils_12.PathExt.join(globalPath, contentsModel.name),
              serverPath: contentsModel.path
            };
          });
        } else {
          return this._defaultDrive.newUntitled(options);
        }
      }
      /**
       * Delete a file.
       *
       * @param path - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       */
      delete(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.delete(localPath);
      }
      /**
       * Rename a file or directory.
       *
       * @param path - The original file path.
       *
       * @param newPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       */
      rename(path2, newPath) {
        const [drive1, path1] = this._driveForPath(path2);
        const [drive2, path22] = this._driveForPath(newPath);
        if (drive1 !== drive2) {
          throw Error("ContentsManager: renaming files must occur within a Drive");
        }
        return drive1.rename(path1, path22).then((contentsModel) => {
          return {
            ...contentsModel,
            path: this._toGlobalPath(drive1, path22),
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Save a file.
       *
       * @param path - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       */
      save(path2, options = {}) {
        const globalPath = this.normalize(path2);
        const [drive, localPath] = this._driveForPath(path2);
        return drive.save(localPath, { ...options, path: localPath }).then((contentsModel) => {
          return {
            ...contentsModel,
            path: globalPath,
            serverPath: contentsModel.path
          };
        });
      }
      /**
       * Copy a file into a given directory.
       *
       * @param path - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       */
      copy(fromFile, toDir) {
        const [drive1, path1] = this._driveForPath(fromFile);
        const [drive2, path2] = this._driveForPath(toDir);
        if (drive1 === drive2) {
          return drive1.copy(path1, path2).then((contentsModel) => {
            return {
              ...contentsModel,
              path: this._toGlobalPath(drive1, contentsModel.path),
              serverPath: contentsModel.path
            };
          });
        } else {
          throw Error("Copying files between drives is not currently implemented");
        }
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       */
      createCheckpoint(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.createCheckpoint(localPath);
      }
      /**
       * List available checkpoints for a file.
       *
       * @param path - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       */
      listCheckpoints(path2) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.listCheckpoints(localPath);
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       */
      restoreCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.restoreCheckpoint(localPath, checkpointID);
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param path - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       */
      deleteCheckpoint(path2, checkpointID) {
        const [drive, localPath] = this._driveForPath(path2);
        return drive.deleteCheckpoint(localPath, checkpointID);
      }
      /**
       * Given a drive and a local path, construct a fully qualified
       * path. The inverse of `_driveForPath`.
       *
       * @param drive an `IDrive`.
       *
       * @param localPath the local path on the drive.
       *
       * @returns the fully qualified path.
       */
      _toGlobalPath(drive, localPath) {
        if (drive === this._defaultDrive) {
          return coreutils_12.PathExt.removeSlash(localPath);
        } else {
          return `${drive.name}:${coreutils_12.PathExt.removeSlash(localPath)}`;
        }
      }
      /**
       * Given a path, get the `IDrive to which it refers,
       * where the path satisfies the pattern
       * `'driveName:path/to/file'`. If there is no `driveName`
       * prepended to the path, it returns the default drive.
       *
       * @param path a path to a file.
       *
       * @returns A tuple containing an `IDrive` object for the path,
       * and a local path for that drive.
       */
      _driveForPath(path2) {
        const driveName = this.driveName(path2);
        const localPath = this.localPath(path2);
        if (driveName) {
          return [this._additionalDrives.get(driveName), localPath];
        } else {
          return [this._defaultDrive, localPath];
        }
      }
      /**
       * Respond to fileChanged signals from the drives attached to
       * the manager. This prepends the drive name to the path if necessary,
       * and then forwards the signal.
       */
      _onFileChanged(sender, args) {
        var _a, _b;
        if (sender === this._defaultDrive) {
          this._fileChanged.emit(args);
        } else {
          let newValue = null;
          let oldValue = null;
          if ((_a = args.newValue) === null || _a === void 0 ? void 0 : _a.path) {
            newValue = {
              ...args.newValue,
              path: this._toGlobalPath(sender, args.newValue.path)
            };
          }
          if ((_b = args.oldValue) === null || _b === void 0 ? void 0 : _b.path) {
            oldValue = {
              ...args.oldValue,
              path: this._toGlobalPath(sender, args.oldValue.path)
            };
          }
          this._fileChanged.emit({
            type: args.type,
            newValue,
            oldValue
          });
        }
      }
    };
    exports2.ContentsManager = ContentsManager;
    var Drive = class {
      /**
       * Construct a new contents manager object.
       *
       * @param options - The options used to initialize the object.
       */
      constructor(options = {}) {
        var _a, _b, _c;
        this._isDisposed = false;
        this._fileChanged = new signaling_1.Signal(this);
        this.name = (_a = options.name) !== null && _a !== void 0 ? _a : "Default";
        this._apiEndpoint = (_b = options.apiEndpoint) !== null && _b !== void 0 ? _b : SERVICE_DRIVE_URL;
        this.serverSettings = (_c = options.serverSettings) !== null && _c !== void 0 ? _c : __1.ServerConnection.makeSettings();
      }
      /**
       * A signal emitted when a file operation takes place.
       */
      get fileChanged() {
        return this._fileChanged;
      }
      /**
       * Test whether the manager has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
      }
      /**
       * Get a file or directory.
       *
       * @param localPath The path to the file.
       *
       * @param options The options used to fetch the file.
       *
       * @returns A promise which resolves with the file content.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async get(localPath, options) {
        let url = this._getUrl(localPath);
        if (options) {
          if (options.type === "notebook") {
            delete options["format"];
          }
          const content = options.content ? "1" : "0";
          const hash = options.hash ? "1" : "0";
          const params = { ...options, content, hash };
          url += coreutils_12.URLExt.objectToQueryString(params);
        }
        const settings = this.serverSettings;
        const response = await __1.ServerConnection.makeRequest(url, {}, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        return data;
      }
      /**
       * Get an encoded download url given a file path.
       *
       * @param localPath - An absolute POSIX file path on the server.
       *
       * #### Notes
       * It is expected that the path contains no relative paths.
       *
       * The returned URL may include a query parameter.
       */
      getDownloadUrl(localPath) {
        const baseUrl = this.serverSettings.baseUrl;
        let url = coreutils_12.URLExt.join(baseUrl, FILES_URL, coreutils_12.URLExt.encodeParts(localPath));
        let cookie = "";
        try {
          cookie = document.cookie;
        } catch (e) {
        }
        const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
        if (xsrfTokenMatch) {
          const fullUrl = new URL(url);
          fullUrl.searchParams.append("_xsrf", xsrfTokenMatch[1]);
          url = fullUrl.toString();
        }
        return Promise.resolve(url);
      }
      /**
       * Create a new untitled file or directory in the specified directory path.
       *
       * @param options The options used to create the file.
       *
       * @returns A promise which resolves with the created file content when the
       *    file is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async newUntitled(options = {}) {
        var _a;
        let body = "{}";
        if (options) {
          if (options.ext) {
            options.ext = Private.normalizeExtension(options.ext);
          }
          body = JSON.stringify(options);
        }
        const settings = this.serverSettings;
        const url = this._getUrl((_a = options.path) !== null && _a !== void 0 ? _a : "");
        const init = {
          method: "POST",
          body
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Delete a file.
       *
       * @param localPath - The path to the file.
       *
       * @returns A promise which resolves when the file is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async delete(localPath) {
        const url = this._getUrl(localPath);
        const settings = this.serverSettings;
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        this._fileChanged.emit({
          type: "delete",
          oldValue: { path: localPath },
          newValue: null
        });
      }
      /**
       * Rename a file or directory.
       *
       * @param oldLocalPath - The original file path.
       *
       * @param newLocalPath - The new file path.
       *
       * @returns A promise which resolves with the new file contents model when
       *   the file is renamed.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async rename(oldLocalPath, newLocalPath) {
        const settings = this.serverSettings;
        const url = this._getUrl(oldLocalPath);
        const init = {
          method: "PATCH",
          body: JSON.stringify({ path: newLocalPath })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "rename",
          oldValue: { path: oldLocalPath },
          newValue: data
        });
        return data;
      }
      /**
       * Save a file.
       *
       * @param localPath - The desired file path.
       *
       * @param options - Optional overrides to the model.
       *
       * @returns A promise which resolves with the file content model when the
       *   file is saved.
       *
       * #### Notes
       * Ensure that `model.content` is populated for the file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async save(localPath, options = {}) {
        const settings = this.serverSettings;
        const url = this._getUrl(localPath);
        const init = {
          method: "PUT",
          body: JSON.stringify(options)
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 200 && response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "save",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Copy a file into a given directory.
       *
       * @param localPath - The original file path.
       *
       * @param toDir - The destination directory path.
       *
       * @returns A promise which resolves with the new contents model when the
       *  file is copied.
       *
       * #### Notes
       * The server will select the name of the copied file.
       *
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async copy(fromFile, toDir) {
        const settings = this.serverSettings;
        const url = this._getUrl(toDir);
        const init = {
          method: "POST",
          body: JSON.stringify({ copy_from: fromFile })
        };
        const response = await __1.ServerConnection.makeRequest(url, init, settings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateContentsModel(data);
        this._fileChanged.emit({
          type: "new",
          oldValue: null,
          newValue: data
        });
        return data;
      }
      /**
       * Create a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with the new checkpoint model when the
       *   checkpoint is created.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async createCheckpoint(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 201) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        validate.validateCheckpointModel(data);
        return data;
      }
      /**
       * List available checkpoints for a file.
       *
       * @param localPath - The path of the file.
       *
       * @returns A promise which resolves with a list of checkpoint models for
       *    the file.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents) and validates the response model.
       */
      async listCheckpoints(localPath) {
        const url = this._getUrl(localPath, "checkpoints");
        const response = await __1.ServerConnection.makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid Checkpoint list");
        }
        for (let i = 0; i < data.length; i++) {
          validate.validateCheckpointModel(data[i]);
        }
        return data;
      }
      /**
       * Restore a file to a known checkpoint state.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to restore.
       *
       * @returns A promise which resolves when the checkpoint is restored.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async restoreCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "POST" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Delete a checkpoint for a file.
       *
       * @param localPath - The path of the file.
       *
       * @param checkpointID - The id of the checkpoint to delete.
       *
       * @returns A promise which resolves when the checkpoint is deleted.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/contents).
       */
      async deleteCheckpoint(localPath, checkpointID) {
        const url = this._getUrl(localPath, "checkpoints", checkpointID);
        const init = { method: "DELETE" };
        const response = await __1.ServerConnection.makeRequest(url, init, this.serverSettings);
        if (response.status !== 204) {
          const err = await __1.ServerConnection.ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Get a REST url for a file given a path.
       */
      _getUrl(...args) {
        const parts = args.map((path2) => coreutils_12.URLExt.encodeParts(path2));
        const baseUrl = this.serverSettings.baseUrl;
        return coreutils_12.URLExt.join(baseUrl, this._apiEndpoint, ...parts);
      }
    };
    exports2.Drive = Drive;
    var Private;
    (function(Private2) {
      function normalizeExtension(extension) {
        if (extension.length > 0 && extension.indexOf(".") !== 0) {
          extension = `.${extension}`;
        }
        return extension;
      }
      Private2.normalizeExtension = normalizeExtension;
    })(Private || (Private = {}));
  }
});

// node_modules/@lumino/polling/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@lumino/polling/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_index_node(), require_dist2()) : typeof define === "function" && define.amd ? define(["exports", "@lumino/coreutils", "@lumino/signaling"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_polling = {}, global2.lumino_coreutils, global2.lumino_signaling));
    })(exports2, function(exports3, coreutils, signaling) {
      "use strict";
      class Poll {
        /**
         * Instantiate a new poll with exponential backoff in case of failure.
         *
         * @param options - The poll instantiation options.
         */
        constructor(options) {
          var _a;
          this._disposed = new signaling.Signal(this);
          this._lingered = 0;
          this._tick = new coreutils.PromiseDelegate();
          this._ticked = new signaling.Signal(this);
          this._factory = options.factory;
          this._linger = (_a = options.linger) !== null && _a !== void 0 ? _a : Private.DEFAULT_LINGER;
          this._standby = options.standby || Private.DEFAULT_STANDBY;
          this._state = { ...Private.DEFAULT_STATE, timestamp: (/* @__PURE__ */ new Date()).getTime() };
          const frequency = options.frequency || {};
          const max = Math.max(frequency.interval || 0, frequency.max || 0, Private.DEFAULT_FREQUENCY.max);
          this.frequency = { ...Private.DEFAULT_FREQUENCY, ...frequency, ...{ max } };
          this.name = options.name || Private.DEFAULT_NAME;
          if ("auto" in options ? options.auto : true) {
            setTimeout(() => this.start());
          }
        }
        /**
         * A signal emitted when the poll is disposed.
         */
        get disposed() {
          return this._disposed;
        }
        /**
         * The polling frequency parameters.
         */
        get frequency() {
          return this._frequency;
        }
        set frequency(frequency) {
          if (this.isDisposed || coreutils.JSONExt.deepEqual(frequency, this.frequency || {})) {
            return;
          }
          let { backoff, interval, max } = frequency;
          interval = Math.round(interval);
          max = Math.round(max);
          if (typeof backoff === "number" && backoff < 1) {
            throw new Error("Poll backoff growth factor must be at least 1");
          }
          if ((interval < 0 || interval > max) && interval !== Poll.NEVER) {
            throw new Error("Poll interval must be between 0 and max");
          }
          if (max > Poll.MAX_INTERVAL && max !== Poll.NEVER) {
            throw new Error(`Max interval must be less than ${Poll.MAX_INTERVAL}`);
          }
          this._frequency = { backoff, interval, max };
        }
        /**
         * Whether the poll is disposed.
         */
        get isDisposed() {
          return this.state.phase === "disposed";
        }
        /**
         * Indicates when the poll switches to standby.
         */
        get standby() {
          return this._standby;
        }
        set standby(standby) {
          if (this.isDisposed || this.standby === standby) {
            return;
          }
          this._standby = standby;
        }
        /**
         * The poll state, which is the content of the current poll tick.
         */
        get state() {
          return this._state;
        }
        /**
         * A promise that resolves when the poll next ticks.
         */
        get tick() {
          return this._tick.promise;
        }
        /**
         * A signal emitted when the poll ticks and fires off a new request.
         */
        get ticked() {
          return this._ticked;
        }
        /**
         * Return an async iterator that yields every tick.
         */
        async *[Symbol.asyncIterator]() {
          while (!this.isDisposed) {
            yield this.state;
            await this.tick.catch(() => void 0);
          }
        }
        /**
         * Dispose the poll.
         */
        dispose() {
          if (this.isDisposed) {
            return;
          }
          this._state = {
            ...Private.DISPOSED_STATE,
            timestamp: (/* @__PURE__ */ new Date()).getTime()
          };
          this._tick.promise.catch((_) => void 0);
          this._tick.reject(new Error(`Poll (${this.name}) is disposed.`));
          this._disposed.emit(void 0);
          signaling.Signal.clearData(this);
        }
        /**
         * Refreshes the poll. Schedules `refreshed` tick if necessary.
         *
         * @returns A promise that resolves after tick is scheduled and never rejects.
         *
         * #### Notes
         * The returned promise resolves after the tick is scheduled, but before
         * the polling action is run. To wait until after the poll action executes,
         * await the `poll.tick` promise: `await poll.refresh(); await poll.tick;`
         */
        refresh() {
          return this.schedule({
            cancel: ({ phase }) => phase === "refreshed",
            interval: Poll.IMMEDIATE,
            phase: "refreshed"
          });
        }
        /**
         * Schedule the next poll tick.
         *
         * @param next - The next poll state data to schedule. Defaults to standby.
         *
         * @param next.cancel - Cancels state transition if function returns `true`.
         *
         * @returns A promise that resolves when the next poll state is active.
         *
         * #### Notes
         * This method is not meant to be invoked by user code typically. It is public
         * to allow poll instances to be composed into classes that schedule ticks.
         */
        async schedule(next = {}) {
          if (this.isDisposed) {
            return;
          }
          if (next.cancel && next.cancel(this.state)) {
            return;
          }
          const pending = this._tick;
          const scheduled = new coreutils.PromiseDelegate();
          const state = {
            interval: this.frequency.interval,
            payload: null,
            phase: "standby",
            timestamp: (/* @__PURE__ */ new Date()).getTime(),
            ...next
          };
          this._state = state;
          this._tick = scheduled;
          clearTimeout(this._timeout);
          this._ticked.emit(this.state);
          pending.resolve(this);
          await pending.promise;
          if (state.interval === Poll.NEVER) {
            this._timeout = void 0;
            return;
          }
          const execute = () => {
            if (this.isDisposed || this.tick !== scheduled.promise) {
              return;
            }
            this._execute();
          };
          this._timeout = setTimeout(execute, state.interval);
        }
        /**
         * Starts the poll. Schedules `started` tick if necessary.
         *
         * @returns A promise that resolves after tick is scheduled and never rejects.
         */
        start() {
          return this.schedule({
            cancel: ({ phase }) => phase !== "constructed" && phase !== "standby" && phase !== "stopped",
            interval: Poll.IMMEDIATE,
            phase: "started"
          });
        }
        /**
         * Stops the poll. Schedules `stopped` tick if necessary.
         *
         * @returns A promise that resolves after tick is scheduled and never rejects.
         */
        stop() {
          return this.schedule({
            cancel: ({ phase }) => phase === "stopped",
            interval: Poll.NEVER,
            phase: "stopped"
          });
        }
        /**
         * Whether the poll is hidden.
         *
         * #### Notes
         * This property is only relevant in a browser context.
         */
        get hidden() {
          return Private.hidden;
        }
        /**
         * Execute a new poll factory promise or stand by if necessary.
         */
        _execute() {
          let standby = typeof this.standby === "function" ? this.standby() : this.standby;
          if (standby === "never") {
            standby = false;
          } else if (standby === "when-hidden") {
            if (this.hidden) {
              standby = ++this._lingered > this._linger;
            } else {
              this._lingered = 0;
              standby = false;
            }
          }
          if (standby) {
            void this.schedule();
            return;
          }
          const pending = this.tick;
          this._factory(this.state).then((resolved) => {
            if (this.isDisposed || this.tick !== pending) {
              return;
            }
            void this.schedule({
              payload: resolved,
              phase: this.state.phase === "rejected" ? "reconnected" : "resolved"
            });
          }).catch((rejected) => {
            if (this.isDisposed || this.tick !== pending) {
              return;
            }
            void this.schedule({
              interval: Private.sleep(this.frequency, this.state),
              payload: rejected,
              phase: "rejected"
            });
          });
        }
      }
      (function(Poll2) {
        Poll2.IMMEDIATE = 0;
        Poll2.MAX_INTERVAL = 2147483647;
        Poll2.NEVER = Infinity;
      })(Poll || (Poll = {}));
      var Private;
      (function(Private2) {
        Private2.DEFAULT_BACKOFF = 3;
        Private2.DEFAULT_FREQUENCY = {
          backoff: true,
          interval: 1e3,
          max: 30 * 1e3
        };
        Private2.DEFAULT_LINGER = 1;
        Private2.DEFAULT_NAME = "unknown";
        Private2.DEFAULT_STANDBY = "when-hidden";
        Private2.DEFAULT_STATE = {
          interval: Poll.NEVER,
          payload: null,
          phase: "constructed",
          timestamp: (/* @__PURE__ */ new Date(0)).getTime()
        };
        Private2.DISPOSED_STATE = {
          interval: Poll.NEVER,
          payload: null,
          phase: "disposed",
          timestamp: (/* @__PURE__ */ new Date(0)).getTime()
        };
        function sleep2(frequency, last) {
          const { backoff, interval, max } = frequency;
          if (interval === Poll.NEVER) {
            return interval;
          }
          const growth = backoff === true ? Private2.DEFAULT_BACKOFF : backoff === false ? 1 : backoff;
          const random = getRandomIntInclusive(interval, last.interval * growth);
          return Math.min(max, random);
        }
        Private2.sleep = sleep2;
        Private2.hidden = (() => {
          if (typeof document === "undefined") {
            return false;
          }
          document.addEventListener("visibilitychange", () => {
            Private2.hidden = document.visibilityState === "hidden";
          });
          document.addEventListener("pagehide", () => {
            Private2.hidden = document.visibilityState === "hidden";
          });
          return document.visibilityState === "hidden";
        })();
        function getRandomIntInclusive(min, max) {
          min = Math.ceil(min);
          max = Math.floor(max);
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }
      })(Private || (Private = {}));
      class RateLimiter {
        /**
         * Instantiate a rate limiter.
         *
         * @param fn - The function to rate limit.
         *
         * @param limit - The rate limit; defaults to 500ms.
         */
        constructor(fn, limit = 500) {
          this.args = void 0;
          this.payload = null;
          this.limit = limit;
          this.poll = new Poll({
            auto: false,
            factory: async () => {
              const { args } = this;
              this.args = void 0;
              return fn(...args);
            },
            frequency: { backoff: false, interval: Poll.NEVER, max: Poll.NEVER },
            standby: "never"
          });
          this.payload = new coreutils.PromiseDelegate();
          this.poll.ticked.connect((_, state) => {
            const { payload } = this;
            if (state.phase === "resolved") {
              this.payload = new coreutils.PromiseDelegate();
              payload.resolve(state.payload);
              return;
            }
            if (state.phase === "rejected" || state.phase === "stopped") {
              this.payload = new coreutils.PromiseDelegate();
              payload.promise.catch((_2) => void 0);
              payload.reject(state.payload);
              return;
            }
          }, this);
        }
        /**
         * Whether the rate limiter is disposed.
         */
        get isDisposed() {
          return this.payload === null;
        }
        /**
         * Disposes the rate limiter.
         */
        dispose() {
          if (this.isDisposed) {
            return;
          }
          this.args = void 0;
          this.payload = null;
          this.poll.dispose();
        }
        /**
         * Stop the function if it is mid-flight.
         */
        async stop() {
          return this.poll.stop();
        }
      }
      class Debouncer extends RateLimiter {
        /**
         * Invokes the function and only executes after rate limit has elapsed.
         * Each invocation resets the timer.
         */
        invoke(...args) {
          this.args = args;
          void this.poll.schedule({ interval: this.limit, phase: "invoked" });
          return this.payload.promise;
        }
      }
      class Throttler extends RateLimiter {
        /**
         * Instantiate a throttler.
         *
         * @param fn - The function being throttled.
         *
         * @param options - Throttling configuration or throttling limit in ms.
         *
         * #### Notes
         * The `edge` defaults to `leading`; the `limit` defaults to `500`.
         */
        constructor(fn, options) {
          super(fn, typeof options === "number" ? options : options && options.limit);
          this._trailing = false;
          if (typeof options !== "number" && options && options.edge === "trailing") {
            this._trailing = true;
          }
          this._interval = this._trailing ? this.limit : Poll.IMMEDIATE;
        }
        /**
         * Throttles function invocations if one is currently in flight.
         */
        invoke(...args) {
          const idle = this.poll.state.phase !== "invoked";
          if (idle || this._trailing) {
            this.args = args;
          }
          if (idle) {
            void this.poll.schedule({ interval: this._interval, phase: "invoked" });
          }
          return this.payload.promise;
        }
      }
      exports3.Debouncer = Debouncer;
      exports3.Poll = Poll;
      exports3.RateLimiter = RateLimiter;
      exports3.Throttler = Throttler;
    });
  }
});

// node_modules/@jupyterlab/services/lib/event/index.js
var require_event = __commonJS({
  "node_modules/@jupyterlab/services/lib/event/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EventManager = void 0;
    var coreutils_12 = require_lib();
    var polling_1 = require_dist3();
    var signaling_1 = require_dist2();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_EVENTS_URL = "api/events";
    var EventManager = class {
      /**
       * Create a new event manager.
       */
      constructor(options = {}) {
        var _a;
        this._socket = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        this._poll = new polling_1.Poll({ factory: () => this._subscribe() });
        this._stream = new signaling_1.Stream(this);
        void this._poll.start();
      }
      /**
       * Whether the event manager is disposed.
       */
      get isDisposed() {
        return this._poll.isDisposed;
      }
      /**
       * An event stream that emits and yields each new event.
       */
      get stream() {
        return this._stream;
      }
      /**
       * Dispose the event manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._poll.dispose();
        const socket = this._socket;
        if (socket) {
          this._socket = null;
          socket.onopen = () => void 0;
          socket.onerror = () => void 0;
          socket.onmessage = () => void 0;
          socket.onclose = () => void 0;
          socket.close();
        }
        signaling_1.Signal.clearData(this);
        this._stream.stop();
      }
      /**
       * Post an event request to be emitted by the event bus.
       */
      async emit(event) {
        const { serverSettings } = this;
        const { baseUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_EVENTS_URL);
        const init = { body: JSON.stringify(event), method: "POST" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
      /**
       * Subscribe to event bus emissions.
       */
      _subscribe() {
        return new Promise((_, reject) => {
          if (this.isDisposed) {
            return;
          }
          const { appendToken, token, WebSocket: WebSocket2, wsUrl } = this.serverSettings;
          let url = coreutils_12.URLExt.join(wsUrl, SERVICE_EVENTS_URL, "subscribe");
          if (appendToken && token !== "") {
            url += `?token=${encodeURIComponent(token)}`;
          }
          const socket = this._socket = new WebSocket2(url);
          const stream = this._stream;
          socket.onclose = () => reject(new Error("EventManager socket closed"));
          socket.onmessage = (msg) => msg.data && stream.emit(JSON.parse(msg.data));
        });
      }
    };
    exports2.EventManager = EventManager;
  }
});

// node_modules/@jupyterlab/services/lib/kernel/kernel.js
var require_kernel = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/kernel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@jupyterlab/services/lib/kernel/validate.js
var require_validate3 = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.validateModel = exports2.validateMessage = void 0;
    var validate_1 = require_validate();
    var HEADER_FIELDS = ["username", "version", "session", "msg_id", "msg_type"];
    var IOPUB_CONTENT_FIELDS = {
      stream: { name: "string", text: "string" },
      display_data: { data: "object", metadata: "object" },
      execute_input: { code: "string", execution_count: "number" },
      execute_result: {
        execution_count: "number",
        data: "object",
        metadata: "object"
      },
      error: { ename: "string", evalue: "string", traceback: "object" },
      status: {
        execution_state: [
          "string",
          ["starting", "idle", "busy", "restarting", "dead"]
        ]
      },
      clear_output: { wait: "boolean" },
      comm_open: { comm_id: "string", target_name: "string", data: "object" },
      comm_msg: { comm_id: "string", data: "object" },
      comm_close: { comm_id: "string" },
      shutdown_reply: { restart: "boolean" }
      // Emitted by the IPython kernel.
    };
    function validateHeader(header) {
      for (let i = 0; i < HEADER_FIELDS.length; i++) {
        (0, validate_1.validateProperty)(header, HEADER_FIELDS[i], "string");
      }
    }
    function validateMessage(msg) {
      (0, validate_1.validateProperty)(msg, "metadata", "object");
      (0, validate_1.validateProperty)(msg, "content", "object");
      (0, validate_1.validateProperty)(msg, "channel", "string");
      validateHeader(msg.header);
      if (msg.channel === "iopub") {
        validateIOPubContent(msg);
      }
    }
    exports2.validateMessage = validateMessage;
    function validateIOPubContent(msg) {
      if (msg.channel === "iopub") {
        const fields = IOPUB_CONTENT_FIELDS[msg.header.msg_type];
        if (fields === void 0) {
          return;
        }
        const names = Object.keys(fields);
        const content = msg.content;
        for (let i = 0; i < names.length; i++) {
          let args = fields[names[i]];
          if (!Array.isArray(args)) {
            args = [args];
          }
          (0, validate_1.validateProperty)(content, names[i], ...args);
        }
      }
    }
    function validateModel(model) {
      (0, validate_1.validateProperty)(model, "name", "string");
      (0, validate_1.validateProperty)(model, "id", "string");
    }
    exports2.validateModel = validateModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid kernel list");
      }
      models.forEach((d) => validateModel(d));
    }
    exports2.validateModels = validateModels;
  }
});

// node_modules/@jupyterlab/services/lib/kernel/restapi.js
var require_restapi = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getKernelModel = exports2.shutdownKernel = exports2.interruptKernel = exports2.restartKernel = exports2.startNew = exports2.listRunning = exports2.KERNEL_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib();
    var validate_1 = require_validate3();
    exports2.KERNEL_SERVICE_URL = "api/kernels";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModels)(data);
      return data;
    }
    exports2.listRunning = listRunning;
    async function startNew(options = {}, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startNew = startNew;
    async function restartKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "restart");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
    }
    exports2.restartKernel = restartKernel;
    async function interruptKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id), "interrupt");
      const init = { method: "POST" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.interruptKernel = interruptKernel;
    async function shutdownKernel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const msg = `The kernel "${id}" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownKernel = shutdownKernel;
    async function getKernelModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.KERNEL_SERVICE_URL, encodeURIComponent(id));
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status === 404) {
        return void 0;
      } else if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getKernelModel = getKernelModel;
  }
});

// node_modules/@lumino/disposable/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@lumino/disposable/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_dist2()) : typeof define === "function" && define.amd ? define(["exports", "@lumino/signaling"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_disposable = {}, global2.lumino_signaling));
    })(exports2, function(exports3, signaling) {
      "use strict";
      class DisposableDelegate {
        /**
         * Construct a new disposable delegate.
         *
         * @param fn - The callback function to invoke on dispose.
         */
        constructor(fn) {
          this._fn = fn;
        }
        /**
         * Test whether the delegate has been disposed.
         */
        get isDisposed() {
          return !this._fn;
        }
        /**
         * Dispose of the delegate and invoke the callback function.
         */
        dispose() {
          if (!this._fn) {
            return;
          }
          let fn = this._fn;
          this._fn = null;
          fn();
        }
      }
      class ObservableDisposableDelegate extends DisposableDelegate {
        constructor() {
          super(...arguments);
          this._disposed = new signaling.Signal(this);
        }
        /**
         * A signal emitted when the delegate is disposed.
         */
        get disposed() {
          return this._disposed;
        }
        /**
         * Dispose of the delegate and invoke the callback function.
         */
        dispose() {
          if (this.isDisposed) {
            return;
          }
          super.dispose();
          this._disposed.emit(void 0);
          signaling.Signal.clearData(this);
        }
      }
      class DisposableSet {
        constructor() {
          this._isDisposed = false;
          this._items = /* @__PURE__ */ new Set();
        }
        /**
         * Test whether the set has been disposed.
         */
        get isDisposed() {
          return this._isDisposed;
        }
        /**
         * Dispose of the set and the items it contains.
         *
         * #### Notes
         * Items are disposed in the order they are added to the set.
         */
        dispose() {
          if (this._isDisposed) {
            return;
          }
          this._isDisposed = true;
          this._items.forEach((item) => {
            item.dispose();
          });
          this._items.clear();
        }
        /**
         * Test whether the set contains a specific item.
         *
         * @param item - The item of interest.
         *
         * @returns `true` if the set contains the item, `false` otherwise.
         */
        contains(item) {
          return this._items.has(item);
        }
        /**
         * Add a disposable item to the set.
         *
         * @param item - The item to add to the set.
         *
         * #### Notes
         * If the item is already contained in the set, this is a no-op.
         */
        add(item) {
          this._items.add(item);
        }
        /**
         * Remove a disposable item from the set.
         *
         * @param item - The item to remove from the set.
         *
         * #### Notes
         * If the item is not contained in the set, this is a no-op.
         */
        remove(item) {
          this._items.delete(item);
        }
        /**
         * Remove all items from the set.
         */
        clear() {
          this._items.clear();
        }
      }
      (function(DisposableSet2) {
        function from(items) {
          let set = new DisposableSet2();
          for (const item of items) {
            set.add(item);
          }
          return set;
        }
        DisposableSet2.from = from;
      })(DisposableSet || (DisposableSet = {}));
      class ObservableDisposableSet extends DisposableSet {
        constructor() {
          super(...arguments);
          this._disposed = new signaling.Signal(this);
        }
        /**
         * A signal emitted when the set is disposed.
         */
        get disposed() {
          return this._disposed;
        }
        /**
         * Dispose of the set and the items it contains.
         *
         * #### Notes
         * Items are disposed in the order they are added to the set.
         */
        dispose() {
          if (this.isDisposed) {
            return;
          }
          super.dispose();
          this._disposed.emit(void 0);
          signaling.Signal.clearData(this);
        }
      }
      (function(ObservableDisposableSet2) {
        function from(items) {
          let set = new ObservableDisposableSet2();
          for (const item of items) {
            set.add(item);
          }
          return set;
        }
        ObservableDisposableSet2.from = from;
      })(ObservableDisposableSet || (ObservableDisposableSet = {}));
      exports3.DisposableDelegate = DisposableDelegate;
      exports3.DisposableSet = DisposableSet;
      exports3.ObservableDisposableDelegate = ObservableDisposableDelegate;
      exports3.ObservableDisposableSet = ObservableDisposableSet;
    });
  }
});

// node_modules/@jupyterlab/services/lib/kernel/comm.js
var require_comm = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/comm.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CommHandler = void 0;
    var disposable_1 = require_dist4();
    var KernelMessage = __importStar(require_messages());
    var CommHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new comm channel.
       */
      constructor(target, id, kernel, disposeCb) {
        super(disposeCb);
        this._target = "";
        this._id = "";
        this._id = id;
        this._target = target;
        this._kernel = kernel;
      }
      /**
       * The unique id for the comm channel.
       */
      get commId() {
        return this._id;
      }
      /**
       * The target name for the comm channel.
       */
      get targetName() {
        return this._target;
      }
      /**
       * Get the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client.
       *
       * **See also:** [[ICommClose]], [[close]]
       */
      get onClose() {
        return this._onClose;
      }
      /**
       * Set the callback for a comm close event.
       *
       * #### Notes
       * This is called when the comm is closed from either the server or client. If
       * the function returns a promise, and the kernel was closed from the server,
       * kernel message processing will pause until the returned promise is
       * fulfilled.
       *
       * **See also:** [[close]]
       */
      set onClose(cb) {
        this._onClose = cb;
      }
      /**
       * Get the callback for a comm message received event.
       */
      get onMsg() {
        return this._onMsg;
      }
      /**
       * Set the callback for a comm message received event.
       *
       * #### Notes
       * This is called when a comm message is received. If the function returns a
       * promise, kernel message processing will pause until it is fulfilled.
       */
      set onMsg(cb) {
        this._onMsg = cb;
      }
      /**
       * Open a comm with optional data and metadata.
       *
       * #### Notes
       * This sends a `comm_open` message to the server.
       *
       * **See also:** [[ICommOpen]]
       */
      open(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot open");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_open",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            target_name: this._target,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, true);
      }
      /**
       * Send a `comm_msg` message to the kernel.
       *
       * #### Notes
       * This is a no-op if the comm has been closed.
       *
       * **See also:** [[ICommMsg]]
       */
      send(data, metadata, buffers = [], disposeOnDone = true) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot send");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_msg",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data
          },
          metadata,
          buffers
        });
        return this._kernel.sendShellMessage(msg, false, disposeOnDone);
      }
      /**
       * Close the comm.
       *
       * #### Notes
       * This will send a `comm_close` message to the kernel, and call the
       * `onClose` callback if set.
       *
       * This is a no-op if the comm is already closed.
       *
       * **See also:** [[ICommClose]], [[onClose]]
       */
      close(data, metadata, buffers = []) {
        if (this.isDisposed || this._kernel.isDisposed) {
          throw new Error("Cannot close");
        }
        const msg = KernelMessage.createMessage({
          msgType: "comm_close",
          channel: "shell",
          username: this._kernel.username,
          session: this._kernel.clientId,
          content: {
            comm_id: this._id,
            data: data !== null && data !== void 0 ? data : {}
          },
          metadata,
          buffers
        });
        const future = this._kernel.sendShellMessage(msg, false, true);
        const onClose = this._onClose;
        if (onClose) {
          const ioMsg = KernelMessage.createMessage({
            msgType: "comm_close",
            channel: "iopub",
            username: this._kernel.username,
            session: this._kernel.clientId,
            content: {
              comm_id: this._id,
              data: data !== null && data !== void 0 ? data : {}
            },
            metadata,
            buffers
          });
          void onClose(ioMsg);
        }
        this.dispose();
        return future;
      }
    };
    exports2.CommHandler = CommHandler;
  }
});

// node_modules/@jupyterlab/services/lib/kernel/future.js
var require_future = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/future.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelShellFutureHandler = exports2.KernelControlFutureHandler = exports2.KernelFutureHandler = void 0;
    var coreutils_12 = require_index_node();
    var disposable_1 = require_dist4();
    var KernelMessage = __importStar(require_messages());
    var KernelFutureHandler = class extends disposable_1.DisposableDelegate {
      /**
       * Construct a new KernelFutureHandler.
       */
      constructor(cb, msg, expectReply, disposeOnDone, kernel) {
        super(cb);
        this._status = 0;
        this._stdin = Private.noOp;
        this._iopub = Private.noOp;
        this._reply = Private.noOp;
        this._done = new coreutils_12.PromiseDelegate();
        this._hooks = new Private.HookList();
        this._disposeOnDone = true;
        this._msg = msg;
        if (!expectReply) {
          this._setFlag(Private.KernelFutureFlag.GotReply);
        }
        this._disposeOnDone = disposeOnDone;
        this._kernel = kernel;
      }
      /**
       * Get the original outgoing message.
       */
      get msg() {
        return this._msg;
      }
      /**
       * A promise that resolves when the future is done.
       */
      get done() {
        return this._done.promise;
      }
      /**
       * Get the reply handler.
       */
      get onReply() {
        return this._reply;
      }
      /**
       * Set the reply handler.
       */
      set onReply(cb) {
        this._reply = cb;
      }
      /**
       * Get the iopub handler.
       */
      get onIOPub() {
        return this._iopub;
      }
      /**
       * Set the iopub handler.
       */
      set onIOPub(cb) {
        this._iopub = cb;
      }
      /**
       * Get the stdin handler.
       */
      get onStdin() {
        return this._stdin;
      }
      /**
       * Set the stdin handler.
       */
      set onStdin(cb) {
        this._stdin = cb;
      }
      /**
       * Register hook for IOPub messages.
       *
       * @param hook - The callback invoked for an IOPub message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages handled by the future.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       */
      registerMessageHook(hook) {
        if (this.isDisposed) {
          throw new Error("Kernel future is disposed");
        }
        this._hooks.add(hook);
      }
      /**
       * Remove a hook for IOPub messages.
       *
       * @param hook - The hook to remove.
       *
       * #### Notes
       * If a hook is removed during the hook processing, it will be deactivated immediately.
       */
      removeMessageHook(hook) {
        if (this.isDisposed) {
          return;
        }
        this._hooks.remove(hook);
      }
      /**
       * Send an `input_reply` message.
       */
      sendInputReply(content, parent_header) {
        this._kernel.sendInputReply(content, parent_header);
      }
      /**
       * Dispose and unregister the future.
       */
      dispose() {
        this._stdin = Private.noOp;
        this._iopub = Private.noOp;
        this._reply = Private.noOp;
        this._hooks = null;
        if (!this._testFlag(Private.KernelFutureFlag.IsDone)) {
          this._done.promise.catch(() => {
          });
          this._done.reject(new Error(`Canceled future for ${this.msg.header.msg_type} message before replies were done`));
        }
        super.dispose();
      }
      /**
       * Handle an incoming kernel message.
       */
      async handleMsg(msg) {
        switch (msg.channel) {
          case "control":
          case "shell":
            if (msg.channel === this.msg.channel && msg.parent_header.msg_id === this.msg.header.msg_id) {
              await this._handleReply(msg);
            }
            break;
          case "stdin":
            await this._handleStdin(msg);
            break;
          case "iopub":
            await this._handleIOPub(msg);
            break;
          default:
            break;
        }
      }
      async _handleReply(msg) {
        const reply = this._reply;
        if (reply) {
          await reply(msg);
        }
        this._replyMsg = msg;
        this._setFlag(Private.KernelFutureFlag.GotReply);
        if (this._testFlag(Private.KernelFutureFlag.GotIdle)) {
          this._handleDone();
        }
      }
      async _handleStdin(msg) {
        this._kernel.hasPendingInput = true;
        const stdin = this._stdin;
        if (stdin) {
          await stdin(msg);
        }
      }
      async _handleIOPub(msg) {
        const process2 = await this._hooks.process(msg);
        const iopub = this._iopub;
        if (process2 && iopub) {
          await iopub(msg);
        }
        if (KernelMessage.isStatusMsg(msg) && msg.content.execution_state === "idle") {
          this._setFlag(Private.KernelFutureFlag.GotIdle);
          if (this._testFlag(Private.KernelFutureFlag.GotReply)) {
            this._handleDone();
          }
        }
      }
      _handleDone() {
        if (this._testFlag(Private.KernelFutureFlag.IsDone)) {
          return;
        }
        this._setFlag(Private.KernelFutureFlag.IsDone);
        this._done.resolve(this._replyMsg);
        if (this._disposeOnDone) {
          this.dispose();
        }
      }
      /**
       * Test whether the given future flag is set.
       */
      _testFlag(flag) {
        return (this._status & flag) !== 0;
      }
      /**
       * Set the given future flag.
       */
      _setFlag(flag) {
        this._status |= flag;
      }
    };
    exports2.KernelFutureHandler = KernelFutureHandler;
    var KernelControlFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelControlFutureHandler = KernelControlFutureHandler;
    var KernelShellFutureHandler = class extends KernelFutureHandler {
    };
    exports2.KernelShellFutureHandler = KernelShellFutureHandler;
    var Private;
    (function(Private2) {
      Private2.noOp = () => {
      };
      const defer = (() => {
        const ok = typeof requestAnimationFrame === "function";
        return ok ? requestAnimationFrame : setImmediate;
      })();
      class HookList {
        constructor() {
          this._hooks = [];
        }
        /**
         * Register a hook.
         *
         * @param hook - The callback to register.
         */
        add(hook) {
          this.remove(hook);
          this._hooks.push(hook);
        }
        /**
         * Remove a hook, if it exists in the hook list.
         *
         * @param hook - The callback to remove.
         */
        remove(hook) {
          const index = this._hooks.indexOf(hook);
          if (index >= 0) {
            this._hooks[index] = null;
            this._scheduleCompact();
          }
        }
        /**
         * Process a message through the hooks.
         *
         * @returns a promise resolving to false if any hook resolved as false,
         * otherwise true
         *
         * #### Notes
         * The most recently registered hook is run first. A hook can return a
         * boolean or a promise to a boolean, in which case processing pauses until
         * the promise is fulfilled. If a hook return value resolves to false, any
         * later hooks will not run and the function will return a promise resolving
         * to false. If a hook throws an error, the error is logged to the console
         * and the next hook is run. If a hook is registered during the hook
         * processing, it will not run until the next message. If a hook is removed
         * during the hook processing, it will be deactivated immediately.
         */
        async process(msg) {
          await this._processing;
          const processing = new coreutils_12.PromiseDelegate();
          this._processing = processing.promise;
          let continueHandling;
          for (let i = this._hooks.length - 1; i >= 0; i--) {
            const hook = this._hooks[i];
            if (hook === null) {
              continue;
            }
            try {
              continueHandling = await hook(msg);
            } catch (err) {
              continueHandling = true;
              console.error(err);
            }
            if (continueHandling === false) {
              processing.resolve(void 0);
              return false;
            }
          }
          processing.resolve(void 0);
          return true;
        }
        /**
         * Schedule a cleanup of the list, removing any hooks that have been nulled out.
         */
        _scheduleCompact() {
          if (!this._compactScheduled) {
            this._compactScheduled = true;
            defer(() => {
              this._processing = this._processing.then(() => {
                this._compactScheduled = false;
                this._compact();
              });
            });
          }
        }
        /**
         * Compact the list, removing any nulls.
         */
        _compact() {
          let numNulls = 0;
          for (let i = 0, len = this._hooks.length; i < len; i++) {
            const hook = this._hooks[i];
            if (this._hooks[i] === null) {
              numNulls++;
            } else {
              this._hooks[i - numNulls] = hook;
            }
          }
          this._hooks.length -= numNulls;
        }
      }
      Private2.HookList = HookList;
      let KernelFutureFlag;
      (function(KernelFutureFlag2) {
        KernelFutureFlag2[KernelFutureFlag2["GotReply"] = 1] = "GotReply";
        KernelFutureFlag2[KernelFutureFlag2["GotIdle"] = 2] = "GotIdle";
        KernelFutureFlag2[KernelFutureFlag2["IsDone"] = 4] = "IsDone";
        KernelFutureFlag2[KernelFutureFlag2["DisposeOnDone"] = 8] = "DisposeOnDone";
      })(KernelFutureFlag = Private2.KernelFutureFlag || (Private2.KernelFutureFlag = {}));
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js
var require_kernelspec = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernelspec/kernelspec.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@jupyterlab/services/lib/kernelspec/validate.js
var require_validate4 = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernelspec/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSpecModels = exports2.validateSpecModel = void 0;
    var validate_1 = require_validate();
    function validateSpecModel(data) {
      const spec = data.spec;
      if (!spec) {
        throw new Error("Invalid kernel spec");
      }
      (0, validate_1.validateProperty)(data, "name", "string");
      (0, validate_1.validateProperty)(data, "resources", "object");
      (0, validate_1.validateProperty)(spec, "language", "string");
      (0, validate_1.validateProperty)(spec, "display_name", "string");
      (0, validate_1.validateProperty)(spec, "argv", "array");
      let metadata = null;
      if (spec.hasOwnProperty("metadata")) {
        (0, validate_1.validateProperty)(spec, "metadata", "object");
        metadata = spec.metadata;
      }
      let env2 = null;
      if (spec.hasOwnProperty("env")) {
        (0, validate_1.validateProperty)(spec, "env", "object");
        env2 = spec.env;
      }
      return {
        name: data.name,
        resources: data.resources,
        language: spec.language,
        display_name: spec.display_name,
        argv: spec.argv,
        metadata,
        env: env2
      };
    }
    exports2.validateSpecModel = validateSpecModel;
    function validateSpecModels(data) {
      if (!data.hasOwnProperty("kernelspecs")) {
        throw new Error("No kernelspecs found");
      }
      let keys = Object.keys(data.kernelspecs);
      const kernelspecs = /* @__PURE__ */ Object.create(null);
      let defaultSpec = data.default;
      for (let i = 0; i < keys.length; i++) {
        const ks = data.kernelspecs[keys[i]];
        try {
          kernelspecs[keys[i]] = validateSpecModel(ks);
        } catch (err) {
          console.warn(`Removing errant kernel spec: ${keys[i]}`);
        }
      }
      keys = Object.keys(kernelspecs);
      if (!keys.length) {
        throw new Error("No valid kernelspecs found");
      }
      if (!defaultSpec || typeof defaultSpec !== "string" || !(defaultSpec in kernelspecs)) {
        defaultSpec = keys[0];
        console.warn(`Default kernel not found, using '${keys[0]}'`);
      }
      return {
        default: defaultSpec,
        kernelspecs
      };
    }
    exports2.validateSpecModels = validateSpecModels;
  }
});

// node_modules/@jupyterlab/services/lib/kernelspec/restapi.js
var require_restapi2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernelspec/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpecs = void 0;
    var serverconnection_1 = require_serverconnection();
    var validate_1 = require_validate4();
    var coreutils_12 = require_lib();
    var KERNELSPEC_SERVICE_URL = "api/kernelspecs";
    async function getSpecs(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, KERNELSPEC_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return (0, validate_1.validateSpecModels)(data);
    }
    exports2.getSpecs = getSpecs;
  }
});

// node_modules/@jupyterlab/services/lib/kernelspec/manager.js
var require_manager = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernelspec/manager.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecManager = void 0;
    var coreutils_12 = require_index_node();
    var polling_1 = require_dist3();
    var signaling_1 = require_dist2();
    var restapi = __importStar(require_restapi2());
    var basemanager_1 = require_basemanager();
    var KernelSpecManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel spec manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._specs = null;
        this._specsChanged = new signaling_1.Signal(this);
        this._ready = Promise.all([this.requestSpecs()]).then((_) => void 0).catch((_) => void 0).then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        });
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestSpecs(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelSpecManager#specs`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched kernel specs.
       */
      get specs() {
        return this._specs;
      }
      /**
       * A signal emitted when the specs change.
       */
      get specsChanged() {
        return this._specsChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshSpecs() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll specs and update state.
       */
      async requestSpecs() {
        const specs = await restapi.getSpecs(this.serverSettings);
        if (this.isDisposed) {
          return;
        }
        if (!coreutils_12.JSONExt.deepEqual(specs, this._specs)) {
          this._specs = specs;
          this._specsChanged.emit(specs);
        }
      }
    };
    exports2.KernelSpecManager = KernelSpecManager2;
  }
});

// node_modules/@jupyterlab/services/lib/kernelspec/index.js
var require_kernelspec2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernelspec/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelSpecAPI = exports2.KernelSpec = void 0;
    var KernelSpec = __importStar(require_kernelspec());
    exports2.KernelSpec = KernelSpec;
    var KernelSpecAPI = __importStar(require_restapi2());
    exports2.KernelSpecAPI = KernelSpecAPI;
    __exportStar(require_manager(), exports2);
  }
});

// node_modules/@jupyterlab/services/lib/kernel/default.js
var require_default = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/default.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = void 0;
    var coreutils_12 = require_lib();
    var coreutils_2 = require_index_node();
    var signaling_1 = require_dist2();
    var __1 = require_lib3();
    var comm_1 = require_comm();
    var KernelMessage = __importStar(require_messages());
    var future_1 = require_future();
    var validate = __importStar(require_validate3());
    var kernelspec_1 = require_kernelspec2();
    var restapi = __importStar(require_restapi());
    var KERNEL_INFO_TIMEOUT = 3e3;
    var RESTARTING_KERNEL_SESSION = "_RESTARTING_";
    var STARTING_KERNEL_SESSION = "";
    var KernelConnection = class _KernelConnection {
      /**
       * Construct a kernel object.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._createSocket = (useProtocols = true) => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const settings = this.serverSettings;
          const partialUrl = coreutils_12.URLExt.join(settings.wsUrl, restapi.KERNEL_SERVICE_URL, encodeURIComponent(this._id));
          const display = partialUrl.replace(/^((?:\w+:)?\/\/)(?:[^@\/]+@)/, "$1");
          console.debug(`Starting WebSocket: ${display}`);
          let url = coreutils_12.URLExt.join(partialUrl, "channels?session_id=" + encodeURIComponent(this._clientId));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `&token=${encodeURIComponent(token)}`;
          }
          const supportedProtocols = useProtocols ? this._supportedProtocols : [];
          this._ws = new settings.WebSocket(url, supportedProtocols);
          this._ws.binaryType = "arraybuffer";
          let alreadyCalledOnclose = false;
          const getKernelModel = async (evt) => {
            var _a2, _b2;
            if (this._isDisposed) {
              return;
            }
            this._reason = "";
            this._model = void 0;
            try {
              const model = await restapi.getKernelModel(this._id, settings);
              this._model = model;
              if ((model === null || model === void 0 ? void 0 : model.execution_state) === "dead") {
                this._updateStatus("dead");
              } else {
                this._onWSClose(evt);
              }
            } catch (err) {
              if (err instanceof __1.ServerConnection.NetworkError || ((_a2 = err.response) === null || _a2 === void 0 ? void 0 : _a2.status) === 503 || ((_b2 = err.response) === null || _b2 === void 0 ? void 0 : _b2.status) === 424) {
                const timeout = Private.getRandomIntInclusive(10, 30) * 1e3;
                setTimeout(getKernelModel, timeout, evt);
              } else {
                this._reason = "Kernel died unexpectedly";
                this._updateStatus("dead");
              }
            }
            return;
          };
          const earlyClose = async (evt) => {
            if (alreadyCalledOnclose) {
              return;
            }
            alreadyCalledOnclose = true;
            await getKernelModel(evt);
            return;
          };
          this._ws.onmessage = this._onWSMessage;
          this._ws.onopen = this._onWSOpen;
          this._ws.onclose = earlyClose;
          this._ws.onerror = earlyClose;
        };
        this._onWSOpen = (evt) => {
          if (this._ws.protocol !== "" && !this._supportedProtocols.includes(this._ws.protocol)) {
            console.log("Server selected unknown kernel wire protocol:", this._ws.protocol);
            this._updateStatus("dead");
            throw new Error(`Unknown kernel wire protocol:  ${this._ws.protocol}`);
          }
          this._selectedProtocol = this._ws.protocol;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
          this._updateConnectionStatus("connected");
        };
        this._onWSMessage = (evt) => {
          let msg;
          try {
            msg = this.serverSettings.serializer.deserialize(evt.data, this._ws.protocol);
            validate.validateMessage(msg);
          } catch (error) {
            error.message = `Kernel message validation error: ${error.message}`;
            throw error;
          }
          this._kernelSession = msg.header.session;
          this._msgChain = this._msgChain.then(() => {
            return this._handleMessage(msg);
          }).catch((error) => {
            if (error.message.startsWith("Canceled future for ")) {
              console.error(error);
            }
          });
          this._anyMessage.emit({ msg, direction: "recv" });
        };
        this._onWSClose = (evt) => {
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._id = "";
        this._name = "";
        this._status = "unknown";
        this._connectionStatus = "connecting";
        this._kernelSession = "";
        this._isDisposed = false;
        this._ws = null;
        this._username = "";
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._reconnectTimeout = null;
        this._supportedProtocols = Object.values(KernelMessage.supportedKernelWebSocketProtocols);
        this._selectedProtocol = "";
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._targetRegistry = /* @__PURE__ */ Object.create(null);
        this._info = new coreutils_2.PromiseDelegate();
        this._pendingMessages = [];
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._disposed = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._displayIdToParentIds = /* @__PURE__ */ new Map();
        this._msgIdToDisplayIds = /* @__PURE__ */ new Map();
        this._msgChain = Promise.resolve();
        this._hasPendingInput = false;
        this._reason = "";
        this._noOp = () => {
        };
        this._name = options.model.name;
        this._id = options.model.id;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_2.UUID.uuid4();
        this._username = (_c = options.username) !== null && _c !== void 0 ? _c : "";
        this.handleComms = (_d = options.handleComms) !== null && _d !== void 0 ? _d : true;
        this._createSocket();
      }
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal emitted when the kernel status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal emitted for iopub kernel messages.
       *
       * #### Notes
       * This signal is emitted after the iopub message is handled asynchronously.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal emitted for unhandled kernel message.
       *
       * #### Notes
       * This signal is emitted for a message that was not handled. It is emitted
       * during the asynchronous message handling code.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * The kernel model
       */
      get model() {
        return this._model || {
          id: this.id,
          name: this.name,
          reason: this._reason
        };
      }
      /**
       * A signal emitted for any kernel message.
       *
       * #### Notes
       * This signal is emitted when a message is received, before it is handled
       * asynchronously.
       *
       * This message is emitted when a message is queued for sending (either in
       * the websocket buffer, or our own pending message buffer). The message may
       * actually be sent across the wire at a later time.
       *
       * The message emitted in this signal should not be modified in any way.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a kernel has pending inputs from the user.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * The id of the server-side kernel.
       */
      get id() {
        return this._id;
      }
      /**
       * The name of the server-side kernel.
       */
      get name() {
        return this._name;
      }
      /**
       * The client username.
       */
      get username() {
        return this._username;
      }
      /**
       * The client unique id.
       */
      get clientId() {
        return this._clientId;
      }
      /**
       * The current status of the kernel.
       */
      get status() {
        return this._status;
      }
      /**
       * The current connection status of the kernel connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
      /**
       * Test whether the kernel has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * The cached kernel info.
       *
       * @returns A promise that resolves to the kernel info.
       */
      get info() {
        return this._info.promise;
      }
      /**
       * The kernel spec.
       *
       * @returns A promise that resolves to the kernel spec.
       */
      get spec() {
        if (this._specPromise) {
          return this._specPromise;
        }
        this._specPromise = kernelspec_1.KernelSpecAPI.getSpecs(this.serverSettings).then((specs) => {
          return specs.kernelspecs[this._name];
        });
        return this._specPromise;
      }
      /**
       * Clone the current kernel with a new clientId.
       */
      clone(options = {}) {
        return new _KernelConnection({
          model: this.model,
          username: this.username,
          serverSettings: this.serverSettings,
          // handleComms defaults to false since that is safer
          handleComms: false,
          ...options
        });
      }
      /**
       * Dispose of the resources held by the kernel.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearKernelState();
        this._pendingMessages = [];
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a shell message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's shell channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * shell reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendShellMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelShellFutureHandler, msg, expectReply, disposeOnDone);
      }
      /**
       * Send a control message to the kernel.
       *
       * #### Notes
       * Send a message to the kernel's control channel, yielding a future object
       * for accepting replies.
       *
       * If `expectReply` is given and `true`, the future is disposed when both a
       * control reply and an idle status message are received. If `expectReply`
       * is not given or is `false`, the future is resolved when an idle status
       * message is received.
       * If `disposeOnDone` is not given or is `true`, the Future is disposed at this point.
       * If `disposeOnDone` is given and `false`, it is up to the caller to dispose of the Future.
       *
       * All replies are validated as valid kernel messages.
       *
       * If the kernel status is `dead`, this will throw an error.
       */
      sendControlMessage(msg, expectReply = false, disposeOnDone = true) {
        return this._sendKernelShellControl(future_1.KernelControlFutureHandler, msg, expectReply, disposeOnDone);
      }
      _sendKernelShellControl(ctor, msg, expectReply = false, disposeOnDone = true) {
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        const future = new ctor(() => {
          const msgId = msg.header.msg_id;
          this._futures.delete(msgId);
          const displayIds = this._msgIdToDisplayIds.get(msgId);
          if (!displayIds) {
            return;
          }
          displayIds.forEach((displayId) => {
            const msgIds = this._displayIdToParentIds.get(displayId);
            if (msgIds) {
              const idx = msgIds.indexOf(msgId);
              if (idx === -1) {
                return;
              }
              if (msgIds.length === 1) {
                this._displayIdToParentIds.delete(displayId);
              } else {
                msgIds.splice(idx, 1);
                this._displayIdToParentIds.set(displayId, msgIds);
              }
            }
          });
          this._msgIdToDisplayIds.delete(msgId);
        }, msg, expectReply, disposeOnDone, this);
        this._futures.set(msg.header.msg_id, future);
        return future;
      }
      /**
       * Send a message on the websocket.
       *
       * If queue is true, queue the message for later sending if we cannot send
       * now. Otherwise throw an error.
       *
       * #### Notes
       * As an exception to the queueing, if we are sending a kernel_info_request
       * message while we think the kernel is restarting, we send the message
       * immediately without queueing. This is so that we can trigger a message
       * back, which will then clear the kernel restarting state.
       */
      _sendMessage(msg, queue = true) {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        if ((this._kernelSession === STARTING_KERNEL_SESSION || this._kernelSession === RESTARTING_KERNEL_SESSION) && KernelMessage.isInfoRequestMsg(msg)) {
          if (this.connectionStatus === "connected") {
            this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
            return;
          } else {
            throw new Error("Could not send message: status is not connected");
          }
        }
        if (queue && this._pendingMessages.length > 0) {
          this._pendingMessages.push(msg);
          return;
        }
        if (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION) {
          this._ws.send(this.serverSettings.serializer.serialize(msg, this._ws.protocol));
        } else if (queue) {
          this._pendingMessages.push(msg);
        } else {
          throw new Error("Could not send message");
        }
      }
      /**
       * Interrupt a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the kernel status is `Dead` or if the
       * request fails or the response is invalid.
       */
      async interrupt() {
        this.hasPendingInput = false;
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        return restapi.interruptKernel(this.id, this.serverSettings);
      }
      /**
       * Request a kernel restart.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels)
       * and validates the response model.
       *
       * Any existing Future or Comm objects are cleared once the kernel has
       * actually be restarted.
       *
       * The promise is fulfilled on a valid server response (after the kernel restarts)
       * and rejected otherwise.
       *
       * It is assumed that the API call does not mutate the kernel id or name.
       *
       * The promise will be rejected if the request fails or the response is
       * invalid.
       */
      async restart() {
        if (this.status === "dead") {
          throw new Error("Kernel is dead");
        }
        this._updateStatus("restarting");
        this._clearKernelState();
        this._kernelSession = RESTARTING_KERNEL_SESSION;
        await restapi.restartKernel(this.id, this.serverSettings);
        await this.reconnect();
        this.hasPendingInput = false;
      }
      /**
       * Reconnect to a kernel.
       *
       * #### Notes
       * This may try multiple times to reconnect to a kernel, and will sever any
       * existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Kernel connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Shutdown a kernel.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/kernels).
       *
       * The promise is fulfilled on a valid response and rejected otherwise.
       *
       * On a valid response, disposes this kernel connection.
       *
       * If the kernel is already `dead`, disposes this kernel connection without
       * a server request.
       */
      async shutdown() {
        if (this.status !== "dead") {
          await restapi.shutdownKernel(this.id, this.serverSettings);
        }
        this.handleShutdown();
      }
      /**
       * Handles a kernel shutdown.
       *
       * #### Notes
       * This method should be called if we know from outside information that a
       * kernel is dead (for example, we cannot find the kernel model on the
       * server).
       */
      handleShutdown() {
        this._updateStatus("dead");
        this.dispose();
      }
      /**
       * Send a `kernel_info_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#kernel-info).
       *
       * Fulfills with the `kernel_info_response` content when the shell reply is
       * received and validated.
       */
      async requestKernelInfo() {
        const msg = KernelMessage.createMessage({
          msgType: "kernel_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: {}
        });
        let reply;
        try {
          reply = await Private.handleShellMessage(this, msg);
        } catch (e) {
          if (this.isDisposed) {
            return;
          } else {
            throw e;
          }
        }
        this._errorIfDisposed();
        if (!reply) {
          return;
        }
        if (reply.content.status === void 0) {
          reply.content.status = "ok";
        }
        if (reply.content.status !== "ok") {
          this._info.reject("Kernel info reply errored");
          return reply;
        }
        this._info.resolve(reply.content);
        this._kernelSession = reply.header.session;
        return reply;
      }
      /**
       * Send a `complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#completion).
       *
       * Fulfills with the `complete_reply` content when the shell reply is
       * received and validated.
       */
      requestComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private.handleShellMessage(this, msg);
      }
      /**
       * Send an `inspect_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#introspection).
       *
       * Fulfills with the `inspect_reply` content when the shell reply is
       * received and validated.
       */
      requestInspect(content) {
        const msg = KernelMessage.createMessage({
          msgType: "inspect_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private.handleShellMessage(this, msg);
      }
      /**
       * Send a `history_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#history).
       *
       * Fulfills with the `history_reply` content when the shell reply is
       * received and validated.
       */
      requestHistory(content) {
        const msg = KernelMessage.createMessage({
          msgType: "history_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private.handleShellMessage(this, msg);
      }
      /**
       * Send an `execute_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#execute).
       *
       * Future `onReply` is called with the `execute_reply` content when the
       * shell reply is received and validated. The future will resolve when
       * this message is received and the `idle` iopub status is received.
       * The future will also be disposed at this point unless `disposeOnDone`
       * is specified and `false`, in which case it is up to the caller to dispose
       * of the future.
       *
       * **See also:** [[IExecuteReply]]
       */
      requestExecute(content, disposeOnDone = true, metadata) {
        const defaults = {
          silent: false,
          store_history: true,
          user_expressions: {},
          allow_stdin: true,
          stop_on_error: false
        };
        const msg = KernelMessage.createMessage({
          msgType: "execute_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content: { ...defaults, ...content },
          metadata
        });
        return this.sendShellMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an experimental `debug_request` message.
       *
       * @hidden
       *
       * #### Notes
       * Debug messages are experimental messages that are not in the official
       * kernel message specification. As such, this function is *NOT* considered
       * part of the public API, and may change without notice.
       */
      requestDebug(content, disposeOnDone = true) {
        const msg = KernelMessage.createMessage({
          msgType: "debug_request",
          channel: "control",
          username: this._username,
          session: this._clientId,
          content
        });
        return this.sendControlMessage(msg, true, disposeOnDone);
      }
      /**
       * Send an `is_complete_request` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#code-completeness).
       *
       * Fulfills with the `is_complete_response` content when the shell reply is
       * received and validated.
       */
      requestIsComplete(content) {
        const msg = KernelMessage.createMessage({
          msgType: "is_complete_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private.handleShellMessage(this, msg);
      }
      /**
       * Send a `comm_info_request` message.
       *
       * #### Notes
       * Fulfills with the `comm_info_reply` content when the shell reply is
       * received and validated.
       */
      requestCommInfo(content) {
        const msg = KernelMessage.createMessage({
          msgType: "comm_info_request",
          channel: "shell",
          username: this._username,
          session: this._clientId,
          content
        });
        return Private.handleShellMessage(this, msg);
      }
      /**
       * Send an `input_reply` message.
       *
       * #### Notes
       * See [Messaging in Jupyter](https://jupyter-client.readthedocs.io/en/latest/messaging.html#messages-on-the-stdin-router-dealer-sockets).
       */
      sendInputReply(content, parent_header) {
        const msg = KernelMessage.createMessage({
          msgType: "input_reply",
          channel: "stdin",
          username: this._username,
          session: this._clientId,
          content
        });
        msg.parent_header = parent_header;
        this._sendMessage(msg);
        this._anyMessage.emit({ msg, direction: "send" });
        this.hasPendingInput = false;
      }
      /**
       * Create a new comm.
       *
       * #### Notes
       * If a client-side comm already exists with the given commId, an error is thrown.
       * If the kernel does not handle comms, an error is thrown.
       */
      createComm(targetName, commId = coreutils_2.UUID.uuid4()) {
        if (!this.handleComms) {
          throw new Error("Comms are disabled on this kernel connection");
        }
        if (this._comms.has(commId)) {
          throw new Error("Comm is already created");
        }
        const comm = new comm_1.CommHandler(targetName, commId, this, () => {
          this._unregisterComm(commId);
        });
        this._comms.set(commId, comm);
        return comm;
      }
      /**
       * Check if a comm exists.
       */
      hasComm(commId) {
        return this._comms.has(commId);
      }
      /**
       * Register a comm target handler.
       *
       * @param targetName - The name of the comm target.
       *
       * @param callback - The callback invoked for a comm open message.
       *
       * @returns A disposable used to unregister the comm target.
       *
       * #### Notes
       * Only one comm target can be registered to a target name at a time, an
       * existing callback for the same target name will be overridden.  A registered
       * comm target handler will take precedence over a comm which specifies a
       * `target_module`.
       *
       * If the callback returns a promise, kernel message processing will pause
       * until the returned promise is fulfilled.
       */
      registerCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        this._targetRegistry[targetName] = callback;
      }
      /**
       * Remove a comm target handler.
       *
       * @param targetName - The name of the comm target to remove.
       *
       * @param callback - The callback to remove.
       *
       * #### Notes
       * The comm target is only removed if the callback argument matches.
       */
      removeCommTarget(targetName, callback) {
        if (!this.handleComms) {
          return;
        }
        if (!this.isDisposed && this._targetRegistry[targetName] === callback) {
          delete this._targetRegistry[targetName];
        }
      }
      /**
       * Register an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook will intercept.
       *
       * @param hook - The callback invoked for the message.
       *
       * #### Notes
       * The IOPub hook system allows you to preempt the handlers for IOPub
       * messages that are responses to a given message id.
       *
       * The most recently registered hook is run first. A hook can return a
       * boolean or a promise to a boolean, in which case all kernel message
       * processing pauses until the promise is fulfilled. If a hook return value
       * resolves to false, any later hooks will not run and the function will
       * return a promise resolving to false. If a hook throws an error, the error
       * is logged to the console and the next hook is run. If a hook is
       * registered during the hook processing, it will not run until the next
       * message. If a hook is removed during the hook processing, it will be
       * deactivated immediately.
       *
       * See also [[IFuture.registerMessageHook]].
       */
      registerMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.registerMessageHook(hook);
        }
      }
      /**
       * Remove an IOPub message hook.
       *
       * @param msg_id - The parent_header message id the hook intercepted.
       *
       * @param hook - The callback invoked for the message.
       *
       */
      removeMessageHook(msgId, hook) {
        var _a;
        const future = (_a = this._futures) === null || _a === void 0 ? void 0 : _a.get(msgId);
        if (future) {
          future.removeMessageHook(hook);
        }
      }
      /**
       * Remove the input guard, if any.
       */
      removeInputGuard() {
        this.hasPendingInput = false;
      }
      /**
       * Handle a message with a display id.
       *
       * @returns Whether the message was handled.
       */
      async _handleDisplayId(displayId, msg) {
        var _a, _b;
        const msgId = msg.parent_header.msg_id;
        let parentIds = this._displayIdToParentIds.get(displayId);
        if (parentIds) {
          const updateMsg = {
            header: coreutils_2.JSONExt.deepCopy(msg.header),
            parent_header: coreutils_2.JSONExt.deepCopy(msg.parent_header),
            metadata: coreutils_2.JSONExt.deepCopy(msg.metadata),
            content: coreutils_2.JSONExt.deepCopy(msg.content),
            channel: msg.channel,
            buffers: msg.buffers ? msg.buffers.slice() : []
          };
          updateMsg.header.msg_type = "update_display_data";
          await Promise.all(parentIds.map(async (parentId) => {
            const future = this._futures && this._futures.get(parentId);
            if (future) {
              await future.handleMsg(updateMsg);
            }
          }));
        }
        if (msg.header.msg_type === "update_display_data") {
          return true;
        }
        parentIds = (_a = this._displayIdToParentIds.get(displayId)) !== null && _a !== void 0 ? _a : [];
        if (parentIds.indexOf(msgId) === -1) {
          parentIds.push(msgId);
        }
        this._displayIdToParentIds.set(displayId, parentIds);
        const displayIds = (_b = this._msgIdToDisplayIds.get(msgId)) !== null && _b !== void 0 ? _b : [];
        if (displayIds.indexOf(msgId) === -1) {
          displayIds.push(msgId);
        }
        this._msgIdToDisplayIds.set(msgId, displayIds);
        return false;
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Handle status iopub messages from the kernel.
       */
      _updateStatus(status) {
        if (this._status === status || this._status === "dead") {
          return;
        }
        this._status = status;
        Private.logKernelStatus(this);
        this._statusChanged.emit(status);
        if (status === "dead") {
          this.dispose();
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._kernelSession !== RESTARTING_KERNEL_SESSION && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Clear the internal state.
       */
      _clearKernelState() {
        this._kernelSession = "";
        this._pendingMessages = [];
        this._futures.forEach((future) => {
          future.dispose();
        });
        this._comms.forEach((comm) => {
          comm.dispose();
        });
        this._msgChain = Promise.resolve();
        this._futures = /* @__PURE__ */ new Map();
        this._comms = /* @__PURE__ */ new Map();
        this._displayIdToParentIds.clear();
        this._msgIdToDisplayIds.clear();
      }
      /**
       * Check to make sure it is okay to proceed to handle a message.
       *
       * #### Notes
       * Because we handle messages asynchronously, before a message is handled the
       * kernel might be disposed or restarted (and have a different session id).
       * This function throws an error in each of these cases. This is meant to be
       * called at the start of an asynchronous message handler to cancel message
       * processing if the message no longer is valid.
       */
      _assertCurrentMessage(msg) {
        this._errorIfDisposed();
        if (msg.header.session !== this._kernelSession) {
          throw new Error(`Canceling handling of old message: ${msg.header.msg_type}`);
        }
      }
      /**
       * Handle a `comm_open` kernel message.
       */
      async _handleCommOpen(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = new comm_1.CommHandler(content.target_name, content.comm_id, this, () => {
          this._unregisterComm(content.comm_id);
        });
        this._comms.set(content.comm_id, comm);
        try {
          const target = await Private.loadObject(content.target_name, content.target_module, this._targetRegistry);
          await target(comm, msg);
        } catch (e) {
          comm.close();
          console.error("Exception opening new comm");
          throw e;
        }
      }
      /**
       * Handle 'comm_close' kernel message.
       */
      async _handleCommClose(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          console.error("Comm not found for comm id " + content.comm_id);
          return;
        }
        this._unregisterComm(comm.commId);
        const onClose = comm.onClose;
        if (onClose) {
          await onClose(msg);
        }
        comm.dispose();
      }
      /**
       * Handle a 'comm_msg' kernel message.
       */
      async _handleCommMsg(msg) {
        this._assertCurrentMessage(msg);
        const content = msg.content;
        const comm = this._comms.get(content.comm_id);
        if (!comm) {
          return;
        }
        const onMsg = comm.onMsg;
        if (onMsg) {
          await onMsg(msg);
        }
      }
      /**
       * Unregister a comm instance.
       */
      _unregisterComm(commId) {
        this._comms.delete(commId);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (this.status !== "dead") {
          if (connectionStatus === "connected") {
            let restarting = this._kernelSession === RESTARTING_KERNEL_SESSION;
            let p = this.requestKernelInfo();
            let sendPendingCalled = false;
            let sendPendingOnce = () => {
              if (sendPendingCalled) {
                return;
              }
              sendPendingCalled = true;
              if (restarting && this._kernelSession === RESTARTING_KERNEL_SESSION) {
                this._kernelSession = "";
              }
              clearTimeout(timeoutHandle);
              if (this._pendingMessages.length > 0) {
                this._sendPending();
              }
            };
            void p.then(sendPendingOnce);
            let timeoutHandle = setTimeout(sendPendingOnce, KERNEL_INFO_TIMEOUT);
          } else {
            this._updateStatus("unknown");
          }
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      async _handleMessage(msg) {
        var _a, _b;
        let handled = false;
        if (msg.parent_header && msg.channel === "iopub" && (KernelMessage.isDisplayDataMsg(msg) || KernelMessage.isUpdateDisplayDataMsg(msg) || KernelMessage.isExecuteResultMsg(msg))) {
          const transient = (_a = msg.content.transient) !== null && _a !== void 0 ? _a : {};
          const displayId = transient["display_id"];
          if (displayId) {
            handled = await this._handleDisplayId(displayId, msg);
            this._assertCurrentMessage(msg);
          }
        }
        if (!handled && msg.parent_header) {
          const parentHeader = msg.parent_header;
          const future = (_b = this._futures) === null || _b === void 0 ? void 0 : _b.get(parentHeader.msg_id);
          if (future) {
            await future.handleMsg(msg);
            this._assertCurrentMessage(msg);
          } else {
            const owned = parentHeader.session === this.clientId;
            if (msg.channel !== "iopub" && owned) {
              this._unhandledMessage.emit(msg);
            }
          }
        }
        if (msg.channel === "iopub") {
          switch (msg.header.msg_type) {
            case "status": {
              const executionState = msg.content.execution_state;
              if (executionState === "restarting") {
                void Promise.resolve().then(async () => {
                  this._updateStatus("autorestarting");
                  this._clearKernelState();
                  await this.reconnect();
                });
              }
              this._updateStatus(executionState);
              break;
            }
            case "comm_open":
              if (this.handleComms) {
                await this._handleCommOpen(msg);
              }
              break;
            case "comm_msg":
              if (this.handleComms) {
                await this._handleCommMsg(msg);
              }
              break;
            case "comm_close":
              if (this.handleComms) {
                await this._handleCommClose(msg);
              }
              break;
            default:
              break;
          }
          if (!this.isDisposed) {
            this._assertCurrentMessage(msg);
            this._iopubMessage.emit(msg);
          }
        }
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.warn(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          const useProtocols = this._selectedProtocol !== "" ? true : false;
          this._reconnectTimeout = setTimeout(this._createSocket, timeout, useProtocols);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Kernel connection is disposed");
        }
      }
      get hasPendingInput() {
        return this._hasPendingInput;
      }
      set hasPendingInput(value) {
        this._hasPendingInput = value;
        this._pendingInput.emit(value);
      }
    };
    exports2.KernelConnection = KernelConnection;
    var Private;
    (function(Private2) {
      function logKernelStatus(kernel) {
        switch (kernel.status) {
          case "idle":
          case "busy":
          case "unknown":
            return;
          default:
            console.debug(`Kernel: ${kernel.status} (${kernel.id})`);
            break;
        }
      }
      Private2.logKernelStatus = logKernelStatus;
      async function handleShellMessage(kernel, msg) {
        const future = kernel.sendShellMessage(msg, true);
        return future.done;
      }
      Private2.handleShellMessage = handleShellMessage;
      function loadObject(name2, moduleName, registry) {
        return new Promise((resolve, reject) => {
          if (moduleName) {
            if (typeof requirejs === "undefined") {
              throw new Error("requirejs not found");
            }
            requirejs([moduleName], (mod) => {
              if (mod[name2] === void 0) {
                const msg = `Object '${name2}' not found in module '${moduleName}'`;
                reject(new Error(msg));
              } else {
                resolve(mod[name2]);
              }
            }, reject);
          } else {
            if (registry === null || registry === void 0 ? void 0 : registry[name2]) {
              resolve(registry[name2]);
            } else {
              reject(new Error(`Object '${name2}' not found in registry`));
            }
          }
        });
      }
      Private2.loadObject = loadObject;
      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      Private2.getRandomIntInclusive = getRandomIntInclusive;
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/kernel/manager.js
var require_manager2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelManager = void 0;
    var polling_1 = require_dist3();
    var signaling_1 = require_dist2();
    var __1 = require_lib3();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi();
    var default_1 = require_default();
    var KernelManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new kernel manager.
       *
       * @param options - The default options for kernel.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._kernelConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:KernelManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running kernels change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._kernelConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Connect to an existing kernel.
       *
       * @returns The new kernel connection.
       *
       * #### Notes
       * This will use the manager's server settings and ignore any server
       * settings passed in the options.
       */
      connectTo(options) {
        var _a;
        const { id } = options.model;
        let handleComms = (_a = options.handleComms) !== null && _a !== void 0 ? _a : true;
        if (options.handleComms === void 0) {
          for (const kc of this._kernelConnections) {
            if (kc.id === id && kc.handleComms) {
              handleComms = false;
              break;
            }
          }
        }
        const kernelConnection = new default_1.KernelConnection({
          handleComms,
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(kernelConnection);
        if (!this._models.has(id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return kernelConnection;
      }
      /**
       * Create an iterator over the most recent running kernels.
       *
       * @returns A new iterator over the running kernels.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running kernels.
       *
       * @returns A promise that resolves when the running list has been refreshed.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new kernel.
       *
       * @param createOptions - The kernel creation options
       *
       * @param connectOptions - The kernel connection options
       *
       * @returns A promise that resolves with the kernel connection.
       *
       * #### Notes
       * The manager `serverSettings` will be always be used.
       */
      async startNew(createOptions = {}, connectOptions = {}) {
        const model = await (0, restapi_1.startNew)(createOptions, this.serverSettings);
        return this.connectTo({
          ...connectOptions,
          model
        });
      }
      /**
       * Shut down a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves when the operation is complete.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownKernel)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all kernels.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownKernel)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a kernel by id.
       *
       * @param id - The id of the target kernel.
       *
       * @returns A promise that resolves with the kernel's model.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return existing.connections === model.connections && existing.execution_state === model.execution_state && existing.last_activity === model.last_activity && existing.name === model.name && existing.reason === model.reason && existing.traceback === model.traceback;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._kernelConnections.forEach((kc) => {
          if (!this._models.has(kc.id)) {
            kc.handleShutdown();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a kernel starting.
       */
      _onStarted(kernelConnection) {
        this._kernelConnections.add(kernelConnection);
        kernelConnection.statusChanged.connect(this._onStatusChanged, this);
        kernelConnection.disposed.connect(this._onDisposed, this);
      }
      _onDisposed(kernelConnection) {
        this._kernelConnections.delete(kernelConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onStatusChanged(kernelConnection, status) {
        if (status === "dead") {
          void this.refreshRunning().catch(() => {
          });
        }
      }
    };
    exports2.KernelManager = KernelManager2;
    (function(KernelManager3) {
      class NoopManager extends KernelManager3 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new kernel - throws an error since it is not supported.
         */
        async startNew(createOptions = {}, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * Connect to an existing kernel - throws an error since it is not supported.
         */
        connectTo(options) {
          throw new Error("Not implemented in no-op Kernel Manager");
        }
        /**
         * Shut down a kernel by id - throws an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Kernel Manager"));
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Execute a request to the server to poll running kernels and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      KernelManager3.NoopManager = NoopManager;
    })(KernelManager2 || (exports2.KernelManager = KernelManager2 = {}));
  }
});

// node_modules/@jupyterlab/services/lib/kernel/index.js
var require_kernel2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/kernel/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KernelConnection = exports2.KernelAPI = exports2.KernelMessage = exports2.Kernel = void 0;
    var Kernel = __importStar(require_kernel());
    exports2.Kernel = Kernel;
    var KernelMessage = __importStar(require_messages());
    exports2.KernelMessage = KernelMessage;
    var KernelAPI = __importStar(require_restapi());
    exports2.KernelAPI = KernelAPI;
    var default_1 = require_default();
    Object.defineProperty(exports2, "KernelConnection", { enumerable: true, get: function() {
      return default_1.KernelConnection;
    } });
    __exportStar(require_manager2(), exports2);
  }
});

// node_modules/@jupyterlab/services/lib/builder/index.js
var require_builder = __commonJS({
  "node_modules/@jupyterlab/services/lib/builder/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildManager = void 0;
    var coreutils_12 = require_lib();
    var serverconnection_1 = require_serverconnection();
    var BUILD_SETTINGS_URL = "api/build";
    var BuildManager = class {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        this._url = "";
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const { baseUrl, appUrl } = this.serverSettings;
        this._url = coreutils_12.URLExt.join(baseUrl, appUrl, BUILD_SETTINGS_URL);
      }
      /**
       * Test whether the build service is available.
       */
      get isAvailable() {
        return coreutils_12.PageConfig.getOption("buildAvailable").toLowerCase() === "true";
      }
      /**
       * Test whether to check build status automatically.
       */
      get shouldCheck() {
        return coreutils_12.PageConfig.getOption("buildCheck").toLowerCase() === "true";
      }
      /**
       * Get whether the application should be built.
       */
      getStatus() {
        const { _url, serverSettings } = this;
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, {}, serverSettings);
        return promise.then((response) => {
          if (response.status !== 200) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
          return response.json();
        }).then((data) => {
          if (typeof data.status !== "string") {
            throw new Error("Invalid data");
          }
          if (typeof data.message !== "string") {
            throw new Error("Invalid data");
          }
          return data;
        });
      }
      /**
       * Build the application.
       */
      build() {
        const { _url, serverSettings } = this;
        const init = { method: "POST" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status === 400) {
            throw new serverconnection_1.ServerConnection.ResponseError(response, "Build aborted");
          }
          if (response.status !== 200) {
            const message = `Build failed with ${response.status}.

        If you are experiencing the build failure after installing an extension (or trying to include previously installed extension after updating JupyterLab) please check the extension repository for new installation instructions as many extensions migrated to the prebuilt extensions system which no longer requires rebuilding JupyterLab (but uses a different installation procedure, typically involving a package manager such as 'pip' or 'conda').

        If you specifically intended to install a source extension, please run 'jupyter lab build' on the server for full output.`;
            throw new serverconnection_1.ServerConnection.ResponseError(response, message);
          }
        });
      }
      /**
       * Cancel an active build.
       */
      cancel() {
        const { _url, serverSettings } = this;
        const init = { method: "DELETE" };
        const promise = serverconnection_1.ServerConnection.makeRequest(_url, init, serverSettings);
        return promise.then((response) => {
          if (response.status !== 204) {
            throw new serverconnection_1.ServerConnection.ResponseError(response);
          }
        });
      }
    };
    exports2.BuildManager = BuildManager;
  }
});

// node_modules/@jupyterlab/services/lib/nbconvert/index.js
var require_nbconvert = __commonJS({
  "node_modules/@jupyterlab/services/lib/nbconvert/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NbConvertManager = void 0;
    var coreutils_12 = require_lib();
    var serverconnection_1 = require_serverconnection();
    var coreutils_2 = require_index_node();
    var NBCONVERT_SETTINGS_URL = "api/nbconvert";
    var NbConvertManager = class {
      /**
       * Create a new nbconvert manager.
       */
      constructor(options = {}) {
        var _a;
        this._exportFormats = null;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch and cache the export formats from the expensive nbconvert handler.
       */
      async fetchExportFormats() {
        this._requestingFormats = new coreutils_2.PromiseDelegate();
        this._exportFormats = null;
        const base = this.serverSettings.baseUrl;
        const url = coreutils_12.URLExt.join(base, NBCONVERT_SETTINGS_URL);
        const { serverSettings } = this;
        const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
          throw err;
        }
        const data = await response.json();
        const exportList = {};
        const keys = Object.keys(data);
        keys.forEach(function(key) {
          const mimeType = data[key].output_mimetype;
          exportList[key] = { output_mimetype: mimeType };
        });
        this._exportFormats = exportList;
        this._requestingFormats.resolve(exportList);
        return exportList;
      }
      /**
       * Get the list of export formats, preferring pre-cached ones.
       */
      async getExportFormats(force = true) {
        if (this._requestingFormats) {
          return this._requestingFormats.promise;
        }
        if (force || !this._exportFormats) {
          return await this.fetchExportFormats();
        }
        return this._exportFormats;
      }
    };
    exports2.NbConvertManager = NbConvertManager;
  }
});

// node_modules/@jupyterlab/services/lib/session/session.js
var require_session = __commonJS({
  "node_modules/@jupyterlab/services/lib/session/session.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@jupyterlab/services/lib/session/validate.js
var require_validate5 = __commonJS({
  "node_modules/@jupyterlab/services/lib/session/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateModels = exports2.updateLegacySessionModel = exports2.validateModel = void 0;
    var validate_1 = require_validate3();
    var validate_2 = require_validate();
    function validateModel(data) {
      (0, validate_2.validateProperty)(data, "id", "string");
      (0, validate_2.validateProperty)(data, "type", "string");
      (0, validate_2.validateProperty)(data, "name", "string");
      (0, validate_2.validateProperty)(data, "path", "string");
      (0, validate_2.validateProperty)(data, "kernel", "object");
      (0, validate_1.validateModel)(data.kernel);
    }
    exports2.validateModel = validateModel;
    function updateLegacySessionModel(data) {
      if (data.path === void 0 && data.notebook !== void 0) {
        data.path = data.notebook.path;
        data.type = "notebook";
        data.name = "";
      }
    }
    exports2.updateLegacySessionModel = updateLegacySessionModel;
    function validateModels(models) {
      if (!Array.isArray(models)) {
        throw new Error("Invalid session list");
      }
      models.forEach((d) => validateModel(d));
    }
    exports2.validateModels = validateModels;
  }
});

// node_modules/@jupyterlab/services/lib/session/restapi.js
var require_restapi3 = __commonJS({
  "node_modules/@jupyterlab/services/lib/session/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.updateSession = exports2.startSession = exports2.getSessionModel = exports2.shutdownSession = exports2.getSessionUrl = exports2.listRunning = exports2.SESSION_SERVICE_URL = void 0;
    var serverconnection_1 = require_serverconnection();
    var coreutils_12 = require_lib();
    var validate_1 = require_validate5();
    exports2.SESSION_SERVICE_URL = "api/sessions";
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid Session list");
      }
      data.forEach((m) => {
        (0, validate_1.updateLegacySessionModel)(m);
        (0, validate_1.validateModel)(m);
      });
      return data;
    }
    exports2.listRunning = listRunning;
    function getSessionUrl(baseUrl, id) {
      const servicesBase = coreutils_12.URLExt.join(baseUrl, exports2.SESSION_SERVICE_URL);
      const result = coreutils_12.URLExt.join(servicesBase, id);
      if (!result.startsWith(servicesBase)) {
        throw new Error("Can only be used for services requests");
      }
      return result;
    }
    exports2.getSessionUrl = getSessionUrl;
    async function shutdownSession(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      const url = getSessionUrl(settings.baseUrl, id);
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The session "${id}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status === 410) {
        throw new serverconnection_1.ServerConnection.ResponseError(response, "The kernel was deleted but the session was not");
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownSession = shutdownSession;
    async function getSessionModel(id, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, id);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.getSessionModel = getSessionModel;
    async function startSession(options, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.SESSION_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify(options)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 201) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.startSession = startSession;
    async function updateSession(model, settings = serverconnection_1.ServerConnection.makeSettings()) {
      const url = getSessionUrl(settings.baseUrl, model.id);
      const init = {
        method: "PATCH",
        body: JSON.stringify(model)
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      (0, validate_1.updateLegacySessionModel)(data);
      (0, validate_1.validateModel)(data);
      return data;
    }
    exports2.updateSession = updateSession;
  }
});

// node_modules/@jupyterlab/services/lib/session/default.js
var require_default2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/session/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionConnection = void 0;
    var signaling_1 = require_dist2();
    var __1 = require_lib3();
    var restapi_1 = require_restapi3();
    var coreutils_12 = require_index_node();
    var SessionConnection = class {
      /**
       * Construct a new session.
       */
      constructor(options) {
        var _a, _b, _c, _d;
        this._id = "";
        this._path = "";
        this._name = "";
        this._type = "";
        this._kernel = null;
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._kernelChanged = new signaling_1.Signal(this);
        this._statusChanged = new signaling_1.Signal(this);
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._pendingInput = new signaling_1.Signal(this);
        this._iopubMessage = new signaling_1.Signal(this);
        this._unhandledMessage = new signaling_1.Signal(this);
        this._anyMessage = new signaling_1.Signal(this);
        this._propertyChanged = new signaling_1.Signal(this);
        this._id = options.model.id;
        this._name = options.model.name;
        this._path = options.model.path;
        this._type = options.model.type;
        this._username = (_a = options.username) !== null && _a !== void 0 ? _a : "";
        this._clientId = (_b = options.clientId) !== null && _b !== void 0 ? _b : coreutils_12.UUID.uuid4();
        this._connectToKernel = options.connectToKernel;
        this._kernelConnectionOptions = (_c = options.kernelConnectionOptions) !== null && _c !== void 0 ? _c : {};
        this.serverSettings = (_d = options.serverSettings) !== null && _d !== void 0 ? _d : __1.ServerConnection.makeSettings();
        this.setupKernel(options.model.kernel);
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when the kernel changes.
       */
      get kernelChanged() {
        return this._kernelChanged;
      }
      /**
       * A signal proxied from the connection about the kernel status.
       */
      get statusChanged() {
        return this._statusChanged;
      }
      /**
       * A signal proxied from the kernel about the connection status.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * A signal proxied from the kernel pending input.
       */
      get pendingInput() {
        return this._pendingInput;
      }
      /**
       * A signal proxied from the kernel about iopub kernel messages.
       */
      get iopubMessage() {
        return this._iopubMessage;
      }
      /**
       * A signal proxied from the kernel for an unhandled kernel message.
       */
      get unhandledMessage() {
        return this._unhandledMessage;
      }
      /**
       * A signal proxied from the kernel emitted for any kernel message.
       *
       * #### Notes
       * The behavior is undefined if the message is modified during message
       * handling. As such, it should be treated as read-only.
       */
      get anyMessage() {
        return this._anyMessage;
      }
      /**
       * A signal emitted when a session property changes.
       */
      get propertyChanged() {
        return this._propertyChanged;
      }
      /**
       * Get the session id.
       */
      get id() {
        return this._id;
      }
      /**
       * Get the session kernel connection object.
       *
       * #### Notes
       * This is a read-only property, and can be altered by [changeKernel].
       */
      get kernel() {
        return this._kernel;
      }
      /**
       * Get the session path.
       */
      get path() {
        return this._path;
      }
      /**
       * Get the session type.
       */
      get type() {
        return this._type;
      }
      /**
       * Get the session name.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model associated with the session.
       */
      get model() {
        return {
          id: this.id,
          kernel: this.kernel && { id: this.kernel.id, name: this.kernel.name },
          path: this._path,
          type: this._type,
          name: this._name
        };
      }
      /**
       * Test whether the session has been disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Update the session based on a session model from the server.
       *
       * #### Notes
       * This only updates this session connection instance. Use `setPath`,
       * `setName`, `setType`, and `changeKernel` to change the session values on
       * the server.
       */
      update(model) {
        const oldModel = this.model;
        this._path = model.path;
        this._name = model.name;
        this._type = model.type;
        if (this._kernel === null && model.kernel !== null || this._kernel !== null && model.kernel === null || this._kernel !== null && model.kernel !== null && this._kernel.id !== model.kernel.id) {
          if (this._kernel !== null) {
            this._kernel.dispose();
          }
          const oldValue = this._kernel || null;
          this.setupKernel(model.kernel);
          const newValue = this._kernel || null;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        this._handleModelChange(oldModel);
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        if (this._kernel) {
          this._kernel.dispose();
          const oldValue = this._kernel;
          this._kernel = null;
          const newValue = this._kernel;
          this._kernelChanged.emit({ name: "kernel", oldValue, newValue });
        }
        signaling_1.Signal.clearData(this);
      }
      /**
       * Change the session path.
       *
       * @param path - The new session path.
       *
       * @returns A promise that resolves when the session has renamed.
       *
       * #### Notes
       * This uses the Jupyter REST API, and the response is validated.
       * The promise is fulfilled on a valid response and rejected otherwise.
       */
      async setPath(path2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ path: path2 });
      }
      /**
       * Change the session name.
       */
      async setName(name2) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ name: name2 });
      }
      /**
       * Change the session type.
       */
      async setType(type) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ type });
      }
      /**
       * Change the kernel.
       *
       * @param options - The name or id of the new kernel.
       *
       * #### Notes
       * This shuts down the existing kernel and creates a new kernel,
       * keeping the existing session ID and session path.
       */
      async changeKernel(options) {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await this._patch({ kernel: options });
        return this.kernel;
      }
      /**
       * Kill the kernel and shutdown the session.
       *
       * @returns - The promise fulfilled on a valid response from the server.
       *
       * #### Notes
       * Uses the [Jupyter Server API](https://petstore.swagger.io/?url=https://raw.githubusercontent.com/jupyter-server/jupyter_server/main/jupyter_server/services/api/api.yaml#!/sessions), and validates the response.
       * Disposes of the session and emits a [sessionDied] signal on success.
       */
      async shutdown() {
        if (this.isDisposed) {
          throw new Error("Session is disposed");
        }
        await (0, restapi_1.shutdownSession)(this.id, this.serverSettings);
        this.dispose();
      }
      /**
       * Create a new kernel connection and connect to its signals.
       *
       * #### Notes
       * This method is not meant to be subclassed.
       */
      setupKernel(model) {
        if (model === null) {
          this._kernel = null;
          return;
        }
        const kc = this._connectToKernel({
          ...this._kernelConnectionOptions,
          model,
          username: this._username,
          clientId: this._clientId,
          serverSettings: this.serverSettings
        });
        this._kernel = kc;
        kc.statusChanged.connect(this.onKernelStatus, this);
        kc.connectionStatusChanged.connect(this.onKernelConnectionStatus, this);
        kc.pendingInput.connect(this.onPendingInput, this);
        kc.unhandledMessage.connect(this.onUnhandledMessage, this);
        kc.iopubMessage.connect(this.onIOPubMessage, this);
        kc.anyMessage.connect(this.onAnyMessage, this);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelStatus(sender, state) {
        this._statusChanged.emit(state);
      }
      /**
       * Handle to changes in the Kernel status.
       */
      onKernelConnectionStatus(sender, state) {
        this._connectionStatusChanged.emit(state);
      }
      /**
       * Handle a change in the pendingInput.
       */
      onPendingInput(sender, state) {
        this._pendingInput.emit(state);
      }
      /**
       * Handle iopub kernel messages.
       */
      onIOPubMessage(sender, msg) {
        this._iopubMessage.emit(msg);
      }
      /**
       * Handle unhandled kernel messages.
       */
      onUnhandledMessage(sender, msg) {
        this._unhandledMessage.emit(msg);
      }
      /**
       * Handle any kernel messages.
       */
      onAnyMessage(sender, args) {
        this._anyMessage.emit(args);
      }
      /**
       * Send a PATCH to the server, updating the session path or the kernel.
       */
      async _patch(body) {
        const model = await (0, restapi_1.updateSession)({ ...body, id: this._id }, this.serverSettings);
        this.update(model);
        return model;
      }
      /**
       * Handle a change to the model.
       */
      _handleModelChange(oldModel) {
        if (oldModel.name !== this._name) {
          this._propertyChanged.emit("name");
        }
        if (oldModel.type !== this._type) {
          this._propertyChanged.emit("type");
        }
        if (oldModel.path !== this._path) {
          this._propertyChanged.emit("path");
        }
      }
    };
    exports2.SessionConnection = SessionConnection;
  }
});

// node_modules/@jupyterlab/services/lib/session/manager.js
var require_manager3 = __commonJS({
  "node_modules/@jupyterlab/services/lib/session/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionManager = void 0;
    var polling_1 = require_dist3();
    var signaling_1 = require_dist2();
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var default_1 = require_default2();
    var restapi_1 = require_restapi3();
    var SessionManager2 = class extends basemanager_1.BaseManager {
      /**
       * Construct a new session manager.
       *
       * @param options - The default options for each session.
       */
      constructor(options) {
        var _a;
        super(options);
        this._isReady = false;
        this._sessionConnections = /* @__PURE__ */ new Set();
        this._models = /* @__PURE__ */ new Map();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._connectToKernel = (options2) => {
          return this._kernelManager.connectTo(options2);
        };
        this._kernelManager = options.kernelManager;
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:SessionManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          if (this._kernelManager.isActive) {
            await this._kernelManager.ready;
          }
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running sessions change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._models.clear();
        this._sessionConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /*
       * Connect to a running session.  See also [[connectToSession]].
       */
      connectTo(options) {
        const sessionConnection = new default_1.SessionConnection({
          ...options,
          connectToKernel: this._connectToKernel,
          serverSettings: this.serverSettings
        });
        this._onStarted(sessionConnection);
        if (!this._models.has(options.model.id)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return sessionConnection;
      }
      /**
       * Create an iterator over the most recent running sessions.
       *
       * @returns A new iterator over the running sessions.
       */
      running() {
        return this._models.values();
      }
      /**
       * Force a refresh of the running sessions.
       *
       * @returns A promise that with the list of running sessions.
       *
       * #### Notes
       * This is not typically meant to be called by the user, since the
       * manager maintains its own internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Start a new session.  See also [[startNewSession]].
       *
       * @param createOptions - Options for creating the session
       *
       * @param connectOptions - Options for connecting to the session
       */
      async startNew(createOptions, connectOptions = {}) {
        const model = await (0, restapi_1.startSession)(createOptions, this.serverSettings);
        await this.refreshRunning();
        return this.connectTo({ ...connectOptions, model });
      }
      /**
       * Shut down a session by id.
       */
      async shutdown(id) {
        await (0, restapi_1.shutdownSession)(id, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all sessions.
       *
       * @returns A promise that resolves when all of the kernels are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all([...this._models.keys()].map((id) => (0, restapi_1.shutdownSession)(id, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Find a session associated with a path and stop it if it is the only session
       * using that kernel.
       *
       * @param path - The path in question.
       *
       * @returns A promise that resolves when the relevant sessions are stopped.
       */
      async stopIfNeeded(path2) {
        try {
          const sessions = await (0, restapi_1.listRunning)(this.serverSettings);
          const matches = sessions.filter((value) => value.path === path2);
          if (matches.length === 1) {
            const id = matches[0].id;
            await this.shutdown(id);
          }
        } catch (error) {
        }
      }
      /**
       * Find a session by id.
       */
      async findById(id) {
        if (this._models.has(id)) {
          return this._models.get(id);
        }
        await this.refreshRunning();
        return this._models.get(id);
      }
      /**
       * Find a session by path.
       */
      async findByPath(path2) {
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        await this.refreshRunning();
        for (const m of this._models.values()) {
          if (m.path === path2) {
            return m;
          }
        }
        return void 0;
      }
      /**
       * Execute a request to the server to poll running kernels and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof serverconnection_1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        if (this._models.size === models.length && models.every((model) => {
          var _a2, _b2, _c, _d;
          const existing = this._models.get(model.id);
          if (!existing) {
            return false;
          }
          return ((_a2 = existing.kernel) === null || _a2 === void 0 ? void 0 : _a2.id) === ((_b2 = model.kernel) === null || _b2 === void 0 ? void 0 : _b2.id) && ((_c = existing.kernel) === null || _c === void 0 ? void 0 : _c.name) === ((_d = model.kernel) === null || _d === void 0 ? void 0 : _d.name) && existing.name === model.name && existing.path === model.path && existing.type === model.type;
        })) {
          return;
        }
        this._models = new Map(models.map((x) => [x.id, x]));
        this._sessionConnections.forEach((sc) => {
          if (this._models.has(sc.id)) {
            sc.update(this._models.get(sc.id));
          } else {
            sc.dispose();
          }
        });
        this._runningChanged.emit(models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(sessionConnection) {
        this._sessionConnections.add(sessionConnection);
        sessionConnection.disposed.connect(this._onDisposed, this);
        sessionConnection.propertyChanged.connect(this._onChanged, this);
        sessionConnection.kernelChanged.connect(this._onChanged, this);
      }
      _onDisposed(sessionConnection) {
        this._sessionConnections.delete(sessionConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      _onChanged() {
        void this.refreshRunning().catch(() => {
        });
      }
    };
    exports2.SessionManager = SessionManager2;
    (function(SessionManager3) {
      class NoopManager extends SessionManager3 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * Start a new session - throw an error since it is not supported.
         */
        async startNew(createOptions, connectOptions = {}) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /*
         * Connect to a running session - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Session Manager");
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Session Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      SessionManager3.NoopManager = NoopManager;
    })(SessionManager2 || (exports2.SessionManager = SessionManager2 = {}));
  }
});

// node_modules/@jupyterlab/services/lib/session/index.js
var require_session2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/session/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SessionAPI = exports2.Session = void 0;
    var Session = __importStar(require_session());
    exports2.Session = Session;
    var SessionAPI = __importStar(require_restapi3());
    exports2.SessionAPI = SessionAPI;
    __exportStar(require_manager3(), exports2);
  }
});

// node_modules/@jupyterlab/statedb/lib/dataconnector.js
var require_dataconnector = __commonJS({
  "node_modules/@jupyterlab/statedb/lib/dataconnector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DataConnector = void 0;
    var DataConnector = class {
      /**
       * Retrieve the list of items available from the data connector.
       *
       * @param query - The optional query filter to apply to the connector request.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can list.
       */
      async list(query) {
        throw new Error("DataConnector#list method has not been implemented.");
      }
      /**
       * Remove a value using the data connector.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can remove.
       */
      async remove(id) {
        throw new Error("DataConnector#remove method has not been implemented.");
      }
      /**
       * Save a value using the data connector.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that always rejects with an error.
       *
       * #### Notes
       * Subclasses should reimplement if they support a back-end that can save.
       */
      async save(id, value) {
        throw new Error("DataConnector#save method has not been implemented.");
      }
    };
    exports2.DataConnector = DataConnector;
  }
});

// node_modules/@jupyterlab/statedb/lib/interfaces.js
var require_interfaces2 = __commonJS({
  "node_modules/@jupyterlab/statedb/lib/interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@lumino/properties/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@lumino/properties/dist/index.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.lumino_properties = {}));
    })(exports2, function(exports3) {
      "use strict";
      class AttachedProperty {
        /**
         * Construct a new attached property.
         *
         * @param options - The options for initializing the property.
         */
        constructor(options) {
          this._pid = Private.nextPID();
          this.name = options.name;
          this._create = options.create;
          this._coerce = options.coerce || null;
          this._compare = options.compare || null;
          this._changed = options.changed || null;
        }
        /**
         * Get the current value of the property for a given owner.
         *
         * @param owner - The property owner of interest.
         *
         * @returns The current value of the property.
         *
         * #### Notes
         * If the value has not yet been set, the default value will be
         * computed and assigned as the current value of the property.
         */
        get(owner) {
          let value;
          let map = Private.ensureMap(owner);
          if (this._pid in map) {
            value = map[this._pid];
          } else {
            value = map[this._pid] = this._createValue(owner);
          }
          return value;
        }
        /**
         * Set the current value of the property for a given owner.
         *
         * @param owner - The property owner of interest.
         *
         * @param value - The value for the property.
         *
         * #### Notes
         * If the value has not yet been set, the default value will be
         * computed and used as the previous value for the comparison.
         */
        set(owner, value) {
          let oldValue;
          let map = Private.ensureMap(owner);
          if (this._pid in map) {
            oldValue = map[this._pid];
          } else {
            oldValue = map[this._pid] = this._createValue(owner);
          }
          let newValue = this._coerceValue(owner, value);
          this._maybeNotify(owner, oldValue, map[this._pid] = newValue);
        }
        /**
         * Explicitly coerce the current property value for a given owner.
         *
         * @param owner - The property owner of interest.
         *
         * #### Notes
         * If the value has not yet been set, the default value will be
         * computed and used as the previous value for the comparison.
         */
        coerce(owner) {
          let oldValue;
          let map = Private.ensureMap(owner);
          if (this._pid in map) {
            oldValue = map[this._pid];
          } else {
            oldValue = map[this._pid] = this._createValue(owner);
          }
          let newValue = this._coerceValue(owner, oldValue);
          this._maybeNotify(owner, oldValue, map[this._pid] = newValue);
        }
        /**
         * Get or create the default value for the given owner.
         */
        _createValue(owner) {
          let create = this._create;
          return create(owner);
        }
        /**
         * Coerce the value for the given owner.
         */
        _coerceValue(owner, value) {
          let coerce = this._coerce;
          return coerce ? coerce(owner, value) : value;
        }
        /**
         * Compare the old value and new value for equality.
         */
        _compareValue(oldValue, newValue) {
          let compare = this._compare;
          return compare ? compare(oldValue, newValue) : oldValue === newValue;
        }
        /**
         * Run the change notification if the given values are different.
         */
        _maybeNotify(owner, oldValue, newValue) {
          let changed = this._changed;
          if (changed && !this._compareValue(oldValue, newValue)) {
            changed(owner, oldValue, newValue);
          }
        }
      }
      (function(AttachedProperty2) {
        function clearData(owner) {
          Private.ownerData.delete(owner);
        }
        AttachedProperty2.clearData = clearData;
      })(AttachedProperty || (AttachedProperty = {}));
      var Private;
      (function(Private2) {
        Private2.ownerData = /* @__PURE__ */ new WeakMap();
        Private2.nextPID = (() => {
          let id = 0;
          return () => {
            let rand = Math.random();
            let stem = `${rand}`.slice(2);
            return `pid-${stem}-${id++}`;
          };
        })();
        function ensureMap(owner) {
          let map = Private2.ownerData.get(owner);
          if (map) {
            return map;
          }
          map = /* @__PURE__ */ Object.create(null);
          Private2.ownerData.set(owner, map);
          return map;
        }
        Private2.ensureMap = ensureMap;
      })(Private || (Private = {}));
      exports3.AttachedProperty = AttachedProperty;
    });
  }
});

// node_modules/@jupyterlab/statedb/lib/restorablepool.js
var require_restorablepool = __commonJS({
  "node_modules/@jupyterlab/statedb/lib/restorablepool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestorablePool = void 0;
    var coreutils_12 = require_index_node();
    var properties_1 = require_dist5();
    var signaling_1 = require_dist2();
    var RestorablePool = class {
      /**
       * Create a new restorable pool.
       *
       * @param options - The instantiation options for a restorable pool.
       */
      constructor(options) {
        this._added = new signaling_1.Signal(this);
        this._current = null;
        this._currentChanged = new signaling_1.Signal(this);
        this._hasRestored = false;
        this._isDisposed = false;
        this._objects = /* @__PURE__ */ new Set();
        this._restore = null;
        this._restored = new coreutils_12.PromiseDelegate();
        this._updated = new signaling_1.Signal(this);
        this.namespace = options.namespace;
      }
      /**
       * A signal emitted when an object object is added.
       *
       * #### Notes
       * This signal will only fire when an object is added to the pool.
       * It will not fire if an object injected into the pool.
       */
      get added() {
        return this._added;
      }
      /**
       * The current object.
       *
       * #### Notes
       * The restorable pool does not set `current`. It is intended for client use.
       *
       * If `current` is set to an object that does not exist in the pool, it is a
       * no-op.
       */
      get current() {
        return this._current;
      }
      set current(obj) {
        if (this._current === obj) {
          return;
        }
        if (obj !== null && this._objects.has(obj)) {
          this._current = obj;
          this._currentChanged.emit(this._current);
        }
      }
      /**
       * A signal emitted when the current widget changes.
       */
      get currentChanged() {
        return this._currentChanged;
      }
      /**
       * Test whether the pool is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * A promise resolved when the restorable pool has been restored.
       */
      get restored() {
        return this._restored.promise;
      }
      /**
       * The number of objects held by the pool.
       */
      get size() {
        return this._objects.size;
      }
      /**
       * A signal emitted when an object is updated.
       */
      get updated() {
        return this._updated;
      }
      /**
       * Add a new object to the pool.
       *
       * @param obj - The object object being added.
       *
       * #### Notes
       * The object passed into the pool is added synchronously; its existence in
       * the pool can be checked with the `has()` method. The promise this method
       * returns resolves after the object has been added and saved to an underlying
       * restoration connector, if one is available.
       */
      async add(obj) {
        var _a, _b;
        if (obj.isDisposed) {
          const warning = "A disposed object cannot be added.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        if (this._objects.has(obj)) {
          const warning = "This object already exists in the pool.";
          console.warn(warning, obj);
          throw new Error(warning);
        }
        this._objects.add(obj);
        obj.disposed.connect(this._onInstanceDisposed, this);
        if (Private.injectedProperty.get(obj)) {
          return;
        }
        if (this._restore) {
          const { connector } = this._restore;
          const objName = this._restore.name(obj);
          if (objName) {
            const name2 = `${this.namespace}:${objName}`;
            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
            Private.nameProperty.set(obj, name2);
            await connector.save(name2, { data });
          }
        }
        this._added.emit(obj);
      }
      /**
       * Dispose of the resources held by the pool.
       *
       * #### Notes
       * Disposing a pool does not affect the underlying data in the data connector,
       * it simply disposes the client-side pool without making any connector calls.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._current = null;
        this._isDisposed = true;
        this._objects.clear();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Find the first object in the pool that satisfies a filter function.
       *
       * @param fn The filter function to call on each object.
       */
      find(fn) {
        const values = this._objects.values();
        for (const value of values) {
          if (fn(value)) {
            return value;
          }
        }
        return void 0;
      }
      /**
       * Iterate through each object in the pool.
       *
       * @param fn - The function to call on each object.
       */
      forEach(fn) {
        this._objects.forEach(fn);
      }
      /**
       * Filter the objects in the pool based on a predicate.
       *
       * @param fn - The function by which to filter.
       */
      filter(fn) {
        const filtered = [];
        this.forEach((obj) => {
          if (fn(obj)) {
            filtered.push(obj);
          }
        });
        return filtered;
      }
      /**
       * Inject an object into the restorable pool without the pool handling its
       * restoration lifecycle.
       *
       * @param obj - The object to inject into the pool.
       */
      inject(obj) {
        Private.injectedProperty.set(obj, true);
        return this.add(obj);
      }
      /**
       * Check if this pool has the specified object.
       *
       * @param obj - The object whose existence is being checked.
       */
      has(obj) {
        return this._objects.has(obj);
      }
      /**
       * Restore the objects in this pool's namespace.
       *
       * @param options - The configuration options that describe restoration.
       *
       * @returns A promise that resolves when restoration has completed.
       *
       * #### Notes
       * This function should almost never be invoked by client code. Its primary
       * use case is to be invoked by a layout restorer plugin that handles
       * multiple restorable pools and, when ready, asks them each to restore their
       * respective objects.
       */
      async restore(options) {
        if (this._hasRestored) {
          throw new Error("This pool has already been restored.");
        }
        this._hasRestored = true;
        const { command, connector, registry, when } = options;
        const namespace = this.namespace;
        const promises = when ? [connector.list(namespace)].concat(when) : [connector.list(namespace)];
        this._restore = options;
        const [saved] = await Promise.all(promises);
        const values = await Promise.all(saved.ids.map(async (id, index) => {
          const value = saved.values[index];
          const args = value && value.data;
          if (args === void 0) {
            return connector.remove(id);
          }
          return registry.execute(command, args).catch(() => connector.remove(id));
        }));
        this._restored.resolve();
        return values;
      }
      /**
       * Save the restore data for a given object.
       *
       * @param obj - The object being saved.
       */
      async save(obj) {
        var _a, _b;
        const injected = Private.injectedProperty.get(obj);
        if (!this._restore || !this.has(obj) || injected) {
          return;
        }
        const { connector } = this._restore;
        const objName = this._restore.name(obj);
        const oldName = Private.nameProperty.get(obj);
        const newName = objName ? `${this.namespace}:${objName}` : "";
        if (oldName && oldName !== newName) {
          await connector.remove(oldName);
        }
        Private.nameProperty.set(obj, newName);
        if (newName) {
          const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);
          await connector.save(newName, { data });
        }
        if (oldName !== newName) {
          this._updated.emit(obj);
        }
      }
      /**
       * Clean up after disposed objects.
       */
      _onInstanceDisposed(obj) {
        this._objects.delete(obj);
        if (obj === this._current) {
          this._current = null;
          this._currentChanged.emit(this._current);
        }
        if (Private.injectedProperty.get(obj)) {
          return;
        }
        if (!this._restore) {
          return;
        }
        const { connector } = this._restore;
        const name2 = Private.nameProperty.get(obj);
        if (name2) {
          void connector.remove(name2);
        }
      }
    };
    exports2.RestorablePool = RestorablePool;
    var Private;
    (function(Private2) {
      Private2.injectedProperty = new properties_1.AttachedProperty({
        name: "injected",
        create: () => false
      });
      Private2.nameProperty = new properties_1.AttachedProperty({
        name: "name",
        create: () => ""
      });
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/statedb/lib/statedb.js
var require_statedb = __commonJS({
  "node_modules/@jupyterlab/statedb/lib/statedb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StateDB = void 0;
    var signaling_1 = require_dist2();
    var StateDB = class _StateDB {
      /**
       * Create a new state database.
       *
       * @param options - The instantiation options for a state database.
       */
      constructor(options = {}) {
        this._changed = new signaling_1.Signal(this);
        const { connector, transform } = options;
        this._connector = connector || new _StateDB.Connector();
        if (!transform) {
          this._ready = Promise.resolve(void 0);
        } else {
          this._ready = transform.then((transformation) => {
            const { contents, type } = transformation;
            switch (type) {
              case "cancel":
                return;
              case "clear":
                return this._clear();
              case "merge":
                return this._merge(contents || {});
              case "overwrite":
                return this._overwrite(contents || {});
              default:
                return;
            }
          });
        }
      }
      /**
       * A signal that emits the change type any time a value changes.
       */
      get changed() {
        return this._changed;
      }
      /**
       * Clear the entire database.
       */
      async clear() {
        await this._ready;
        await this._clear();
      }
      /**
       * Retrieve a saved bundle from the database.
       *
       * @param id - The identifier used to retrieve a data bundle.
       *
       * @returns A promise that bears a data payload if available.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       *
       * The promise returned by this method may be rejected if an error occurs in
       * retrieving the data. Non-existence of an `id` will succeed with the `value`
       * `undefined`.
       */
      async fetch(id) {
        await this._ready;
        return this._fetch(id);
      }
      /**
       * Retrieve all the saved bundles for a namespace.
       *
       * @param namespace The namespace prefix to retrieve.
       *
       * @returns A promise that bears a collection of payloads for a namespace.
       *
       * #### Notes
       * Namespaces are entirely conventional entities. The `id` values of stored
       * items in the state database are formatted: `'namespace:identifier'`, which
       * is the same convention that command identifiers in JupyterLab use as well.
       *
       * If there are any errors in retrieving the data, they will be logged to the
       * console in order to optimistically return any extant data without failing.
       * This promise will always succeed.
       */
      async list(namespace) {
        await this._ready;
        return this._list(namespace);
      }
      /**
       * Remove a value from the database.
       *
       * @param id - The identifier for the data being removed.
       *
       * @returns A promise that is rejected if remove fails and succeeds otherwise.
       */
      async remove(id) {
        await this._ready;
        await this._remove(id);
        this._changed.emit({ id, type: "remove" });
      }
      /**
       * Save a value in the database.
       *
       * @param id - The identifier for the data being saved.
       *
       * @param value - The data being saved.
       *
       * @returns A promise that is rejected if saving fails and succeeds otherwise.
       *
       * #### Notes
       * The `id` values of stored items in the state database are formatted:
       * `'namespace:identifier'`, which is the same convention that command
       * identifiers in JupyterLab use as well. While this is not a technical
       * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for
       * using the `list(namespace: string)` method.
       */
      async save(id, value) {
        await this._ready;
        await this._save(id, value);
        this._changed.emit({ id, type: "save" });
      }
      /**
       * Return a serialized copy of the state database's entire contents.
       *
       * @returns A promise that resolves with the database contents as JSON.
       */
      async toJSON() {
        await this._ready;
        const { ids, values } = await this._list();
        return values.reduce((acc, val, idx) => {
          acc[ids[idx]] = val;
          return acc;
        }, {});
      }
      /**
       * Clear the entire database.
       */
      async _clear() {
        await Promise.all((await this._list()).ids.map((id) => this._remove(id)));
      }
      /**
       * Fetch a value from the database.
       */
      async _fetch(id) {
        const value = await this._connector.fetch(id);
        if (value) {
          return JSON.parse(value).v;
        }
      }
      /**
       * Fetch a list from the database.
       */
      async _list(namespace = "") {
        const { ids, values } = await this._connector.list(namespace);
        return {
          ids,
          values: values.map((val) => JSON.parse(val).v)
        };
      }
      /**
       * Merge data into the state database.
       */
      async _merge(contents) {
        await Promise.all(Object.keys(contents).map((key) => contents[key] && this._save(key, contents[key])));
      }
      /**
       * Overwrite the entire database with new contents.
       */
      async _overwrite(contents) {
        await this._clear();
        await this._merge(contents);
      }
      /**
       * Remove a key in the database.
       */
      async _remove(id) {
        return this._connector.remove(id);
      }
      /**
       * Save a key and its value in the database.
       */
      async _save(id, value) {
        return this._connector.save(id, JSON.stringify({ v: value }));
      }
    };
    exports2.StateDB = StateDB;
    (function(StateDB2) {
      class Connector {
        constructor() {
          this._storage = {};
        }
        /**
         * Retrieve an item from the data connector.
         */
        async fetch(id) {
          return this._storage[id];
        }
        /**
         * Retrieve the list of items available from the data connector.
         *
         * @param namespace - If not empty, only keys whose first token before `:`
         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.
         */
        async list(namespace = "") {
          return Object.keys(this._storage).reduce((acc, val) => {
            if (namespace === "" ? true : namespace === val.split(":")[0]) {
              acc.ids.push(val);
              acc.values.push(this._storage[val]);
            }
            return acc;
          }, { ids: [], values: [] });
        }
        /**
         * Remove a value using the data connector.
         */
        async remove(id) {
          delete this._storage[id];
        }
        /**
         * Save a value using the data connector.
         */
        async save(id, value) {
          this._storage[id] = value;
        }
      }
      StateDB2.Connector = Connector;
    })(StateDB || (exports2.StateDB = StateDB = {}));
  }
});

// node_modules/@jupyterlab/statedb/lib/tokens.js
var require_tokens = __commonJS({
  "node_modules/@jupyterlab/statedb/lib/tokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IStateDB = void 0;
    var coreutils_12 = require_index_node();
    exports2.IStateDB = new coreutils_12.Token("@jupyterlab/coreutils:IStateDB", `A service for the JupyterLab state database.
  Use this if you want to store data that will persist across page loads.
  See "state database" for more information.`);
  }
});

// node_modules/@jupyterlab/statedb/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@jupyterlab/statedb/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_dataconnector(), exports2);
    __exportStar(require_interfaces2(), exports2);
    __exportStar(require_restorablepool(), exports2);
    __exportStar(require_statedb(), exports2);
    __exportStar(require_tokens(), exports2);
  }
});

// node_modules/@jupyterlab/services/lib/setting/index.js
var require_setting = __commonJS({
  "node_modules/@jupyterlab/services/lib/setting/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SettingManager = void 0;
    var coreutils_12 = require_lib();
    var statedb_1 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_SETTINGS_URL = "api/settings";
    var SettingManager = class extends statedb_1.DataConnector {
      /**
       * Create a new setting manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        if (!id) {
          throw new Error("Plugin `id` parameter is required for settings fetch.");
        }
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of all plugin setting bundles.
       *
       * @returns A promise that resolves if successful.
       */
      async list(query) {
        var _a, _b, _c, _d;
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, "", query === "ids");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          throw new ResponseError(response);
        }
        const json = await response.json();
        const ids = (_b = (_a = json === null || json === void 0 ? void 0 : json["settings"]) === null || _a === void 0 ? void 0 : _a.map((plugin) => plugin.id)) !== null && _b !== void 0 ? _b : [];
        let values = [];
        if (!query) {
          values = (_d = (_c = json === null || json === void 0 ? void 0 : json["settings"]) === null || _c === void 0 ? void 0 : _c.map((plugin) => {
            plugin.data = { composite: {}, user: {} };
            return plugin;
          })) !== null && _d !== void 0 ? _d : [];
        }
        return { ids, values };
      }
      /**
       * Save a plugin's settings.
       *
       * @param id - The plugin's ID.
       *
       * @param raw - The user setting values as a raw string of JSON with comments.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, raw) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, id);
        const init = { body: JSON.stringify({ raw }), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          throw new ResponseError(response);
        }
      }
    };
    exports2.SettingManager = SettingManager;
    var Private;
    (function(Private2) {
      function url(base, id, idsOnly) {
        const idsOnlyParam = idsOnly ? coreutils_12.URLExt.objectToQueryString({ ids_only: true }) : "";
        const settingsBase = coreutils_12.URLExt.join(base, SERVICE_SETTINGS_URL);
        const result = coreutils_12.URLExt.join(settingsBase, id);
        if (!result.startsWith(settingsBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return `${result}${idsOnlyParam}`;
      }
      Private2.url = url;
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/terminal/restapi.js
var require_restapi4 = __commonJS({
  "node_modules/@jupyterlab/services/lib/terminal/restapi.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shutdownTerminal = exports2.listRunning = exports2.startNew = exports2.isAvailable = exports2.TERMINAL_SERVICE_URL = void 0;
    var coreutils_12 = require_lib();
    var serverconnection_1 = require_serverconnection();
    exports2.TERMINAL_SERVICE_URL = "api/terminals";
    function isAvailable() {
      const available = String(coreutils_12.PageConfig.getOption("terminalsAvailable"));
      return available.toLowerCase() === "true";
    }
    exports2.isAvailable = isAvailable;
    async function startNew(settings = serverconnection_1.ServerConnection.makeSettings(), name2, cwd) {
      Private.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const init = {
        method: "POST",
        body: JSON.stringify({ name: name2, cwd })
      };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      return data;
    }
    exports2.startNew = startNew;
    async function listRunning(settings = serverconnection_1.ServerConnection.makeSettings()) {
      Private.errorIfNotAvailable();
      const url = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const response = await serverconnection_1.ServerConnection.makeRequest(url, {}, settings);
      if (response.status !== 200) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error("Invalid terminal list");
      }
      return data;
    }
    exports2.listRunning = listRunning;
    async function shutdownTerminal(name2, settings = serverconnection_1.ServerConnection.makeSettings()) {
      var _a;
      Private.errorIfNotAvailable();
      const workspacesBase = coreutils_12.URLExt.join(settings.baseUrl, exports2.TERMINAL_SERVICE_URL);
      const url = coreutils_12.URLExt.join(workspacesBase, name2);
      if (!url.startsWith(workspacesBase)) {
        throw new Error("Can only be used for terminal requests");
      }
      const init = { method: "DELETE" };
      const response = await serverconnection_1.ServerConnection.makeRequest(url, init, settings);
      if (response.status === 404) {
        const data = await response.json();
        const msg = (_a = data.message) !== null && _a !== void 0 ? _a : `The terminal session "${name2}"" does not exist on the server`;
        console.warn(msg);
      } else if (response.status !== 204) {
        const err = await serverconnection_1.ServerConnection.ResponseError.create(response);
        throw err;
      }
    }
    exports2.shutdownTerminal = shutdownTerminal;
    var Private;
    (function(Private2) {
      function errorIfNotAvailable() {
        if (!isAvailable()) {
          throw new Error("Terminals Unavailable");
        }
      }
      Private2.errorIfNotAvailable = errorIfNotAvailable;
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/terminal/terminal.js
var require_terminal = __commonJS({
  "node_modules/@jupyterlab/services/lib/terminal/terminal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAvailable = void 0;
    var restapi_1 = require_restapi4();
    Object.defineProperty(exports2, "isAvailable", { enumerable: true, get: function() {
      return restapi_1.isAvailable;
    } });
  }
});

// node_modules/@jupyterlab/services/lib/terminal/default.js
var require_default3 = __commonJS({
  "node_modules/@jupyterlab/services/lib/terminal/default.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalConnection = void 0;
    var coreutils_12 = require_lib();
    var coreutils_2 = require_index_node();
    var signaling_1 = require_dist2();
    var __1 = require_lib3();
    var restapi_1 = require_restapi4();
    var TerminalConnection = class _TerminalConnection {
      /**
       * Construct a new terminal session.
       */
      constructor(options) {
        var _a;
        this._createSocket = () => {
          this._errorIfDisposed();
          this._clearSocket();
          this._updateConnectionStatus("connecting");
          const name2 = this._name;
          const settings = this.serverSettings;
          let url = coreutils_12.URLExt.join(settings.wsUrl, "terminals", "websocket", encodeURIComponent(name2));
          const token = settings.token;
          if (settings.appendToken && token !== "") {
            url = url + `?token=${encodeURIComponent(token)}`;
          }
          this._ws = new settings.WebSocket(url);
          this._ws.onmessage = this._onWSMessage;
          this._ws.onclose = this._onWSClose;
          this._ws.onerror = this._onWSClose;
        };
        this._onWSMessage = (event) => {
          if (this._isDisposed) {
            return;
          }
          const data = JSON.parse(event.data);
          if (data[0] === "disconnect") {
            this.dispose();
          }
          if (this._connectionStatus === "connecting") {
            if (data[0] === "setup") {
              this._updateConnectionStatus("connected");
            }
            return;
          }
          this._messageReceived.emit({
            type: data[0],
            content: data.slice(1)
          });
        };
        this._onWSClose = (event) => {
          console.warn(`Terminal websocket closed: ${event.code}`);
          if (!this.isDisposed) {
            this._reconnect();
          }
        };
        this._connectionStatus = "connecting";
        this._connectionStatusChanged = new signaling_1.Signal(this);
        this._isDisposed = false;
        this._disposed = new signaling_1.Signal(this);
        this._messageReceived = new signaling_1.Signal(this);
        this._reconnectTimeout = null;
        this._ws = null;
        this._noOp = () => {
        };
        this._reconnectLimit = 7;
        this._reconnectAttempt = 0;
        this._pendingMessages = [];
        this._name = options.model.name;
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : __1.ServerConnection.makeSettings();
        this._createSocket();
      }
      /**
       * A signal emitted when the session is disposed.
       */
      get disposed() {
        return this._disposed;
      }
      /**
       * A signal emitted when a message is received from the server.
       */
      get messageReceived() {
        return this._messageReceived;
      }
      /**
       * Get the name of the terminal session.
       */
      get name() {
        return this._name;
      }
      /**
       * Get the model for the terminal session.
       */
      get model() {
        return { name: this._name };
      }
      /**
       * Test whether the session is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources held by the session.
       */
      dispose() {
        if (this._isDisposed) {
          return;
        }
        this._isDisposed = true;
        this._disposed.emit();
        this._updateConnectionStatus("disconnected");
        this._clearSocket();
        signaling_1.Signal.clearData(this);
      }
      /**
       * Send a message to the terminal session.
       *
       * #### Notes
       * If the connection is down, the message will be queued for sending when
       * the connection comes back up.
       */
      send(message) {
        this._sendMessage(message);
      }
      /**
       * Send a message on the websocket, or possibly queue for later sending.
       *
       * @param queue - whether to queue the message if it cannot be sent
       */
      _sendMessage(message, queue = true) {
        if (this._isDisposed || !message.content) {
          return;
        }
        if (this.connectionStatus === "connected" && this._ws) {
          const msg = [message.type, ...message.content];
          this._ws.send(JSON.stringify(msg));
        } else if (queue) {
          this._pendingMessages.push(message);
        } else {
          throw new Error(`Could not send message: ${JSON.stringify(message)}`);
        }
      }
      /**
       * Send pending messages to the kernel.
       */
      _sendPending() {
        while (this.connectionStatus === "connected" && this._pendingMessages.length > 0) {
          this._sendMessage(this._pendingMessages[0], false);
          this._pendingMessages.shift();
        }
      }
      /**
       * Reconnect to a terminal.
       *
       * #### Notes
       * This may try multiple times to reconnect to a terminal, and will sever
       * any existing connection.
       */
      reconnect() {
        this._errorIfDisposed();
        const result = new coreutils_2.PromiseDelegate();
        const fulfill = (sender, status) => {
          if (status === "connected") {
            result.resolve();
            this.connectionStatusChanged.disconnect(fulfill, this);
          } else if (status === "disconnected") {
            result.reject(new Error("Terminal connection disconnected"));
            this.connectionStatusChanged.disconnect(fulfill, this);
          }
        };
        this.connectionStatusChanged.connect(fulfill, this);
        this._reconnectAttempt = 0;
        this._reconnect();
        return result.promise;
      }
      /**
       * Attempt a connection if we have not exhausted connection attempts.
       */
      _reconnect() {
        this._errorIfDisposed();
        clearTimeout(this._reconnectTimeout);
        if (this._reconnectAttempt < this._reconnectLimit) {
          this._updateConnectionStatus("connecting");
          const timeout = Private.getRandomIntInclusive(0, 1e3 * (Math.pow(2, this._reconnectAttempt) - 1));
          console.error(`Connection lost, reconnecting in ${Math.floor(timeout / 1e3)} seconds.`);
          this._reconnectTimeout = setTimeout(this._createSocket, timeout);
          this._reconnectAttempt += 1;
        } else {
          this._updateConnectionStatus("disconnected");
        }
        this._clearSocket();
      }
      /**
       * Forcefully clear the socket state.
       *
       * #### Notes
       * This will clear all socket state without calling any handlers and will
       * not update the connection status. If you call this method, you are
       * responsible for updating the connection status as needed and recreating
       * the socket if you plan to reconnect.
       */
      _clearSocket() {
        if (this._ws !== null) {
          this._ws.onopen = this._noOp;
          this._ws.onclose = this._noOp;
          this._ws.onerror = this._noOp;
          this._ws.onmessage = this._noOp;
          this._ws.close();
          this._ws = null;
        }
      }
      /**
       * Shut down the terminal session.
       */
      async shutdown() {
        await (0, restapi_1.shutdownTerminal)(this.name, this.serverSettings);
        this.dispose();
      }
      /**
       * Clone the current terminal connection.
       */
      clone() {
        return new _TerminalConnection(this);
      }
      /**
       * Handle connection status changes.
       */
      _updateConnectionStatus(connectionStatus) {
        if (this._connectionStatus === connectionStatus) {
          return;
        }
        this._connectionStatus = connectionStatus;
        if (connectionStatus !== "connecting") {
          this._reconnectAttempt = 0;
          clearTimeout(this._reconnectTimeout);
        }
        if (connectionStatus === "connected") {
          this._sendPending();
        }
        this._connectionStatusChanged.emit(connectionStatus);
      }
      /**
       * Utility function to throw an error if this instance is disposed.
       */
      _errorIfDisposed() {
        if (this.isDisposed) {
          throw new Error("Terminal connection is disposed");
        }
      }
      /**
       * A signal emitted when the terminal connection status changes.
       */
      get connectionStatusChanged() {
        return this._connectionStatusChanged;
      }
      /**
       * The current connection status of the terminal connection.
       */
      get connectionStatus() {
        return this._connectionStatus;
      }
    };
    exports2.TerminalConnection = TerminalConnection;
    var Private;
    (function(Private2) {
      function getTermUrl(baseUrl, name2) {
        return coreutils_12.URLExt.join(baseUrl, restapi_1.TERMINAL_SERVICE_URL, encodeURIComponent(name2));
      }
      Private2.getTermUrl = getTermUrl;
      function getRandomIntInclusive(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }
      Private2.getRandomIntInclusive = getRandomIntInclusive;
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/terminal/manager.js
var require_manager4 = __commonJS({
  "node_modules/@jupyterlab/services/lib/terminal/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalManager = void 0;
    var polling_1 = require_dist3();
    var signaling_1 = require_dist2();
    var __1 = require_lib3();
    var basemanager_1 = require_basemanager();
    var restapi_1 = require_restapi4();
    var default_1 = require_default3();
    var TerminalManager = class extends basemanager_1.BaseManager {
      /**
       * Construct a new terminal manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._names = [];
        this._terminalConnections = /* @__PURE__ */ new Set();
        this._runningChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        if (!this.isAvailable()) {
          this._ready = Promise.reject("Terminals unavailable");
          this._ready.catch((_) => void 0);
          return;
        }
        this._pollModels = new polling_1.Poll({
          auto: false,
          factory: () => this.requestRunning(),
          frequency: {
            interval: 10 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: `@jupyterlab/services:TerminalManager#models`,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        this._ready = (async () => {
          await this._pollModels.start();
          await this._pollModels.tick;
          this._isReady = true;
        })();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * A signal emitted when the running terminals change.
       */
      get runningChanged() {
        return this._runningChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._names.length = 0;
        this._terminalConnections.forEach((x) => x.dispose());
        this._pollModels.dispose();
        super.dispose();
      }
      /**
       * Whether the terminal service is available.
       */
      isAvailable() {
        return (0, restapi_1.isAvailable)();
      }
      /*
       * Connect to a running terminal.
       *
       * @param options - The options used to connect to the terminal.
       *
       * @returns The new terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used.
       */
      connectTo(options) {
        const terminalConnection = new default_1.TerminalConnection({
          ...options,
          serverSettings: this.serverSettings
        });
        this._onStarted(terminalConnection);
        if (!this._names.includes(options.model.name)) {
          void this.refreshRunning().catch(() => {
          });
        }
        return terminalConnection;
      }
      /**
       * Create an iterator over the most recent running terminals.
       *
       * @returns A new iterator over the running terminals.
       */
      running() {
        return this._models[Symbol.iterator]();
      }
      /**
       * Force a refresh of the running terminals.
       *
       * @returns A promise that with the list of running terminals.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshRunning() {
        await this._pollModels.refresh();
        await this._pollModels.tick;
      }
      /**
       * Create a new terminal session.
       *
       * @param options - The options used to create the terminal.
       *
       * @returns A promise that resolves with the terminal connection instance.
       *
       * #### Notes
       * The manager `serverSettings` will be used unless overridden in the
       * options.
       */
      async startNew(options) {
        const model = await (0, restapi_1.startNew)(this.serverSettings, options === null || options === void 0 ? void 0 : options.name, options === null || options === void 0 ? void 0 : options.cwd);
        await this.refreshRunning();
        return this.connectTo({ model });
      }
      /**
       * Shut down a terminal session by name.
       */
      async shutdown(name2) {
        await (0, restapi_1.shutdownTerminal)(name2, this.serverSettings);
        await this.refreshRunning();
      }
      /**
       * Shut down all terminal sessions.
       *
       * @returns A promise that resolves when all of the sessions are shut down.
       */
      async shutdownAll() {
        await this.refreshRunning();
        await Promise.all(this._names.map((name2) => (0, restapi_1.shutdownTerminal)(name2, this.serverSettings)));
        await this.refreshRunning();
      }
      /**
       * Execute a request to the server to poll running terminals and update state.
       */
      async requestRunning() {
        var _a, _b;
        let models;
        try {
          models = await (0, restapi_1.listRunning)(this.serverSettings);
        } catch (err) {
          if (err instanceof __1.ServerConnection.NetworkError || ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) === 503 || ((_b = err.response) === null || _b === void 0 ? void 0 : _b.status) === 424) {
            this._connectionFailure.emit(err);
          }
          throw err;
        }
        if (this.isDisposed) {
          return;
        }
        const names = models.map(({ name: name2 }) => name2).sort();
        if (names === this._names) {
          return;
        }
        this._names = names;
        this._terminalConnections.forEach((tc) => {
          if (!names.includes(tc.name)) {
            tc.dispose();
          }
        });
        this._runningChanged.emit(this._models);
      }
      /**
       * Handle a session starting.
       */
      _onStarted(terminalConnection) {
        this._terminalConnections.add(terminalConnection);
        terminalConnection.disposed.connect(this._onDisposed, this);
      }
      /**
       * Handle a session terminating.
       */
      _onDisposed(terminalConnection) {
        this._terminalConnections.delete(terminalConnection);
        void this.refreshRunning().catch(() => {
        });
      }
      get _models() {
        return this._names.map((name2) => {
          return { name: name2 };
        });
      }
    };
    exports2.TerminalManager = TerminalManager;
    (function(TerminalManager2) {
      class NoopManager extends TerminalManager2 {
        constructor() {
          super(...arguments);
          this._readyPromise = new Promise(() => {
          });
        }
        /**
         * Whether the manager is active.
         */
        get isActive() {
          return false;
        }
        /**
         * Used for testing.
         */
        get parentReady() {
          return super.ready;
        }
        /**
         * A promise that fulfills when the manager is ready (never).
         */
        get ready() {
          return this.parentReady.then(() => this._readyPromise);
        }
        /**
         * Create a new terminal session - throw an error since it is not supported.
         *
         */
        async startNew(options) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /*
         * Connect to a running terminal - throw an error since it is not supported.
         */
        connectTo(options) {
          throw Error("Not implemented in no-op Terminal Manager");
        }
        /**
         * Shut down a session by id - throw an error since it is not supported.
         */
        async shutdown(id) {
          return Promise.reject(new Error("Not implemented in no-op Terminal Manager"));
        }
        /**
         * Execute a request to the server to poll running sessions and update state.
         */
        async requestRunning() {
          return Promise.resolve();
        }
      }
      TerminalManager2.NoopManager = NoopManager;
    })(TerminalManager || (exports2.TerminalManager = TerminalManager = {}));
  }
});

// node_modules/@jupyterlab/services/lib/terminal/index.js
var require_terminal2 = __commonJS({
  "node_modules/@jupyterlab/services/lib/terminal/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TerminalAPI = exports2.Terminal = void 0;
    var Terminal = __importStar(require_terminal());
    exports2.Terminal = Terminal;
    var TerminalAPI = __importStar(require_restapi4());
    exports2.TerminalAPI = TerminalAPI;
    __exportStar(require_manager4(), exports2);
  }
});

// node_modules/@jupyterlab/services/lib/user/index.js
var require_user = __commonJS({
  "node_modules/@jupyterlab/services/lib/user/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UserManager = void 0;
    var coreutils_12 = require_lib();
    var coreutils_2 = require_index_node();
    var polling_1 = require_dist3();
    var signaling_1 = require_dist2();
    var serverconnection_1 = require_serverconnection();
    var basemanager_1 = require_basemanager();
    var SERVICE_USER_URL = "api/me";
    var SERVICE_ID = "@jupyterlab/services:UserManager#user";
    var UserManager = class extends basemanager_1.BaseManager {
      /**
       * Create a new user manager.
       */
      constructor(options = {}) {
        var _a;
        super(options);
        this._isReady = false;
        this._userChanged = new signaling_1.Signal(this);
        this._connectionFailure = new signaling_1.Signal(this);
        this._ready = this.requestUser().then(() => {
          if (this.isDisposed) {
            return;
          }
          this._isReady = true;
        }).catch((_) => (
          // Return a promise that will never resolve, so user service is never ready
          // This typically occurs when the backend has no user service
          new Promise(() => {
          })
        ));
        this._pollSpecs = new polling_1.Poll({
          auto: false,
          factory: () => this.requestUser(),
          frequency: {
            interval: 61 * 1e3,
            backoff: true,
            max: 300 * 1e3
          },
          name: SERVICE_ID,
          standby: (_a = options.standby) !== null && _a !== void 0 ? _a : "when-hidden"
        });
        void this.ready.then(() => {
          void this._pollSpecs.start();
        });
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._ready;
      }
      /**
       * Get the most recently fetched identity.
       */
      get identity() {
        return this._identity;
      }
      /**
       * Get the most recently fetched permissions.
       */
      get permissions() {
        return this._permissions;
      }
      /**
       * A signal emitted when the user changes.
       */
      get userChanged() {
        return this._userChanged;
      }
      /**
       * A signal emitted when there is a connection failure.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        this._pollSpecs.dispose();
        super.dispose();
      }
      /**
       * Force a refresh of the specs from the server.
       *
       * @returns A promise that resolves when the specs are fetched.
       *
       * #### Notes
       * This is intended to be called only in response to a user action,
       * since the manager maintains its internal state.
       */
      async refreshUser() {
        await this._pollSpecs.refresh();
        await this._pollSpecs.tick;
      }
      /**
       * Execute a request to the server to poll the user and update state.
       */
      async requestUser() {
        if (this.isDisposed) {
          return;
        }
        const { baseUrl } = this.serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const url = coreutils_12.URLExt.join(baseUrl, SERVICE_USER_URL);
        const response = await makeRequest(url, {}, this.serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const oldUser = {
          identity: this._identity,
          permissions: this._permissions
        };
        const newUser = await response.json();
        const identity = newUser.identity;
        const { localStorage: localStorage2 } = window;
        const data = localStorage2.getItem(SERVICE_ID);
        if (data && (!identity.initials || !identity.color)) {
          const localUser = JSON.parse(data);
          identity.initials = identity.initials || localUser.initials || identity.name.substring(0, 1);
          identity.color = identity.color || localUser.color || Private.getRandomColor();
        }
        if (!coreutils_2.JSONExt.deepEqual(newUser, oldUser)) {
          this._identity = identity;
          this._permissions = newUser.permissions;
          localStorage2.setItem(SERVICE_ID, JSON.stringify(identity));
          this._userChanged.emit(newUser);
        }
      }
    };
    exports2.UserManager = UserManager;
    var Private;
    (function(Private2) {
      const userColors = [
        "var(--jp-collaborator-color1)",
        "var(--jp-collaborator-color2)",
        "var(--jp-collaborator-color3)",
        "var(--jp-collaborator-color4)",
        "var(--jp-collaborator-color5)",
        "var(--jp-collaborator-color6)",
        "var(--jp-collaborator-color7)"
      ];
      Private2.getRandomColor = () => userColors[Math.floor(Math.random() * userColors.length)];
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/workspace/index.js
var require_workspace = __commonJS({
  "node_modules/@jupyterlab/services/lib/workspace/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceManager = void 0;
    var coreutils_12 = require_lib();
    var statedb_1 = require_lib2();
    var serverconnection_1 = require_serverconnection();
    var SERVICE_WORKSPACES_URL = "api/workspaces";
    var WorkspaceManager = class extends statedb_1.DataConnector {
      /**
       * Create a new workspace manager.
       */
      constructor(options = {}) {
        var _a;
        super();
        this.serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
      }
      /**
       * Fetch a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async fetch(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, id);
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        return response.json();
      }
      /**
       * Fetch the list of workspace IDs that exist on the server.
       *
       * @returns A promise that resolves if successful.
       */
      async list() {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, "");
        const response = await makeRequest(url, {}, serverSettings);
        if (response.status !== 200) {
          const err = await ResponseError.create(response);
          throw err;
        }
        const result = await response.json();
        return result.workspaces;
      }
      /**
       * Remove a workspace from the server.
       *
       * @param id - The workspaces's ID.
       *
       * @returns A promise that resolves if successful.
       */
      async remove(id) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, id);
        const init = { method: "DELETE" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
      /**
       * Save a workspace.
       *
       * @param id - The workspace's ID.
       *
       * @param workspace - The workspace being saved.
       *
       * @returns A promise that resolves if successful.
       */
      async save(id, workspace5) {
        const { serverSettings } = this;
        const { baseUrl, appUrl } = serverSettings;
        const { makeRequest, ResponseError } = serverconnection_1.ServerConnection;
        const base = baseUrl + appUrl;
        const url = Private.url(base, id);
        const init = { body: JSON.stringify(workspace5), method: "PUT" };
        const response = await makeRequest(url, init, serverSettings);
        if (response.status !== 204) {
          const err = await ResponseError.create(response);
          throw err;
        }
      }
    };
    exports2.WorkspaceManager = WorkspaceManager;
    var Private;
    (function(Private2) {
      function url(base, id) {
        const workspacesBase = coreutils_12.URLExt.join(base, SERVICE_WORKSPACES_URL);
        const result = coreutils_12.URLExt.join(workspacesBase, id);
        if (!result.startsWith(workspacesBase)) {
          throw new Error("Can only be used for workspaces requests");
        }
        return result;
      }
      Private2.url = url;
    })(Private || (Private = {}));
  }
});

// node_modules/@jupyterlab/services/lib/manager.js
var require_manager5 = __commonJS({
  "node_modules/@jupyterlab/services/lib/manager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServiceManager = void 0;
    var signaling_1 = require_dist2();
    var builder_1 = require_builder();
    var contents_1 = require_contents();
    var event_1 = require_event();
    var kernel_1 = require_kernel2();
    var kernelspec_1 = require_kernelspec2();
    var nbconvert_1 = require_nbconvert();
    var serverconnection_1 = require_serverconnection();
    var session_1 = require_session2();
    var setting_1 = require_setting();
    var terminal_1 = require_terminal2();
    var user_1 = require_user();
    var workspace_1 = require_workspace();
    var ServiceManager = class {
      /**
       * Construct a new services provider.
       */
      constructor(options = {}) {
        var _a, _b;
        this._isDisposed = false;
        this._connectionFailure = new signaling_1.Signal(this);
        this._isReady = false;
        const defaultDrive = options.defaultDrive;
        const serverSettings = (_a = options.serverSettings) !== null && _a !== void 0 ? _a : serverconnection_1.ServerConnection.makeSettings();
        const standby = (_b = options.standby) !== null && _b !== void 0 ? _b : "when-hidden";
        const normalized = { defaultDrive, serverSettings, standby };
        this.serverSettings = serverSettings;
        this.contents = options.contents || new contents_1.ContentsManager(normalized);
        this.events = options.events || new event_1.EventManager(normalized);
        this.kernels = options.kernels || new kernel_1.KernelManager(normalized);
        this.sessions = options.sessions || new session_1.SessionManager({
          ...normalized,
          kernelManager: this.kernels
        });
        this.settings = options.settings || new setting_1.SettingManager(normalized);
        this.terminals = options.terminals || new terminal_1.TerminalManager(normalized);
        this.builder = options.builder || new builder_1.BuildManager(normalized);
        this.workspaces = options.workspaces || new workspace_1.WorkspaceManager(normalized);
        this.nbconvert = options.nbconvert || new nbconvert_1.NbConvertManager(normalized);
        this.kernelspecs = options.kernelspecs || new kernelspec_1.KernelSpecManager(normalized);
        this.user = options.user || new user_1.UserManager(normalized);
        this.kernelspecs.connectionFailure.connect(this._onConnectionFailure, this);
        this.sessions.connectionFailure.connect(this._onConnectionFailure, this);
        this.terminals.connectionFailure.connect(this._onConnectionFailure, this);
        const readyList = [this.sessions.ready, this.kernelspecs.ready];
        if (this.terminals.isAvailable()) {
          readyList.push(this.terminals.ready);
        }
        this._readyPromise = Promise.all(readyList).then(() => {
          this._isReady = true;
        });
      }
      /**
       * A signal emitted when there is a connection failure with the kernel.
       */
      get connectionFailure() {
        return this._connectionFailure;
      }
      /**
       * Test whether the service manager is disposed.
       */
      get isDisposed() {
        return this._isDisposed;
      }
      /**
       * Dispose of the resources used by the manager.
       */
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this._isDisposed = true;
        signaling_1.Signal.clearData(this);
        this.contents.dispose();
        this.events.dispose();
        this.sessions.dispose();
        this.terminals.dispose();
      }
      /**
       * Test whether the manager is ready.
       */
      get isReady() {
        return this._isReady;
      }
      /**
       * A promise that fulfills when the manager is ready.
       */
      get ready() {
        return this._readyPromise;
      }
      _onConnectionFailure(sender, err) {
        this._connectionFailure.emit(err);
      }
    };
    exports2.ServiceManager = ServiceManager;
  }
});

// node_modules/@jupyterlab/services/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@jupyterlab/services/lib/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_basemanager(), exports2);
    __exportStar(require_config(), exports2);
    __exportStar(require_contents(), exports2);
    __exportStar(require_event(), exports2);
    __exportStar(require_kernel2(), exports2);
    __exportStar(require_kernelspec2(), exports2);
    __exportStar(require_manager5(), exports2);
    __exportStar(require_serverconnection(), exports2);
    __exportStar(require_session2(), exports2);
    __exportStar(require_setting(), exports2);
    __exportStar(require_terminal2(), exports2);
    __exportStar(require_user(), exports2);
    __exportStar(require_workspace(), exports2);
    __exportStar(require_nbconvert(), exports2);
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetryReporter.js
var require_baseTelemetryReporter = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetryReporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseTelemetryReporter = void 0;
    var BaseTelemetryReporter = class {
      constructor(telemetrySender, vscodeAPI, initializationOptions) {
        this.telemetrySender = telemetrySender;
        this.vscodeAPI = vscodeAPI;
        this.userOptIn = false;
        this.errorOptIn = false;
        this.disposables = [];
        this._onDidChangeTelemetryLevel = new this.vscodeAPI.EventEmitter();
        this.onDidChangeTelemetryLevel = this._onDidChangeTelemetryLevel.event;
        this.telemetryLogger = this.vscodeAPI.env.createTelemetryLogger(this.telemetrySender, initializationOptions);
        this.updateUserOptIn();
        this.telemetryLogger.onDidChangeEnableStates(() => {
          this.updateUserOptIn();
        });
      }
      /**
       * Updates the user's telemetry opt-in status
       */
      updateUserOptIn() {
        this.errorOptIn = this.telemetryLogger.isErrorsEnabled;
        this.userOptIn = this.telemetryLogger.isUsageEnabled;
        if (this.telemetryLogger.isErrorsEnabled || this.telemetryLogger.isUsageEnabled) {
          this.telemetrySender.instantiateSender();
        }
        this._onDidChangeTelemetryLevel.fire(this.telemetryLevel);
      }
      get telemetryLevel() {
        if (this.errorOptIn && this.userOptIn) {
          return "all";
        } else if (this.errorOptIn) {
          return "error";
        } else {
          return "off";
        }
      }
      /**
       * Internal function which logs telemetry events and takes extra options.
       * @param eventName The name of the event
       * @param properties The properties of the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures
       * @param dangerous Whether or not to ignore telemetry level
       */
      internalSendTelemetryEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
          this.telemetrySender.sendEventData(eventName, { properties, measurements });
        } else {
          this.telemetryLogger.logUsage(eventName, { properties, measurements });
        }
      }
      /**
       * Given an event name, some properties, and measurements sends a telemetry event.
       * Properties are sanitized on best-effort basis to remove sensitive data prior to sending.
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       */
      sendTelemetryEvent(eventName, properties, measurements) {
        this.internalSendTelemetryEvent(eventName, properties, measurements, false);
      }
      /**
       * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry event without checking telemetry setting
       * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures, defaults to true
       */
      sendDangerousTelemetryEvent(eventName, properties, measurements) {
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryEvent(eventName, properties, measurements, true);
      }
      /**
       * Internal function which logs telemetry error events and takes extra options.
       * @param eventName The name of the event
       * @param properties The properties of the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures
       * @param dangerous Whether or not to ignore telemetry level
       */
      internalSendTelemetryErrorEvent(eventName, properties, measurements, dangerous) {
        if (dangerous) {
          this.telemetrySender.sendEventData(eventName, { properties, measurements });
        } else {
          this.telemetryLogger.logError(eventName, { properties, measurements });
        }
      }
      /**
       * Given an event name, some properties, and measurements sends an error event
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       */
      sendTelemetryErrorEvent(eventName, properties, measurements) {
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, false);
      }
      /**
       * **DANGEROUS** Given an event name, some properties, and measurements sends a telemetry error event without checking telemetry setting
       * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to run the properties and measures through sanitiziation, defaults to true
       */
      sendDangerousTelemetryErrorEvent(eventName, properties, measurements) {
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryErrorEvent(eventName, properties, measurements, true);
      }
      /**
       * Internal function which logs telemetry exceptions and takes extra options
       * @param error: The error to send
       * @param properties The properties of the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures
       * @param dangerous Whether or not to ignore telemetry level
       */
      internalSendTelemetryException(error, properties, measurements, dangerous) {
        if (dangerous) {
          this.telemetrySender.sendErrorData(error, { properties, measurements });
        } else {
          this.telemetryLogger.logError(error, { properties, measurements });
        }
      }
      /**
       * Given an error, properties, and measurements. Sends an exception event
       * @param error The error to send
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       */
      sendTelemetryException(error, properties, measurements) {
        this.internalSendTelemetryException(error, properties, measurements, false);
      }
      /**
       * **DANGEROUS** Given an error, properties, and measurements. Sends an exception event without checking the telemetry setting
       * Do not use unless in a controlled environment i.e. sending telmetry from a CI pipeline or testing during development
       * @param eventName The name of the event
       * @param properties The properties to send with the event
       * @param measurements The measurements (numeric values) to send with the event
       * @param sanitize Whether or not to sanitize to the properties and measures, defaults to true
       */
      sendDangerousTelemetryException(error, properties, measurements) {
        this.telemetrySender.instantiateSender();
        this.internalSendTelemetryException(error, properties, measurements, true);
      }
      /**
       * Disposes of the telemetry reporter
       */
      dispose() {
        this.telemetryLogger.dispose();
        return Promise.all(this.disposables.map((d) => d.dispose()));
      }
    };
    exports2.BaseTelemetryReporter = BaseTelemetryReporter;
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetrySender.js
var require_baseTelemetrySender = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/baseTelemetrySender.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseTelemetrySender = void 0;
    var InstantiationStatus;
    (function(InstantiationStatus2) {
      InstantiationStatus2[InstantiationStatus2["NOT_INSTANTIATED"] = 0] = "NOT_INSTANTIATED";
      InstantiationStatus2[InstantiationStatus2["INSTANTIATING"] = 1] = "INSTANTIATING";
      InstantiationStatus2[InstantiationStatus2["INSTANTIATED"] = 2] = "INSTANTIATED";
    })(InstantiationStatus || (InstantiationStatus = {}));
    var BaseTelemetrySender = class {
      constructor(key, clientFactory) {
        this._instantiationStatus = InstantiationStatus.NOT_INSTANTIATED;
        this._eventQueue = [];
        this._exceptionQueue = [];
        this._clientFactory = clientFactory;
        this._key = key;
      }
      /**
       * Sends the event to the passed in telemetry client
       * The sender does no telemetry level checks as those are done by the reporter.
       * @param eventName The name of the event to log
       * @param data The data contanied in the event
       */
      sendEventData(eventName, data) {
        if (!this._telemetryClient) {
          if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
            this._eventQueue.push({ eventName, data });
          }
          return;
        }
        this._telemetryClient.logEvent(eventName, data);
      }
      /**
       * Sends an exception to the passed in telemetry client
       * The sender does no telemetry level checks as those are done by the reporter.
       * @param exception The exception to collect
       * @param data Data associated with the exception
       */
      sendErrorData(exception, data) {
        if (!this._telemetryClient) {
          if (this._instantiationStatus !== InstantiationStatus.INSTANTIATED) {
            this._exceptionQueue.push({ exception, data });
          }
          return;
        }
      }
      /**
       * Flushes the buffered telemetry data
       */
      async flush() {
        if (this._telemetryClient) {
          await this._telemetryClient.flush();
          this._telemetryClient = void 0;
        }
        return;
      }
      /**
       * Flushes the queued events that existed before the client was instantiated
       */
      _flushQueues() {
        this._eventQueue.forEach(({ eventName, data }) => this.sendEventData(eventName, data));
        this._eventQueue = [];
        this._exceptionQueue.forEach(({ exception, data }) => this.sendErrorData(exception, data));
        this._exceptionQueue = [];
      }
      /**
       * Instantiates the telemetry client to make the sender "active"
       */
      instantiateSender() {
        if (this._instantiationStatus !== InstantiationStatus.NOT_INSTANTIATED) {
          return;
        }
        this._instantiationStatus = InstantiationStatus.INSTANTIATING;
        this._clientFactory(this._key).then((client) => {
          this._telemetryClient = client;
          this._instantiationStatus = InstantiationStatus.INSTANTIATED;
          this._flushQueues();
        }).catch((err) => {
          console.error(err);
          this._instantiationStatus = InstantiationStatus.INSTANTIATED;
        });
      }
    };
    exports2.BaseTelemetrySender = BaseTelemetrySender;
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/util.js
var require_util = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetryUtil = void 0;
    var TelemetryUtil = class _TelemetryUtil {
      static applyReplacements(data, replacementOptions) {
        for (const key of Object.keys(data)) {
          for (const option of replacementOptions) {
            if (option.lookup.test(key)) {
              if (option.replacementString !== void 0) {
                data[key] = option.replacementString;
              } else {
                delete data[key];
              }
            }
          }
        }
      }
      /**
       * Given a key checks if it is a valid 1DS key
       * @param key The key to check if it's a valid 1DS key
       */
      static shouldUseOneDataSystemSDK(key) {
        return key.length === 74 && key[32] === "-" && key[41] === "-" && key[46] === "-" && key[51] === "-" && key[56] === "-" && key[69] === "-";
      }
      // This also includes the common properties which core mixes in
      // __GDPR__COMMON__ "common.os" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.nodeArch" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.platformversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.extname" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.extversion" : { "classification": "PublicNonPersonalData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodemachineid" : { "endPoint": "MacAddressHash", "classification": "EndUserPseudonymizedInformation", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodesessionid" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.vscodeversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.uikind" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.remotename" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.isnewappinstall" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.product" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      // __GDPR__COMMON__ "common.telemetryclientversion" : { "classification": "SystemMetaData", "purpose": "FeatureInsight" }
      static getAdditionalCommonProperties(osShim) {
        return {
          "common.os": osShim.platform,
          "common.nodeArch": osShim.architecture,
          "common.platformversion": (osShim.release || "").replace(/^(\d+)(\.\d+)?(\.\d+)?(.*)/, "$1$2$3"),
          // Do not change this string as it gets found and replaced upon packaging
          "common.telemetryclientversion": "0.7.7"
        };
      }
      // Get singleton instance of TelemetryUtil
      static getInstance() {
        if (!_TelemetryUtil._instance) {
          _TelemetryUtil._instance = new _TelemetryUtil();
        }
        return _TelemetryUtil._instance;
      }
    };
    exports2.TelemetryUtil = TelemetryUtil;
  }
});

// node_modules/@microsoft/applicationinsights-shims/dist/umd/applicationinsights-shims.js
var require_applicationinsights_shims = __commonJS({
  "node_modules/@microsoft/applicationinsights-shims/dist/umd/applicationinsights-shims.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.Microsoft = global2.Microsoft || {}, global2.Microsoft.ApplicationInsights = global2.Microsoft.ApplicationInsights || {}, global2.Microsoft.ApplicationInsights.Shims = {})));
    })(exports2, function(exports3) {
      "use strict";
      var strShimFunction = "function";
      var strShimObject = "object";
      var strShimUndefined = "undefined";
      var strShimPrototype = "prototype";
      var strShimHasOwnProperty = "hasOwnProperty";
      var strDefault = "default";
      var ObjClass = Object;
      var ObjProto = ObjClass[strShimPrototype];
      var ObjAssign = ObjClass["assign"];
      var ObjCreate = ObjClass["create"];
      var ObjDefineProperty = ObjClass["defineProperty"];
      var ObjHasOwnProperty = ObjProto[strShimHasOwnProperty];
      var _cachedGlobal = null;
      function getGlobal(useCached) {
        if (useCached === void 0) {
          useCached = true;
        }
        var result = useCached === false ? null : _cachedGlobal;
        if (!result) {
          if (typeof globalThis !== strShimUndefined) {
            result = globalThis;
          }
          if (!result && typeof self !== strShimUndefined) {
            result = self;
          }
          if (!result && typeof window !== strShimUndefined) {
            result = window;
          }
          if (!result && typeof global !== strShimUndefined) {
            result = global;
          }
          _cachedGlobal = result;
        }
        return result;
      }
      function throwTypeError(message) {
        throw new TypeError(message);
      }
      function objCreateFn(obj) {
        var func = ObjCreate;
        if (func) {
          return func(obj);
        }
        if (obj == null) {
          return {};
        }
        var type = typeof obj;
        if (type !== strShimObject && type !== strShimFunction) {
          throwTypeError("Object prototype may only be an Object:" + obj);
        }
        function tmpFunc() {
        }
        tmpFunc[strShimPrototype] = obj;
        return new tmpFunc();
      }
      var SymbolObj = (getGlobal() || {})["Symbol"];
      var ReflectObj = (getGlobal() || {})["Reflect"];
      var __hasReflect = !!ReflectObj;
      var strDecorate = "decorate";
      var strMetadata = "metadata";
      var strGetOwnPropertySymbols = "getOwnPropertySymbols";
      var strIterator = "iterator";
      var __objAssignFnImpl = function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) {
            if (ObjProto[strShimHasOwnProperty].call(s, p)) {
              t[p] = s[p];
            }
          }
        }
        return t;
      };
      var __assignFn = ObjAssign || __objAssignFnImpl;
      var extendStaticsFn = function(d, b) {
        extendStaticsFn = ObjClass["setPrototypeOf"] || // tslint:disable-next-line: only-arrow-functions
        { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || // tslint:disable-next-line: only-arrow-functions
        function(d2, b2) {
          for (var p in b2) {
            if (b2[strShimHasOwnProperty](p)) {
              d2[p] = b2[p];
            }
          }
        };
        return extendStaticsFn(d, b);
      };
      function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
          throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
          this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreateFn(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
      }
      function __restFn(s, e) {
        var t = {};
        for (var k in s) {
          if (ObjHasOwnProperty.call(s, k) && e.indexOf(k) < 0) {
            t[k] = s[k];
          }
        }
        if (s != null && typeof ObjClass[strGetOwnPropertySymbols] === strShimFunction) {
          for (var i = 0, p = ObjClass[strGetOwnPropertySymbols](s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && ObjProto["propertyIsEnumerable"].call(s, p[i])) {
              t[p[i]] = s[p[i]];
            }
          }
        }
        return t;
      }
      function __decorateFn(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = ObjClass["getOwnPropertyDescriptor"](target, key) : desc, d;
        if (__hasReflect && typeof ReflectObj[strDecorate] === strShimFunction) {
          r = ReflectObj[strDecorate](decorators, target, key, desc);
        } else {
          for (var i = decorators.length - 1; i >= 0; i--) {
            if (d = decorators[i]) {
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
            }
          }
        }
        return c > 3 && r && ObjDefineProperty(target, key, r), r;
      }
      function __paramFn(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      }
      function __metadataFn(metadataKey, metadataValue) {
        if (__hasReflect && ReflectObj[strMetadata] === strShimFunction) {
          return ReflectObj[strMetadata](metadataKey, metadataValue);
        }
      }
      function __exportStarFn(m, o) {
        for (var p in m) {
          if (p !== strDefault && !ObjHasOwnProperty.call(o, p)) {
            __createBindingFn(o, m, p);
          }
        }
      }
      function __createBindingFn(o, m, k, k2) {
        if (k2 === void 0) {
          k2 = k;
        }
        if (!!ObjCreate) {
          ObjDefineProperty(o, k2, {
            enumerable: true,
            get: function() {
              return m[k];
            }
          });
        } else {
          o[k2] = m[k];
        }
      }
      function __valuesFn(o) {
        var s = typeof SymbolObj === strShimFunction && SymbolObj[strIterator], m = s && o[s], i = 0;
        if (m) {
          return m.call(o);
        }
        if (o && typeof o.length === "number") {
          return {
            next: function() {
              if (o && i >= o.length) {
                o = void 0;
              }
              return { value: o && o[i++], done: !o };
            }
          };
        }
        throwTypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function __readFn(o, n) {
        var m = typeof SymbolObj === strShimFunction && o[SymbolObj[strIterator]];
        if (!m) {
          return o;
        }
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
            ar.push(r.value);
          }
        } catch (error) {
          e = {
            error
          };
        } finally {
          try {
            if (r && !r.done && (m = i["return"])) {
              m.call(i);
            }
          } finally {
            if (e) {
              throw e.error;
            }
          }
        }
        return ar;
      }
      function __spreadArraysFn() {
        var theArgs = arguments;
        for (var s = 0, i = 0, il = theArgs.length; i < il; i++) {
          s += theArgs[i].length;
        }
        for (var r = Array(s), k = 0, i = 0; i < il; i++) {
          for (var a = theArgs[i], j = 0, jl = a.length; j < jl; j++, k++) {
            r[k] = a[j];
          }
        }
        return r;
      }
      function __spreadArrayFn(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
          to[j] = from[i];
        }
        return to;
      }
      function __makeTemplateObjectFn(cooked, raw) {
        if (ObjDefineProperty) {
          ObjDefineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      }
      function __importStarFn(mod) {
        if (mod && mod.__esModule) {
          return mod;
        }
        var result = {};
        if (mod != null) {
          for (var k in mod) {
            if (k !== strDefault && Object.prototype.hasOwnProperty.call(mod, k)) {
              __createBindingFn(result, mod, k);
            }
          }
        }
        if (!!ObjCreate) {
          ObjDefineProperty(result, strDefault, { enumerable: true, value: mod });
        } else {
          result[strDefault] = mod;
        }
        return result;
      }
      function __importDefaultFn(mod) {
        return mod && mod.__esModule ? mod : { strDefault: mod };
      }
      function __exposeGlobalTsLib() {
        var globalObj = getGlobal() || {};
        (function(root, assignFn, extendsFn, createBindingFn) {
          if (!root.__assign) {
            root.__assign = ObjAssign || assignFn;
          }
          if (!root.__extends) {
            root.__extends = extendsFn;
          }
          if (!root.__createBinding) {
            root.__createBinding = createBindingFn;
          }
        })(globalObj, __assignFn, __extendsFn, __createBindingFn);
        if (!__assign) {
          __assign = globalObj.__assign;
        }
        if (!__extends) {
          __extends = globalObj.__extends;
        }
        if (!__createBinding) {
          __createBinding = globalObj.__createBinding;
        }
      }
      exports3.ObjAssign = ObjAssign;
      exports3.ObjClass = ObjClass;
      exports3.ObjCreate = ObjCreate;
      exports3.ObjDefineProperty = ObjDefineProperty;
      exports3.ObjHasOwnProperty = ObjHasOwnProperty;
      exports3.ObjProto = ObjProto;
      exports3.__assignFn = __assignFn;
      exports3.__createBindingFn = __createBindingFn;
      exports3.__decorateFn = __decorateFn;
      exports3.__exportStarFn = __exportStarFn;
      exports3.__exposeGlobalTsLib = __exposeGlobalTsLib;
      exports3.__extendsFn = __extendsFn;
      exports3.__importDefaultFn = __importDefaultFn;
      exports3.__importStarFn = __importStarFn;
      exports3.__makeTemplateObjectFn = __makeTemplateObjectFn;
      exports3.__metadataFn = __metadataFn;
      exports3.__paramFn = __paramFn;
      exports3.__readFn = __readFn;
      exports3.__restFn = __restFn;
      exports3.__spreadArrayFn = __spreadArrayFn;
      exports3.__spreadArraysFn = __spreadArraysFn;
      exports3.__valuesFn = __valuesFn;
      exports3.getGlobal = getGlobal;
      exports3.objCreateFn = objCreateFn;
      exports3.strDefault = strDefault;
      exports3.strShimFunction = strShimFunction;
      exports3.strShimHasOwnProperty = strShimHasOwnProperty;
      exports3.strShimObject = strShimObject;
      exports3.strShimPrototype = strShimPrototype;
      exports3.strShimUndefined = strShimUndefined;
      exports3.throwTypeError = throwTypeError;
      (function(obj, prop, descriptor) {
        var func = Object["defineProperty"];
        if (func) {
          try {
            return func(obj, prop, descriptor);
          } catch (e) {
          }
        }
        if (descriptor && typeof descriptor.value !== void 0) {
          obj[prop] = descriptor.value;
        }
        return obj;
      })(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@microsoft/applicationinsights-core-js/dist/applicationinsights-core-js.js
var require_applicationinsights_core_js = __commonJS({
  "node_modules/@microsoft/applicationinsights-core-js/dist/applicationinsights-core-js.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.Microsoft = global2.Microsoft || {}, global2.Microsoft.ApplicationInsights = global2.Microsoft.ApplicationInsights || {})));
    })(exports2, function(exports3) {
      "use strict";
      var MinChannelPriorty = 100;
      var strShimFunction = "function";
      var strShimObject = "object";
      var strShimUndefined = "undefined";
      var strShimPrototype = "prototype";
      var strShimHasOwnProperty = "hasOwnProperty";
      var ObjClass = Object;
      var ObjProto = ObjClass[strShimPrototype];
      var ObjAssign = ObjClass["assign"];
      var ObjCreate = ObjClass["create"];
      var ObjDefineProperty = ObjClass["defineProperty"];
      var ObjHasOwnProperty = ObjProto[strShimHasOwnProperty];
      var _cachedGlobal = null;
      function getGlobal(useCached) {
        if (useCached === void 0) {
          useCached = true;
        }
        var result = useCached === false ? null : _cachedGlobal;
        if (!result) {
          if (typeof globalThis !== strShimUndefined) {
            result = globalThis;
          }
          if (!result && typeof self !== strShimUndefined) {
            result = self;
          }
          if (!result && typeof window !== strShimUndefined) {
            result = window;
          }
          if (!result && typeof global !== strShimUndefined) {
            result = global;
          }
          _cachedGlobal = result;
        }
        return result;
      }
      function throwTypeError(message) {
        throw new TypeError(message);
      }
      function objCreateFn(obj) {
        var func = ObjCreate;
        if (func) {
          return func(obj);
        }
        if (obj == null) {
          return {};
        }
        var type = typeof obj;
        if (type !== strShimObject && type !== strShimFunction) {
          throwTypeError("Object prototype may only be an Object:" + obj);
        }
        function tmpFunc() {
        }
        tmpFunc[strShimPrototype] = obj;
        return new tmpFunc();
      }
      (getGlobal() || {})["Symbol"];
      (getGlobal() || {})["Reflect"];
      var extendStaticsFn = function(d, b) {
        extendStaticsFn = ObjClass["setPrototypeOf"] || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (b2[strShimHasOwnProperty](p)) {
              d2[p] = b2[p];
            }
          }
        };
        return extendStaticsFn(d, b);
      };
      function __extendsFn(d, b) {
        if (typeof b !== strShimFunction && b !== null) {
          throwTypeError("Class extends value " + String(b) + " is not a constructor or null");
        }
        extendStaticsFn(d, b);
        function __() {
          this.constructor = d;
        }
        d[strShimPrototype] = b === null ? objCreateFn(b) : (__[strShimPrototype] = b[strShimPrototype], new __());
      }
      function __spreadArrayFn(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
          to[j] = from[i];
        }
        return to;
      }
      var _DYN_INITIALIZE = "initialize";
      var _DYN_NAME = "name";
      var _DYN_GET_NOTIFY_MGR = "getNotifyMgr";
      var _DYN_IDENTIFIER = "identifier";
      var _DYN_PUSH = "push";
      var _DYN_IS_INITIALIZED = "isInitialized";
      var _DYN_CONFIG = "config";
      var _DYN_INSTRUMENTATION_KEY = "instrumentationKey";
      var _DYN_LOGGER = "logger";
      var _DYN_LENGTH = "length";
      var _DYN_TIME = "time";
      var _DYN_PROCESS_NEXT = "processNext";
      var _DYN_GET_PROCESS_TEL_CONT0 = "getProcessTelContext";
      var _DYN_ADD_NOTIFICATION_LIS1 = "addNotificationListener";
      var _DYN_REMOVE_NOTIFICATION_2 = "removeNotificationListener";
      var _DYN_STOP_POLLING_INTERNA3 = "stopPollingInternalLogs";
      var _DYN_ON_COMPLETE = "onComplete";
      var _DYN_GET_PLUGIN = "getPlugin";
      var _DYN_FLUSH = "flush";
      var _DYN__EXTENSIONS = "_extensions";
      var _DYN_SPLICE = "splice";
      var _DYN_TEARDOWN = "teardown";
      var _DYN_MESSAGE_ID = "messageId";
      var _DYN_MESSAGE = "message";
      var _DYN_IS_ASYNC = "isAsync";
      var _DYN__DO_TEARDOWN = "_doTeardown";
      var _DYN_UPDATE = "update";
      var _DYN_GET_NEXT = "getNext";
      var _DYN_DIAG_LOG = "diagLog";
      var _DYN_SET_NEXT_PLUGIN = "setNextPlugin";
      var _DYN_CREATE_NEW = "createNew";
      var _DYN_COOKIE_CFG = "cookieCfg";
      var _DYN_INDEX_OF = "indexOf";
      var _DYN_SUBSTRING = "substring";
      var _DYN_USER_AGENT = "userAgent";
      var _DYN_SPLIT = "split";
      var _DYN_SET_ENABLED = "setEnabled";
      var _DYN_SUBSTR = "substr";
      var _DYN_NODE_TYPE = "nodeType";
      var _DYN_APPLY = "apply";
      var _DYN_REPLACE = "replace";
      var _DYN_ENABLE_DEBUG_EXCEPTI4 = "enableDebugExceptions";
      var _DYN_LOG_INTERNAL_MESSAGE = "logInternalMessage";
      var _DYN_TO_LOWER_CASE = "toLowerCase";
      var _DYN_CALL = "call";
      var _DYN_TYPE = "type";
      var _DYN_HANDLER = "handler";
      var _DYN_LISTENERS = "listeners";
      var _DYN_IS_CHILD_EVT = "isChildEvt";
      var _DYN_GET_CTX = "getCtx";
      var _DYN_SET_CTX = "setCtx";
      var _DYN_COMPLETE = "complete";
      var _DYN_TRACE_ID = "traceId";
      var _DYN_SPAN_ID = "spanId";
      var _DYN_TRACE_FLAGS = "traceFlags";
      var _DYN_VERSION = "version";
      var STR_EMPTY = "";
      var STR_CHANNELS = "channels";
      var STR_CORE = "core";
      var STR_CREATE_PERF_MGR = "createPerfMgr";
      var STR_DISABLED = "disabled";
      var STR_EXTENSION_CONFIG = "extensionConfig";
      var STR_EXTENSIONS = "extensions";
      var STR_PROCESS_TELEMETRY = "processTelemetry";
      var STR_PRIORITY = "priority";
      var STR_EVENTS_SENT = "eventsSent";
      var STR_EVENTS_DISCARDED = "eventsDiscarded";
      var STR_EVENTS_SEND_REQUEST = "eventsSendRequest";
      var STR_PERF_EVENT = "perfEvent";
      var STR_ERROR_TO_CONSOLE = "errorToConsole";
      var STR_WARN_TO_CONSOLE = "warnToConsole";
      var STR_GET_PERF_MGR = "getPerfMgr";
      var strToISOString = "toISOString";
      var cStrEndsWith = "endsWith";
      var cStrStartsWith = "startsWith";
      var strIndexOf = "indexOf";
      var strMap = "map";
      var strReduce = "reduce";
      var cStrTrim = "trim";
      var strToString = "toString";
      var str__Proto$1 = "__proto__";
      var strConstructor = "constructor";
      var _objDefineProperty$1 = ObjDefineProperty;
      var _objFreeze = ObjClass.freeze;
      var _objSeal = ObjClass.seal;
      var _objKeys = ObjClass.keys;
      var StringProto = String[strShimPrototype];
      var _strTrim = StringProto[cStrTrim];
      var _strEndsWith = StringProto[cStrEndsWith];
      var _strStartsWith = StringProto[cStrStartsWith];
      var DateProto = Date[strShimPrototype];
      var _dataToISOString = DateProto[strToISOString];
      var _isArray = Array.isArray;
      var _objToString = ObjProto[strToString];
      var _fnToString = ObjHasOwnProperty[strToString];
      var _objFunctionString = _fnToString[_DYN_CALL](ObjClass);
      var rCamelCase = /-([a-z])/g;
      var rNormalizeInvalid = /([^\w\d_$])/g;
      var rLeadingNumeric = /^(\d+[\w\d_$])/;
      var _objGetPrototypeOf$1 = Object["getPrototypeOf"];
      function _getObjProto$1(target) {
        if (target) {
          if (_objGetPrototypeOf$1) {
            return _objGetPrototypeOf$1(target);
          }
          var newProto = target[str__Proto$1] || target[strShimPrototype] || target[strConstructor];
          if (newProto) {
            return newProto;
          }
        }
        return null;
      }
      function objToString(obj) {
        return _objToString[_DYN_CALL](obj);
      }
      function isTypeof(value, theType) {
        return typeof value === theType;
      }
      function isUndefined(value) {
        return value === void 0 || typeof value === strShimUndefined;
      }
      function isNotUndefined(value) {
        return !isUndefined(value);
      }
      function isNullOrUndefined(value) {
        return value === null || isUndefined(value);
      }
      function isNotNullOrUndefined(value) {
        return !isNullOrUndefined(value);
      }
      function hasOwnProperty(obj, prop) {
        return !!(obj && ObjHasOwnProperty[_DYN_CALL](obj, prop));
      }
      function isObject(value) {
        return !!(value && typeof value === strShimObject);
      }
      function isFunction(value) {
        return !!(value && typeof value === strShimFunction);
      }
      function normalizeJsName(name2) {
        var value = name2;
        if (value && isString(value)) {
          value = value[_DYN_REPLACE](rCamelCase, function(_all, letter) {
            return letter.toUpperCase();
          });
          value = value[_DYN_REPLACE](rNormalizeInvalid, "_");
          value = value[_DYN_REPLACE](rLeadingNumeric, function(_all, match) {
            return "_" + match;
          });
        }
        return value;
      }
      function objForEachKey(target, callbackfn) {
        if (target) {
          for (var prop in target) {
            if (ObjHasOwnProperty[_DYN_CALL](target, prop)) {
              callbackfn[_DYN_CALL](target, prop, target[prop]);
            }
          }
        }
      }
      function strEndsWith(value, search) {
        var result = false;
        if (value && search && !(result = value === search)) {
          result = _strEndsWith ? value[cStrEndsWith](search) : _strEndsWithPoly(value, search);
        }
        return result;
      }
      function _strEndsWithPoly(value, search) {
        var result = false;
        var searchLen = search ? search[_DYN_LENGTH] : 0;
        var valLen = value ? value[_DYN_LENGTH] : 0;
        if (searchLen && valLen && valLen >= searchLen && !(result = value === search)) {
          var pos = valLen - 1;
          for (var lp = searchLen - 1; lp >= 0; lp--) {
            if (value[pos] != search[lp]) {
              return false;
            }
            pos--;
          }
          result = true;
        }
        return result;
      }
      function strStartsWith(value, checkValue) {
        var result = false;
        if (value && checkValue && !(result = value === checkValue)) {
          result = _strStartsWith ? value[cStrStartsWith](checkValue) : _strStartsWithPoly(value, checkValue);
        }
        return result;
      }
      function _strStartsWithPoly(value, checkValue) {
        var result = false;
        var chkLen = checkValue ? checkValue[_DYN_LENGTH] : 0;
        if (value && chkLen && value[_DYN_LENGTH] >= chkLen && !(result = value === checkValue)) {
          for (var lp = 0; lp < chkLen; lp++) {
            if (value[lp] !== checkValue[lp]) {
              return false;
            }
          }
          result = true;
        }
        return result;
      }
      function strContains(value, search) {
        if (value && search) {
          return value[_DYN_INDEX_OF](search) !== -1;
        }
        return false;
      }
      function isDate(obj) {
        return !!(obj && _objToString[_DYN_CALL](obj) === "[object Date]");
      }
      var isArray = _isArray || _isArrayPoly;
      function _isArrayPoly(obj) {
        return !!(obj && _objToString[_DYN_CALL](obj) === "[object Array]");
      }
      function isError(obj) {
        return !!(obj && _objToString[_DYN_CALL](obj) === "[object Error]");
      }
      function isString(value) {
        return typeof value === "string";
      }
      function isNumber(value) {
        return typeof value === "number";
      }
      function isBoolean(value) {
        return typeof value === "boolean";
      }
      function isSymbol(value) {
        return typeof value === "symbol";
      }
      function isPlainObject(value) {
        var result = false;
        if (value && typeof value === "object") {
          var proto = _objGetPrototypeOf$1 ? _objGetPrototypeOf$1(value) : _getObjProto$1(value);
          if (!proto) {
            result = true;
          } else {
            if (proto[strConstructor] && ObjHasOwnProperty[_DYN_CALL](proto, strConstructor)) {
              proto = proto[strConstructor];
            }
            result = typeof proto === strShimFunction && _fnToString[_DYN_CALL](proto) === _objFunctionString;
          }
        }
        return result;
      }
      function toISOString(date) {
        if (date) {
          return _dataToISOString ? date[strToISOString]() : _toISOStringPoly(date);
        }
      }
      function _toISOStringPoly(date) {
        if (date && date.getUTCFullYear) {
          var pad = function(num) {
            var r = String(num);
            if (r[_DYN_LENGTH] === 1) {
              r = "0" + r;
            }
            return r;
          };
          return date.getUTCFullYear() + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate()) + "T" + pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + "." + String((date.getUTCMilliseconds() / 1e3).toFixed(3)).slice(2, 5) + "Z";
        }
      }
      function arrForEach(arr, callbackfn, thisArg) {
        var len = arr[_DYN_LENGTH];
        try {
          for (var idx = 0; idx < len; idx++) {
            if (idx in arr) {
              if (callbackfn[_DYN_CALL](thisArg || arr, arr[idx], idx, arr) === -1) {
                break;
              }
            }
          }
        } catch (e) {
        }
      }
      function arrIndexOf(arr, searchElement, fromIndex) {
        if (arr) {
          if (arr[strIndexOf]) {
            return arr[strIndexOf](searchElement, fromIndex);
          }
          var len = arr[_DYN_LENGTH];
          var from = fromIndex || 0;
          try {
            for (var lp = Math.max(from >= 0 ? from : len - Math.abs(from), 0); lp < len; lp++) {
              if (lp in arr && arr[lp] === searchElement) {
                return lp;
              }
            }
          } catch (e) {
          }
        }
        return -1;
      }
      function arrMap(arr, callbackfn, thisArg) {
        var results;
        if (arr) {
          if (arr[strMap]) {
            return arr[strMap](callbackfn, thisArg);
          }
          var len = arr[_DYN_LENGTH];
          var _this = thisArg || arr;
          results = new Array(len);
          try {
            for (var lp = 0; lp < len; lp++) {
              if (lp in arr) {
                results[lp] = callbackfn[_DYN_CALL](_this, arr[lp], arr);
              }
            }
          } catch (e) {
          }
        }
        return results;
      }
      function arrReduce(arr, callbackfn, initialValue) {
        var value;
        if (arr) {
          if (arr[strReduce]) {
            return arr[strReduce](callbackfn, initialValue);
          }
          var len = arr[_DYN_LENGTH];
          var lp = 0;
          if (arguments[_DYN_LENGTH] >= 3) {
            value = arguments[2];
          } else {
            while (lp < len && !(lp in arr)) {
              lp++;
            }
            value = arr[lp++];
          }
          while (lp < len) {
            if (lp in arr) {
              value = callbackfn(value, arr[lp], lp, arr);
            }
            lp++;
          }
        }
        return value;
      }
      function strTrim(str) {
        if (str) {
          str = _strTrim && str[cStrTrim] ? str[cStrTrim]() : str[_DYN_REPLACE] ? str[_DYN_REPLACE](/^\s+|(?=\s)\s+$/g, STR_EMPTY) : str;
        }
        return str;
      }
      var _objKeysHasDontEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
      var _objKeysDontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      function objKeys(obj) {
        var objType = typeof obj;
        if (objType !== strShimFunction && (objType !== strShimObject || obj === null)) {
          throwTypeError("objKeys called on non-object");
        }
        if (!_objKeysHasDontEnumBug && _objKeys) {
          return _objKeys(obj);
        }
        var result = [];
        for (var prop in obj) {
          if (obj && ObjHasOwnProperty[_DYN_CALL](obj, prop)) {
            result[_DYN_PUSH](prop);
          }
        }
        if (_objKeysHasDontEnumBug) {
          var dontEnumsLength = _objKeysDontEnums[_DYN_LENGTH];
          for (var lp = 0; lp < dontEnumsLength; lp++) {
            if (obj && ObjHasOwnProperty[_DYN_CALL](obj, _objKeysDontEnums[lp])) {
              result[_DYN_PUSH](_objKeysDontEnums[lp]);
            }
          }
        }
        return result;
      }
      function objDefineAccessors(target, prop, getProp, setProp) {
        if (_objDefineProperty$1) {
          try {
            var descriptor = {
              enumerable: true,
              configurable: true
            };
            if (getProp) {
              descriptor.get = getProp;
            }
            if (setProp) {
              descriptor.set = setProp;
            }
            _objDefineProperty$1(target, prop, descriptor);
            return true;
          } catch (e) {
          }
        }
        return false;
      }
      function _doNothing(value) {
        return value;
      }
      function deepFreeze(obj) {
        if (_objFreeze) {
          objForEachKey(obj, function(name2, value) {
            if (isArray(value) || isObject(value)) {
              _objFreeze(value);
            }
          });
        }
        return objFreeze(obj);
      }
      var objFreeze = _objFreeze || _doNothing;
      var objSeal = _objSeal || _doNothing;
      function dateNow() {
        var dt = Date;
        return dt.now ? dt.now() : new dt().getTime();
      }
      function getExceptionName(object) {
        if (isError(object)) {
          return object[_DYN_NAME];
        }
        return STR_EMPTY;
      }
      function setValue(target, field, value, valChk, srcChk) {
        var theValue = value;
        if (target) {
          theValue = target[field];
          if (theValue !== value && (!srcChk || srcChk(theValue)) && (!valChk || valChk(value))) {
            theValue = value;
            target[field] = theValue;
          }
        }
        return theValue;
      }
      function getSetValue(target, field, defValue) {
        var theValue;
        if (target) {
          theValue = target[field];
          if (!theValue && isNullOrUndefined(theValue)) {
            theValue = !isUndefined(defValue) ? defValue : {};
            target[field] = theValue;
          }
        } else {
          theValue = !isUndefined(defValue) ? defValue : {};
        }
        return theValue;
      }
      function getCfgValue(theValue, defaultValue) {
        return !isNullOrUndefined(theValue) ? theValue : defaultValue;
      }
      function isNotTruthy(value) {
        return !value;
      }
      function isTruthy(value) {
        return !!value;
      }
      function throwError(message) {
        throw new Error(message);
      }
      function _createProxyFunction(source, funcName) {
        var srcFunc = null;
        var src = null;
        if (isFunction(source)) {
          srcFunc = source;
        } else {
          src = source;
        }
        return function() {
          var originalArguments = arguments;
          if (srcFunc) {
            src = srcFunc();
          }
          if (src) {
            return src[funcName][_DYN_APPLY](src, originalArguments);
          }
        };
      }
      function proxyAssign(target, source, chkSet) {
        if (target && source && isObject(target) && isObject(source)) {
          var _loop_1 = function(field2) {
            if (isString(field2)) {
              var value = source[field2];
              if (isFunction(value)) {
                if (!chkSet || chkSet(field2, true, source, target)) {
                  target[field2] = _createProxyFunction(source, field2);
                }
              } else if (!chkSet || chkSet(field2, false, source, target)) {
                if (hasOwnProperty(target, field2)) {
                  delete target[field2];
                }
                if (!objDefineAccessors(target, field2, function() {
                  return source[field2];
                }, function(theValue) {
                  source[field2] = theValue;
                })) {
                  target[field2] = value;
                }
              }
            }
          };
          for (var field in source) {
            _loop_1(field);
          }
        }
        return target;
      }
      function proxyFunctionAs(target, name2, source, theFunc, overwriteTarget) {
        if (target && name2 && source) {
          if (overwriteTarget !== false || isUndefined(target[name2])) {
            target[name2] = _createProxyFunction(source, theFunc);
          }
        }
      }
      function proxyFunctions(target, source, functionsToProxy, overwriteTarget) {
        if (target && source && isObject(target) && isArray(functionsToProxy)) {
          arrForEach(functionsToProxy, function(theFuncName) {
            if (isString(theFuncName)) {
              proxyFunctionAs(target, theFuncName, source, theFuncName, overwriteTarget);
            }
          });
        }
        return target;
      }
      function createClassFromInterface(defaults) {
        return (
          /** @class */
          function() {
            function class_1() {
              var _this_1 = this;
              if (defaults) {
                objForEachKey(defaults, function(field, value) {
                  _this_1[field] = value;
                });
              }
            }
            return class_1;
          }()
        );
      }
      function optimizeObject(theObject) {
        if (theObject && ObjAssign) {
          theObject = ObjClass(ObjAssign({}, theObject));
        }
        return theObject;
      }
      function objExtend(obj1, obj2, obj3, obj4, obj5, obj6) {
        var theArgs = arguments;
        var extended = theArgs[0] || {};
        var argLen = theArgs[_DYN_LENGTH];
        var deep = false;
        var idx = 1;
        if (argLen > 0 && isBoolean(extended)) {
          deep = extended;
          extended = theArgs[idx] || {};
          idx++;
        }
        if (!isObject(extended)) {
          extended = {};
        }
        for (; idx < argLen; idx++) {
          var arg = theArgs[idx];
          var isArgArray = isArray(arg);
          var isArgObj = isObject(arg);
          for (var prop in arg) {
            var propOk = isArgArray && prop in arg || isArgObj && ObjHasOwnProperty[_DYN_CALL](arg, prop);
            if (!propOk) {
              continue;
            }
            var newValue = arg[prop];
            var isNewArray = void 0;
            if (deep && newValue && ((isNewArray = isArray(newValue)) || isPlainObject(newValue))) {
              var clone = extended[prop];
              if (isNewArray) {
                if (!isArray(clone)) {
                  clone = [];
                }
              } else if (!isPlainObject(clone)) {
                clone = {};
              }
              newValue = objExtend(deep, clone, newValue);
            }
            if (newValue !== void 0) {
              extended[prop] = newValue;
            }
          }
        }
        return extended;
      }
      function createEnumStyle(values) {
        var enumClass = {};
        objForEachKey(values, function(field, value) {
          enumClass[field] = value;
          enumClass[value] = field;
        });
        return deepFreeze(enumClass);
      }
      function createEnumMap(values) {
        var mapClass = {};
        objForEachKey(values, function(field, value) {
          mapClass[field] = field;
          mapClass[value] = field;
        });
        return deepFreeze(mapClass);
      }
      function createValueMap(values) {
        var mapClass = {};
        objForEachKey(values, function(field, value) {
          mapClass[field] = value[1];
          mapClass[value[0]] = value[1];
        });
        return deepFreeze(mapClass);
      }
      var EventsDiscardedReason = createEnumStyle({
        Unknown: 0,
        NonRetryableStatus: 1,
        InvalidEvent: 2,
        SizeLimitExceeded: 3,
        KillSwitch: 4,
        QueueFull: 5
      });
      var _a$1;
      var UNDEFINED = "undefined";
      var Constructor = "constructor";
      var Prototype = "prototype";
      var strFunction = "function";
      var DynInstFuncTable = "_dynInstFuncs";
      var DynProxyTag = "_isDynProxy";
      var DynClassName = "_dynClass";
      var DynClassNamePrefix = "_dynCls$";
      var DynInstChkTag = "_dynInstChk";
      var DynAllowInstChkTag = DynInstChkTag;
      var DynProtoDefaultOptions = "_dfOpts";
      var UnknownValue = "_unknown_";
      var str__Proto = "__proto__";
      var DynProtoBaseProto = "_dyn" + str__Proto;
      var DynProtoGlobalSettings = "__dynProto$Gbl";
      var DynProtoCurrent = "_dynInstProto";
      var strUseBaseInst = "useBaseInst";
      var strSetInstFuncs = "setInstFuncs";
      var Obj = Object;
      var _objGetPrototypeOf = Obj["getPrototypeOf"];
      var _objGetOwnProps = Obj["getOwnPropertyNames"];
      function _getGlobal() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
          result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
          result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
          result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
          result = global;
        }
        return result || {};
      }
      var _gbl = _getGlobal();
      var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a$1 = {}, _a$1[strSetInstFuncs] = true, _a$1[strUseBaseInst] = true, _a$1),
        n: 1e3
      });
      function _hasOwnProperty(obj, prop) {
        return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);
      }
      function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
      }
      function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
      }
      function _getObjProto(target) {
        var newProto;
        if (target) {
          if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
          }
          var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
          newProto = target[DynProtoBaseProto] || curProto;
          if (!_hasOwnProperty(target, DynProtoBaseProto)) {
            delete target[DynProtoCurrent];
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
          }
        }
        return newProto;
      }
      function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
          props = _objGetOwnProps(target);
        } else {
          for (var name_1 in target) {
            if (typeof name_1 === "string" && _hasOwnProperty(target, name_1)) {
              props.push(name_1);
            }
          }
        }
        if (props && props.length > 0) {
          for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
          }
        }
      }
      function _isDynamicCandidate(target, funcName, skipOwn) {
        return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName));
      }
      function _throwTypeError(message) {
        throw new TypeError("DynamicProto: " + message);
      }
      function _getInstanceFuncs(thisTarget) {
        var instFuncs = {};
        _forEachProp(thisTarget, function(name2) {
          if (!instFuncs[name2] && _isDynamicCandidate(thisTarget, name2, false)) {
            instFuncs[name2] = thisTarget[name2];
          }
        });
        return instFuncs;
      }
      function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
          if (values[lp] === value) {
            return true;
          }
        }
        return false;
      }
      function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
          var theFunc = funcHost[funcName];
          if (theFunc[DynProxyTag] && useBaseInst) {
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
          }
          return function() {
            return theFunc.apply(target, arguments);
          };
        }
        var baseFuncs = {};
        _forEachProp(instFuncs, function(name2) {
          baseFuncs[name2] = _instFuncProxy(thisTarget, instFuncs, name2);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
          _forEachProp(baseProto, function(name2) {
            if (!baseFuncs[name2] && _isDynamicCandidate(baseProto, name2, !_objGetPrototypeOf)) {
              baseFuncs[name2] = _instFuncProxy(thisTarget, baseProto, name2);
            }
          });
          visited.push(baseProto);
          baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
      }
      function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && _hasOwnProperty(proto, DynClassName)) {
          var instFuncTable = target[DynInstFuncTable] || {};
          instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName];
          if (!instFunc) {
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
          }
          if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            var canAddInst = !_hasOwnProperty(target, funcName);
            var objProto = _getObjProto(target);
            var visited = [];
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
              var protoFunc = objProto[funcName];
              if (protoFunc) {
                canAddInst = protoFunc === currentDynProtoProxy;
                break;
              }
              visited.push(objProto);
              objProto = _getObjProto(objProto);
            }
            try {
              if (canAddInst) {
                target[funcName] = instFunc;
              }
              instFunc[DynInstChkTag] = 1;
            } catch (e) {
              instFuncTable[DynAllowInstChkTag] = false;
            }
          }
        }
        return instFunc;
      }
      function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
          protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
          _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
      }
      function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto2, funcName) {
          var dynProtoProxy = function() {
            var instFunc = _getInstFunc(this, funcName, proto2, dynProtoProxy) || _getProtoFunc(funcName, proto2, dynProtoProxy);
            return instFunc.apply(this, arguments);
          };
          dynProtoProxy[DynProxyTag] = 1;
          return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
          var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {};
          var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || {};
          if (instFuncTable[DynAllowInstChkTag] !== false) {
            instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
          }
          _forEachProp(target, function(name2) {
            if (_isDynamicCandidate(target, name2, false) && target[name2] !== baseInstFuncs[name2]) {
              instFuncs_1[name2] = target[name2];
              delete target[name2];
              if (!_hasOwnProperty(proto, name2) || proto[name2] && !proto[name2][DynProxyTag]) {
                proto[name2] = _createDynamicPrototype(proto, name2);
              }
            }
          });
        }
      }
      function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
          var visited = [];
          var thisProto = _getObjProto(thisTarget);
          while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
              return true;
            }
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
          }
          return false;
        }
        return true;
      }
      function _getObjName(target, unknownValue) {
        if (_hasOwnProperty(target, Prototype)) {
          return target.name || unknownValue || UnknownValue;
        }
        return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
      }
      function dynamicProto(theClass, target, delegateFunc, options) {
        if (!_hasOwnProperty(theClass, Prototype)) {
          _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
          _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (_hasOwnProperty(classProto, DynClassName)) {
          className = classProto[DynClassName];
        } else {
          className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
          _gblInst.n++;
          classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== void 0) {
          useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
          setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
      }
      dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
      var strWindow = "window";
      var strDocument = "document";
      var strDocumentMode = "documentMode";
      var strNavigator = "navigator";
      var strHistory = "history";
      var strLocation = "location";
      var strConsole = "console";
      var strPerformance = "performance";
      var strJSON = "JSON";
      var strCrypto = "crypto";
      var strMsCrypto = "msCrypto";
      var strReactNative = "ReactNative";
      var strMsie = "msie";
      var strTrident = "trident/";
      var strXMLHttpRequest = "XMLHttpRequest";
      var _isTrident = null;
      var _navUserAgentCheck = null;
      var _enableMocks = false;
      var _useXDomainRequest = null;
      var _beaconsSupported = null;
      function _hasProperty(theClass, property) {
        var supported = false;
        if (theClass) {
          try {
            supported = property in theClass;
            if (!supported) {
              var proto = theClass[strShimPrototype];
              if (proto) {
                supported = property in proto;
              }
            }
          } catch (e) {
          }
          if (!supported) {
            try {
              var tmp = new theClass();
              supported = !isUndefined(tmp[property]);
            } catch (e) {
            }
          }
        }
        return supported;
      }
      function setEnableEnvMocks(enabled) {
        _enableMocks = enabled;
      }
      function getGlobalInst(name2) {
        var gbl = getGlobal();
        if (gbl && gbl[name2]) {
          return gbl[name2];
        }
        if (name2 === strWindow && hasWindow()) {
          return window;
        }
        return null;
      }
      function hasWindow() {
        return Boolean(typeof window === strShimObject && window);
      }
      function getWindow() {
        if (hasWindow()) {
          return window;
        }
        return getGlobalInst(strWindow);
      }
      function hasDocument() {
        return Boolean(typeof document === strShimObject && document);
      }
      function getDocument() {
        if (hasDocument()) {
          return document;
        }
        return getGlobalInst(strDocument);
      }
      function hasNavigator() {
        return Boolean(typeof navigator === strShimObject && navigator);
      }
      function getNavigator() {
        if (hasNavigator()) {
          return navigator;
        }
        return getGlobalInst(strNavigator);
      }
      function hasHistory() {
        return Boolean(typeof history === strShimObject && history);
      }
      function getHistory() {
        if (hasHistory()) {
          return history;
        }
        return getGlobalInst(strHistory);
      }
      function getLocation(checkForMock) {
        if (checkForMock && _enableMocks) {
          var mockLocation = getGlobalInst("__mockLocation");
          if (mockLocation) {
            return mockLocation;
          }
        }
        if (typeof location === strShimObject && location) {
          return location;
        }
        return getGlobalInst(strLocation);
      }
      function getConsole() {
        if (typeof console !== strShimUndefined) {
          return console;
        }
        return getGlobalInst(strConsole);
      }
      function getPerformance() {
        return getGlobalInst(strPerformance);
      }
      function hasJSON() {
        return Boolean(typeof JSON === strShimObject && JSON || getGlobalInst(strJSON) !== null);
      }
      function getJSON() {
        if (hasJSON()) {
          return JSON || getGlobalInst(strJSON);
        }
        return null;
      }
      function getCrypto() {
        return getGlobalInst(strCrypto);
      }
      function getMsCrypto() {
        return getGlobalInst(strMsCrypto);
      }
      function isReactNative() {
        var nav = getNavigator();
        if (nav && nav.product) {
          return nav.product === strReactNative;
        }
        return false;
      }
      function isIE() {
        var nav = getNavigator();
        if (nav && (nav[_DYN_USER_AGENT] !== _navUserAgentCheck || _isTrident === null)) {
          _navUserAgentCheck = nav[_DYN_USER_AGENT];
          var userAgent = (_navUserAgentCheck || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
          _isTrident = strContains(userAgent, strMsie) || strContains(userAgent, strTrident);
        }
        return _isTrident;
      }
      function getIEVersion(userAgentStr) {
        if (userAgentStr === void 0) {
          userAgentStr = null;
        }
        if (!userAgentStr) {
          var navigator_1 = getNavigator() || {};
          userAgentStr = navigator_1 ? (navigator_1[_DYN_USER_AGENT] || STR_EMPTY)[_DYN_TO_LOWER_CASE]() : STR_EMPTY;
        }
        var ua = (userAgentStr || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
        if (strContains(ua, strMsie)) {
          var doc = getDocument() || {};
          return Math.max(parseInt(ua[_DYN_SPLIT](strMsie)[1]), doc[strDocumentMode] || 0);
        } else if (strContains(ua, strTrident)) {
          var tridentVer = parseInt(ua[_DYN_SPLIT](strTrident)[1]);
          if (tridentVer) {
            return tridentVer + 4;
          }
        }
        return null;
      }
      function dumpObj(object) {
        var objectTypeDump = Object[strShimPrototype].toString[_DYN_CALL](object);
        var propertyValueDump = STR_EMPTY;
        if (objectTypeDump === "[object Error]") {
          propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object[_DYN_NAME] + "'";
        } else if (hasJSON()) {
          propertyValueDump = getJSON().stringify(object);
        }
        return objectTypeDump + propertyValueDump;
      }
      function isSafari(userAgentStr) {
        if (!userAgentStr || !isString(userAgentStr)) {
          var navigator_2 = getNavigator() || {};
          userAgentStr = navigator_2 ? (navigator_2[_DYN_USER_AGENT] || STR_EMPTY)[_DYN_TO_LOWER_CASE]() : STR_EMPTY;
        }
        var ua = (userAgentStr || STR_EMPTY)[_DYN_TO_LOWER_CASE]();
        return ua[_DYN_INDEX_OF]("safari") >= 0;
      }
      function isBeaconsSupported() {
        if (_beaconsSupported === null) {
          _beaconsSupported = hasNavigator() && Boolean(getNavigator().sendBeacon);
        }
        return _beaconsSupported;
      }
      function isFetchSupported(withKeepAlive) {
        var isSupported = false;
        try {
          isSupported = !!getGlobalInst("fetch");
          var request = getGlobalInst("Request");
          if (isSupported && withKeepAlive && request) {
            isSupported = _hasProperty(request, "keepalive");
          }
        } catch (e) {
        }
        return isSupported;
      }
      function useXDomainRequest() {
        if (_useXDomainRequest === null) {
          _useXDomainRequest = typeof XDomainRequest !== strShimUndefined;
          if (_useXDomainRequest && isXhrSupported()) {
            _useXDomainRequest = _useXDomainRequest && !_hasProperty(getGlobalInst(strXMLHttpRequest), "withCredentials");
          }
        }
        return _useXDomainRequest;
      }
      function isXhrSupported() {
        var isSupported = false;
        try {
          var xmlHttpRequest = getGlobalInst(strXMLHttpRequest);
          isSupported = !!xmlHttpRequest;
        } catch (e) {
        }
        return isSupported;
      }
      function _getNamedValue(values, name2) {
        if (values) {
          for (var i = 0; i < values[_DYN_LENGTH]; i++) {
            var value = values[i];
            if (value[_DYN_NAME]) {
              if (value[_DYN_NAME] === name2) {
                return value;
              }
            }
          }
        }
        return {};
      }
      function findMetaTag(name2) {
        var doc = getDocument();
        if (doc && name2) {
          return _getNamedValue(doc.querySelectorAll("meta"), name2).content;
        }
        return null;
      }
      function findNamedServerTiming(name2) {
        var value;
        var perf = getPerformance();
        if (perf) {
          var navPerf = perf.getEntriesByType("navigation") || [];
          value = _getNamedValue((navPerf[_DYN_LENGTH] > 0 ? navPerf[0] : {}).serverTiming, name2).description;
        }
        return value;
      }
      function dispatchEvent(target, evnt) {
        if (target && target.dispatchEvent && evnt) {
          target.dispatchEvent(evnt);
          return true;
        }
        return false;
      }
      function createCustomDomEvent(eventName, details) {
        var event = null;
        var detail = { detail: details || null };
        if (isFunction(CustomEvent)) {
          event = new CustomEvent(eventName, detail);
        } else {
          var doc = getDocument();
          if (doc && doc.createEvent) {
            event = doc.createEvent("CustomEvent");
            event.initCustomEvent(eventName, true, true, detail);
          }
        }
        return event;
      }
      function sendCustomEvent(evtName, cfg, customDetails) {
        var global2 = getGlobal();
        if (global2 && global2.CustomEvent) {
          try {
            var details = { cfg: cfg || null, customDetails: customDetails || null };
            return dispatchEvent(global2, createCustomDomEvent(evtName, details));
          } catch (e) {
          }
        }
        return false;
      }
      var listenerFuncs = ["eventsSent", "eventsDiscarded", "eventsSendRequest", "perfEvent"];
      var _aiNamespace = null;
      var _debugListener;
      function _listenerProxyFunc(name2, config) {
        return function() {
          var args = arguments;
          var dbgExt = getDebugExt(config);
          if (dbgExt) {
            var listener = dbgExt.listener;
            if (listener && listener[name2]) {
              listener[name2][_DYN_APPLY](listener, args);
            }
          }
        };
      }
      function _getExtensionNamespace() {
        var target = getGlobalInst("Microsoft");
        if (target) {
          _aiNamespace = target["ApplicationInsights"];
        }
        return _aiNamespace;
      }
      function getDebugExt(config) {
        var ns = _aiNamespace;
        if (!ns && config.disableDbgExt !== true) {
          ns = _aiNamespace || _getExtensionNamespace();
        }
        return ns ? ns["ChromeDbgExt"] : null;
      }
      function getDebugListener(config) {
        if (!_debugListener) {
          _debugListener = {};
          for (var lp = 0; lp < listenerFuncs[_DYN_LENGTH]; lp++) {
            _debugListener[listenerFuncs[lp]] = _listenerProxyFunc(listenerFuncs[lp], config);
          }
        }
        return _debugListener;
      }
      var AiNonUserActionablePrefix = "AI (Internal): ";
      var AiUserActionablePrefix = "AI: ";
      var AIInternalMessagePrefix = "AITR_";
      function _sanitizeDiagnosticText(text) {
        if (text) {
          return '"' + text[_DYN_REPLACE](/\"/g, STR_EMPTY) + '"';
        }
        return STR_EMPTY;
      }
      function _logToConsole(func, message) {
        var theConsole = getConsole();
        if (!!theConsole) {
          var logFunc = "log";
          if (theConsole[func]) {
            logFunc = func;
          }
          if (isFunction(theConsole[logFunc])) {
            theConsole[logFunc](message);
          }
        }
      }
      var _InternalLogMessage = (
        /** @class */
        function() {
          function _InternalLogMessage2(msgId, msg, isUserAct, properties) {
            if (isUserAct === void 0) {
              isUserAct = false;
            }
            var _self = this;
            _self[_DYN_MESSAGE_ID] = msgId;
            _self[_DYN_MESSAGE] = (isUserAct ? AiUserActionablePrefix : AiNonUserActionablePrefix) + msgId;
            var strProps = STR_EMPTY;
            if (hasJSON()) {
              strProps = getJSON().stringify(properties);
            }
            var diagnosticText = (msg ? " message:" + _sanitizeDiagnosticText(msg) : STR_EMPTY) + (properties ? " props:" + _sanitizeDiagnosticText(strProps) : STR_EMPTY);
            _self[_DYN_MESSAGE] += diagnosticText;
          }
          _InternalLogMessage2.dataType = "MessageData";
          return _InternalLogMessage2;
        }()
      );
      function safeGetLogger(core, config) {
        return (core || {})[_DYN_LOGGER] || new DiagnosticLogger(config);
      }
      var DiagnosticLogger = (
        /** @class */
        function() {
          function DiagnosticLogger2(config) {
            this.identifier = "DiagnosticLogger";
            this.queue = [];
            var _messageCount = 0;
            var _messageLogged = {};
            var _loggingLevelConsole;
            var _loggingLevelTelemetry;
            var _maxInternalMessageLimit;
            var _enableDebug;
            dynamicProto(DiagnosticLogger2, this, function(_self) {
              _setDefaultsFromConfig(config || {});
              _self.consoleLoggingLevel = function() {
                return _loggingLevelConsole;
              };
              _self.telemetryLoggingLevel = function() {
                return _loggingLevelTelemetry;
              };
              _self.maxInternalMessageLimit = function() {
                return _maxInternalMessageLimit;
              };
              _self[_DYN_ENABLE_DEBUG_EXCEPTI4] = function() {
                return _enableDebug;
              };
              _self.throwInternal = function(severity, msgId, msg, properties, isUserAct) {
                if (isUserAct === void 0) {
                  isUserAct = false;
                }
                var message = new _InternalLogMessage(msgId, msg, isUserAct, properties);
                if (_enableDebug) {
                  throw dumpObj(message);
                } else {
                  var logFunc = severity === 1 ? STR_ERROR_TO_CONSOLE : STR_WARN_TO_CONSOLE;
                  if (!isUndefined(message[_DYN_MESSAGE])) {
                    if (isUserAct) {
                      var messageKey = +message[_DYN_MESSAGE_ID];
                      if (!_messageLogged[messageKey] && _loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE]);
                        _messageLogged[messageKey] = true;
                      }
                    } else {
                      if (_loggingLevelConsole >= severity) {
                        _self[logFunc](message[_DYN_MESSAGE]);
                      }
                    }
                    _logInternalMessage2(severity, message);
                  } else {
                    _debugExtMsg("throw" + (severity === 1 ? "Critical" : "Warning"), message);
                  }
                }
              };
              _self[STR_WARN_TO_CONSOLE] = function(message) {
                _logToConsole("warn", message);
                _debugExtMsg("warning", message);
              };
              _self[STR_ERROR_TO_CONSOLE] = function(message) {
                _logToConsole("error", message);
                _debugExtMsg("error", message);
              };
              _self.resetInternalMessageCount = function() {
                _messageCount = 0;
                _messageLogged = {};
              };
              _self[_DYN_LOG_INTERNAL_MESSAGE] = _logInternalMessage2;
              function _logInternalMessage2(severity, message) {
                if (_areInternalMessagesThrottled()) {
                  return;
                }
                var logMessage2 = true;
                var messageKey = AIInternalMessagePrefix + message[_DYN_MESSAGE_ID];
                if (_messageLogged[messageKey]) {
                  logMessage2 = false;
                } else {
                  _messageLogged[messageKey] = true;
                }
                if (logMessage2) {
                  if (severity <= _loggingLevelTelemetry) {
                    _self.queue[_DYN_PUSH](message);
                    _messageCount++;
                    _debugExtMsg(severity === 1 ? "error" : "warn", message);
                  }
                  if (_messageCount === _maxInternalMessageLimit) {
                    var throttleLimitMessage = "Internal events throttle limit per PageView reached for this app.";
                    var throttleMessage = new _InternalLogMessage(23, throttleLimitMessage, false);
                    _self.queue[_DYN_PUSH](throttleMessage);
                    if (severity === 1) {
                      _self[STR_ERROR_TO_CONSOLE](throttleLimitMessage);
                    } else {
                      _self[STR_WARN_TO_CONSOLE](throttleLimitMessage);
                    }
                  }
                }
              }
              function _setDefaultsFromConfig(config2) {
                _loggingLevelConsole = getCfgValue(config2.loggingLevelConsole, 0);
                _loggingLevelTelemetry = getCfgValue(config2.loggingLevelTelemetry, 1);
                _maxInternalMessageLimit = getCfgValue(config2.maxMessageLimit, 25);
                _enableDebug = getCfgValue(config2.enableDebug, getCfgValue(config2[_DYN_ENABLE_DEBUG_EXCEPTI4], false));
              }
              function _areInternalMessagesThrottled() {
                return _messageCount >= _maxInternalMessageLimit;
              }
              function _debugExtMsg(name2, data) {
                var dbgExt = getDebugExt(config || {});
                if (dbgExt && dbgExt[_DYN_DIAG_LOG]) {
                  dbgExt[_DYN_DIAG_LOG](name2, data);
                }
              }
            });
          }
          DiagnosticLogger2.__ieDyn = 1;
          return DiagnosticLogger2;
        }()
      );
      function _getLogger(logger) {
        return logger || new DiagnosticLogger();
      }
      function _throwInternal(logger, severity, msgId, msg, properties, isUserAct) {
        if (isUserAct === void 0) {
          isUserAct = false;
        }
        _getLogger(logger).throwInternal(severity, msgId, msg, properties, isUserAct);
      }
      function _warnToConsole(logger, message) {
        _getLogger(logger)[STR_WARN_TO_CONSOLE](message);
      }
      function _logInternalMessage(logger, severity, message) {
        _getLogger(logger)[_DYN_LOG_INTERNAL_MESSAGE](severity, message);
      }
      var strExecutionContextKey = "ctx";
      var strParentContextKey = "ParentContextKey";
      var strChildrenContextKey = "ChildrenContextKey";
      var _defaultPerfManager = null;
      var PerfEvent = (
        /** @class */
        function() {
          function PerfEvent2(name2, payloadDetails, isAsync) {
            var _self = this;
            var accessorDefined = false;
            _self.start = dateNow();
            _self[_DYN_NAME] = name2;
            _self[_DYN_IS_ASYNC] = isAsync;
            _self[_DYN_IS_CHILD_EVT] = function() {
              return false;
            };
            if (isFunction(payloadDetails)) {
              var theDetails_1;
              accessorDefined = objDefineAccessors(_self, "payload", function() {
                if (!theDetails_1 && isFunction(payloadDetails)) {
                  theDetails_1 = payloadDetails();
                  payloadDetails = null;
                }
                return theDetails_1;
              });
            }
            _self[_DYN_GET_CTX] = function(key) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey] || key === PerfEvent2[strChildrenContextKey]) {
                  return _self[key];
                }
                return (_self[strExecutionContextKey] || {})[key];
              }
              return null;
            };
            _self[_DYN_SET_CTX] = function(key, value) {
              if (key) {
                if (key === PerfEvent2[strParentContextKey]) {
                  if (!_self[key]) {
                    _self[_DYN_IS_CHILD_EVT] = function() {
                      return true;
                    };
                  }
                  _self[key] = value;
                } else if (key === PerfEvent2[strChildrenContextKey]) {
                  _self[key] = value;
                } else {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              }
            };
            _self[_DYN_COMPLETE] = function() {
              var childTime = 0;
              var childEvts = _self[_DYN_GET_CTX](PerfEvent2[strChildrenContextKey]);
              if (isArray(childEvts)) {
                for (var lp = 0; lp < childEvts[_DYN_LENGTH]; lp++) {
                  var childEvt = childEvts[lp];
                  if (childEvt) {
                    childTime += childEvt[_DYN_TIME];
                  }
                }
              }
              _self[_DYN_TIME] = dateNow() - _self.start;
              _self.exTime = _self[_DYN_TIME] - childTime;
              _self[_DYN_COMPLETE] = function() {
              };
              if (!accessorDefined && isFunction(payloadDetails)) {
                _self.payload = payloadDetails();
              }
            };
          }
          PerfEvent2.ParentContextKey = "parent";
          PerfEvent2.ChildrenContextKey = "childEvts";
          return PerfEvent2;
        }()
      );
      var PerfManager = (
        /** @class */
        function() {
          function PerfManager2(manager) {
            this.ctx = {};
            dynamicProto(PerfManager2, this, function(_self) {
              _self.create = function(src, payloadDetails, isAsync) {
                return new PerfEvent(src, payloadDetails, isAsync);
              };
              _self.fire = function(perfEvent) {
                if (perfEvent) {
                  perfEvent[_DYN_COMPLETE]();
                  if (manager && isFunction(manager[STR_PERF_EVENT])) {
                    manager[STR_PERF_EVENT](perfEvent);
                  }
                }
              };
              _self[_DYN_SET_CTX] = function(key, value) {
                if (key) {
                  var ctx = _self[strExecutionContextKey] = _self[strExecutionContextKey] || {};
                  ctx[key] = value;
                }
              };
              _self[_DYN_GET_CTX] = function(key) {
                return (_self[strExecutionContextKey] || {})[key];
              };
            });
          }
          PerfManager2.__ieDyn = 1;
          return PerfManager2;
        }()
      );
      var doPerfActiveKey = "CoreUtils.doPerf";
      function doPerf(mgrSource, getSource, func, details, isAsync) {
        if (mgrSource) {
          var perfMgr = mgrSource;
          if (perfMgr[STR_GET_PERF_MGR]) {
            perfMgr = perfMgr[STR_GET_PERF_MGR]();
          }
          if (perfMgr) {
            var perfEvt = void 0;
            var currentActive = perfMgr[_DYN_GET_CTX](doPerfActiveKey);
            try {
              perfEvt = perfMgr.create(getSource(), details, isAsync);
              if (perfEvt) {
                if (currentActive && perfEvt[_DYN_SET_CTX]) {
                  perfEvt[_DYN_SET_CTX](PerfEvent[strParentContextKey], currentActive);
                  if (currentActive[_DYN_GET_CTX] && currentActive[_DYN_SET_CTX]) {
                    var children = currentActive[_DYN_GET_CTX](PerfEvent[strChildrenContextKey]);
                    if (!children) {
                      children = [];
                      currentActive[_DYN_SET_CTX](PerfEvent[strChildrenContextKey], children);
                    }
                    children[_DYN_PUSH](perfEvt);
                  }
                }
                perfMgr[_DYN_SET_CTX](doPerfActiveKey, perfEvt);
                return func(perfEvt);
              }
            } catch (ex) {
              if (perfEvt && perfEvt[_DYN_SET_CTX]) {
                perfEvt[_DYN_SET_CTX]("exception", ex);
              }
            } finally {
              if (perfEvt) {
                perfMgr.fire(perfEvt);
              }
              perfMgr[_DYN_SET_CTX](doPerfActiveKey, currentActive);
            }
          }
        }
        return func();
      }
      function setGblPerfMgr(perfManager) {
        _defaultPerfManager = perfManager;
      }
      function getGblPerfMgr() {
        return _defaultPerfManager;
      }
      var UInt32Mask = 4294967296;
      var MaxUInt32 = 4294967295;
      var _mwcSeeded = false;
      var _mwcW = 123456789;
      var _mwcZ = 987654321;
      function _mwcSeed(seedValue) {
        if (seedValue < 0) {
          seedValue >>>= 0;
        }
        _mwcW = 123456789 + seedValue & MaxUInt32;
        _mwcZ = 987654321 - seedValue & MaxUInt32;
        _mwcSeeded = true;
      }
      function _autoSeedMwc() {
        try {
          var now = dateNow() & 2147483647;
          _mwcSeed((Math.random() * UInt32Mask ^ now) + now);
        } catch (e) {
        }
      }
      function randomValue(maxValue) {
        if (maxValue > 0) {
          return Math.floor(random32() / MaxUInt32 * (maxValue + 1)) >>> 0;
        }
        return 0;
      }
      function random32(signed) {
        var value = 0;
        var c = getCrypto() || getMsCrypto();
        if (c && c.getRandomValues) {
          value = c.getRandomValues(new Uint32Array(1))[0] & MaxUInt32;
        }
        if (value === 0 && isIE()) {
          if (!_mwcSeeded) {
            _autoSeedMwc();
          }
          value = mwcRandom32() & MaxUInt32;
        }
        if (value === 0) {
          value = Math.floor(UInt32Mask * Math.random() | 0);
        }
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function mwcRandomSeed(value) {
        if (!value) {
          _autoSeedMwc();
        } else {
          _mwcSeed(value);
        }
      }
      function mwcRandom32(signed) {
        _mwcZ = 36969 * (_mwcZ & 65535) + (_mwcZ >> 16) & MaxUInt32;
        _mwcW = 18e3 * (_mwcW & 65535) + (_mwcW >> 16) & MaxUInt32;
        var value = (_mwcZ << 16) + (_mwcW & 65535) >>> 0 & MaxUInt32 | 0;
        if (!signed) {
          value >>>= 0;
        }
        return value;
      }
      function newId(maxLength) {
        if (maxLength === void 0) {
          maxLength = 22;
        }
        var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var number = random32() >>> 0;
        var chars = 0;
        var result = STR_EMPTY;
        while (result[_DYN_LENGTH] < maxLength) {
          chars++;
          result += base64chars.charAt(number & 63);
          number >>>= 6;
          if (chars === 5) {
            number = (random32() << 2 & 4294967295 | number & 3) >>> 0;
            chars = 0;
          }
        }
        return result;
      }
      var _objDefineProperty = ObjDefineProperty;
      var version = "2.8.15";
      var instanceName = "." + newId(6);
      var _dataUid = 0;
      function _createAccessor(target, prop, value) {
        if (_objDefineProperty) {
          try {
            _objDefineProperty(target, prop, {
              value,
              enumerable: false,
              configurable: true
            });
            return true;
          } catch (e) {
          }
        }
        return false;
      }
      function _canAcceptData(target) {
        return target[_DYN_NODE_TYPE] === 1 || target[_DYN_NODE_TYPE] === 9 || !+target[_DYN_NODE_TYPE];
      }
      function _getCache(data, target) {
        var theCache = target[data.id];
        if (!theCache) {
          theCache = {};
          try {
            if (_canAcceptData(target)) {
              if (!_createAccessor(target, data.id, theCache)) {
                target[data.id] = theCache;
              }
            }
          } catch (e) {
          }
        }
        return theCache;
      }
      function createUniqueNamespace(name2, includeVersion) {
        if (includeVersion === void 0) {
          includeVersion = false;
        }
        return normalizeJsName(name2 + _dataUid++ + (includeVersion ? "." + version : STR_EMPTY) + instanceName);
      }
      function createElmNodeData(name2) {
        var data = {
          id: createUniqueNamespace("_aiData-" + (name2 || STR_EMPTY) + "." + version),
          accept: function(target) {
            return _canAcceptData(target);
          },
          get: function(target, name3, defValue, addDefault) {
            var theCache = target[data.id];
            if (!theCache) {
              if (addDefault) {
                theCache = _getCache(data, target);
                theCache[normalizeJsName(name3)] = defValue;
              }
              return defValue;
            }
            return theCache[normalizeJsName(name3)];
          },
          kill: function(target, name3) {
            if (target && target[name3]) {
              try {
                delete target[name3];
              } catch (e) {
              }
            }
          }
        };
        return data;
      }
      var strToGMTString = "toGMTString";
      var strToUTCString = "toUTCString";
      var strCookie = "cookie";
      var strExpires = "expires";
      var strEnabled = "enabled";
      var strIsCookieUseDisabled = "isCookieUseDisabled";
      var strDisableCookiesUsage = "disableCookiesUsage";
      var strConfigCookieMgr = "_ckMgr";
      var _supportsCookies = null;
      var _allowUaSameSite = null;
      var _parsedCookieValue = null;
      var _doc = getDocument();
      var _cookieCache = {};
      var _globalCookieConfig = {};
      function _gblCookieMgr(config, logger) {
        var inst = createCookieMgr[strConfigCookieMgr] || _globalCookieConfig[strConfigCookieMgr];
        if (!inst) {
          inst = createCookieMgr[strConfigCookieMgr] = createCookieMgr(config, logger);
          _globalCookieConfig[strConfigCookieMgr] = inst;
        }
        return inst;
      }
      function _isMgrEnabled(cookieMgr) {
        if (cookieMgr) {
          return cookieMgr.isEnabled();
        }
        return true;
      }
      function _createCookieMgrConfig(rootConfig) {
        var cookieMgrCfg = rootConfig[_DYN_COOKIE_CFG] = rootConfig[_DYN_COOKIE_CFG] || {};
        setValue(cookieMgrCfg, "domain", rootConfig.cookieDomain, isNotNullOrUndefined, isNullOrUndefined);
        setValue(cookieMgrCfg, "path", rootConfig.cookiePath || "/", null, isNullOrUndefined);
        if (isNullOrUndefined(cookieMgrCfg[strEnabled])) {
          var cookieEnabled = void 0;
          if (!isUndefined(rootConfig[strIsCookieUseDisabled])) {
            cookieEnabled = !rootConfig[strIsCookieUseDisabled];
          }
          if (!isUndefined(rootConfig[strDisableCookiesUsage])) {
            cookieEnabled = !rootConfig[strDisableCookiesUsage];
          }
          cookieMgrCfg[strEnabled] = cookieEnabled;
        }
        return cookieMgrCfg;
      }
      function _isIgnoredCookie(cookieMgrCfg, name2) {
        if (name2 && cookieMgrCfg && isArray(cookieMgrCfg.ignoreCookies)) {
          return cookieMgrCfg.ignoreCookies[_DYN_INDEX_OF](name2) !== -1;
        }
        return false;
      }
      function _isBlockedCookie(cookieMgrCfg, name2) {
        if (name2 && cookieMgrCfg && isArray(cookieMgrCfg.blockedCookies)) {
          if (cookieMgrCfg.blockedCookies[_DYN_INDEX_OF](name2) !== -1) {
            return true;
          }
        }
        return _isIgnoredCookie(cookieMgrCfg, name2);
      }
      function safeGetCookieMgr(core, config) {
        var cookieMgr;
        if (core) {
          cookieMgr = core.getCookieMgr();
        } else if (config) {
          var cookieCfg = config[_DYN_COOKIE_CFG];
          if (cookieCfg[strConfigCookieMgr]) {
            cookieMgr = cookieCfg[strConfigCookieMgr];
          } else {
            cookieMgr = createCookieMgr(config);
          }
        }
        if (!cookieMgr) {
          cookieMgr = _gblCookieMgr(config, (core || {})[_DYN_LOGGER]);
        }
        return cookieMgr;
      }
      function createCookieMgr(rootConfig, logger) {
        var _a2;
        var cookieMgrConfig = _createCookieMgrConfig(rootConfig || _globalCookieConfig);
        var _path = cookieMgrConfig.path || "/";
        var _domain = cookieMgrConfig.domain;
        var _enabled = cookieMgrConfig[strEnabled] !== false;
        var cookieMgr = (_a2 = {
          isEnabled: function() {
            var enabled = _enabled && areCookiesSupported(logger);
            var gblManager = _globalCookieConfig[strConfigCookieMgr];
            if (enabled && gblManager && cookieMgr !== gblManager) {
              enabled = _isMgrEnabled(gblManager);
            }
            return enabled;
          }
        }, _a2[_DYN_SET_ENABLED] = function(value) {
          _enabled = value !== false;
        }, _a2.set = function(name2, value, maxAgeSec, domain, path2) {
          var result = false;
          if (_isMgrEnabled(cookieMgr) && !_isBlockedCookie(cookieMgrConfig, name2)) {
            var values = {};
            var theValue = strTrim(value || STR_EMPTY);
            var idx = theValue[_DYN_INDEX_OF](";");
            if (idx !== -1) {
              theValue = strTrim(value[_DYN_SUBSTRING](0, idx));
              values = _extractParts(value[_DYN_SUBSTRING](idx + 1));
            }
            setValue(values, "domain", domain || _domain, isTruthy, isUndefined);
            if (!isNullOrUndefined(maxAgeSec)) {
              var _isIE = isIE();
              if (isUndefined(values[strExpires])) {
                var nowMs = dateNow();
                var expireMs = nowMs + maxAgeSec * 1e3;
                if (expireMs > 0) {
                  var expiry = /* @__PURE__ */ new Date();
                  expiry.setTime(expireMs);
                  setValue(values, strExpires, _formatDate(expiry, !_isIE ? strToUTCString : strToGMTString) || _formatDate(expiry, _isIE ? strToGMTString : strToUTCString) || STR_EMPTY, isTruthy);
                }
              }
              if (!_isIE) {
                setValue(values, "max-age", STR_EMPTY + maxAgeSec, null, isUndefined);
              }
            }
            var location_1 = getLocation();
            if (location_1 && location_1.protocol === "https:") {
              setValue(values, "secure", null, null, isUndefined);
              if (_allowUaSameSite === null) {
                _allowUaSameSite = !uaDisallowsSameSiteNone((getNavigator() || {})[_DYN_USER_AGENT]);
              }
              if (_allowUaSameSite) {
                setValue(values, "SameSite", "None", null, isUndefined);
              }
            }
            setValue(values, "path", path2 || _path, null, isUndefined);
            var setCookieFn = cookieMgrConfig.setCookie || _setCookieValue;
            setCookieFn(name2, _formatCookieValue(theValue, values));
            result = true;
          }
          return result;
        }, _a2.get = function(name2) {
          var value = STR_EMPTY;
          if (_isMgrEnabled(cookieMgr) && !_isIgnoredCookie(cookieMgrConfig, name2)) {
            value = (cookieMgrConfig.getCookie || _getCookieValue)(name2);
          }
          return value;
        }, _a2.del = function(name2, path2) {
          var result = false;
          if (_isMgrEnabled(cookieMgr)) {
            result = cookieMgr.purge(name2, path2);
          }
          return result;
        }, _a2.purge = function(name2, path2) {
          var _a3;
          var result = false;
          if (areCookiesSupported(logger)) {
            var values = (_a3 = {}, _a3["path"] = path2 ? path2 : "/", _a3[strExpires] = "Thu, 01 Jan 1970 00:00:01 GMT", _a3);
            if (!isIE()) {
              values["max-age"] = "0";
            }
            var delCookie = cookieMgrConfig.delCookie || _setCookieValue;
            delCookie(name2, _formatCookieValue(STR_EMPTY, values));
            result = true;
          }
          return result;
        }, _a2);
        cookieMgr[strConfigCookieMgr] = cookieMgr;
        return cookieMgr;
      }
      function areCookiesSupported(logger) {
        if (_supportsCookies === null) {
          _supportsCookies = false;
          try {
            var doc = _doc || {};
            _supportsCookies = doc[strCookie] !== void 0;
          } catch (e) {
            _throwInternal(logger, 2, 68, "Cannot access document.cookie - " + getExceptionName(e), { exception: dumpObj(e) });
          }
        }
        return _supportsCookies;
      }
      function _extractParts(theValue) {
        var values = {};
        if (theValue && theValue[_DYN_LENGTH]) {
          var parts = strTrim(theValue)[_DYN_SPLIT](";");
          arrForEach(parts, function(thePart) {
            thePart = strTrim(thePart || STR_EMPTY);
            if (thePart) {
              var idx = thePart[_DYN_INDEX_OF]("=");
              if (idx === -1) {
                values[thePart] = null;
              } else {
                values[strTrim(thePart[_DYN_SUBSTRING](0, idx))] = strTrim(thePart[_DYN_SUBSTRING](idx + 1));
              }
            }
          });
        }
        return values;
      }
      function _formatDate(theDate, func) {
        if (isFunction(theDate[func])) {
          return theDate[func]();
        }
        return null;
      }
      function _formatCookieValue(value, values) {
        var cookieValue = value || STR_EMPTY;
        objForEachKey(values, function(name2, theValue) {
          cookieValue += "; " + name2 + (!isNullOrUndefined(theValue) ? "=" + theValue : STR_EMPTY);
        });
        return cookieValue;
      }
      function _getCookieValue(name2) {
        var cookieValue = STR_EMPTY;
        if (_doc) {
          var theCookie = _doc[strCookie] || STR_EMPTY;
          if (_parsedCookieValue !== theCookie) {
            _cookieCache = _extractParts(theCookie);
            _parsedCookieValue = theCookie;
          }
          cookieValue = strTrim(_cookieCache[name2] || STR_EMPTY);
        }
        return cookieValue;
      }
      function _setCookieValue(name2, cookieValue) {
        if (_doc) {
          _doc[strCookie] = name2 + "=" + cookieValue;
        }
      }
      function uaDisallowsSameSiteNone(userAgent) {
        if (!isString(userAgent)) {
          return false;
        }
        if (strContains(userAgent, "CPU iPhone OS 12") || strContains(userAgent, "iPad; CPU OS 12")) {
          return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strContains(userAgent, "Version/") && strContains(userAgent, "Safari")) {
          return true;
        }
        if (strContains(userAgent, "Macintosh; Intel Mac OS X 10_14") && strEndsWith(userAgent, "AppleWebKit/605.1.15 (KHTML, like Gecko)")) {
          return true;
        }
        if (strContains(userAgent, "Chrome/5") || strContains(userAgent, "Chrome/6")) {
          return true;
        }
        if (strContains(userAgent, "UnrealEngine") && !strContains(userAgent, "Chrome")) {
          return true;
        }
        if (strContains(userAgent, "UCBrowser/12") || strContains(userAgent, "UCBrowser/11")) {
          return true;
        }
        return false;
      }
      var strOnPrefix = "on";
      var strAttachEvent = "attachEvent";
      var strAddEventHelper = "addEventListener";
      var strDetachEvent = "detachEvent";
      var strRemoveEventListener = "removeEventListener";
      var strEvents = "events";
      var strVisibilityChangeEvt = "visibilitychange";
      var strPageHide = "pagehide";
      var strPageShow = "pageshow";
      var strUnload = "unload";
      var strBeforeUnload = "beforeunload";
      var strPageHideNamespace = createUniqueNamespace("aiEvtPageHide");
      var strPageShowNamespace = createUniqueNamespace("aiEvtPageShow");
      var rRemoveEmptyNs = /\.[\.]+/g;
      var rRemoveTrailingEmptyNs = /[\.]+$/;
      var _guid = 1;
      var elmNodeData = createElmNodeData("events");
      var eventNamespace = /^([^.]*)(?:\.(.+)|)/;
      function _normalizeNamespace(name2) {
        if (name2 && name2[_DYN_REPLACE]) {
          return name2[_DYN_REPLACE](/^[\s\.]+|(?=[\s\.])[\.\s]+$/g, STR_EMPTY);
        }
        return name2;
      }
      function _getEvtNamespace(eventName, evtNamespace) {
        var _a2;
        if (evtNamespace) {
          var theNamespace_1 = STR_EMPTY;
          if (isArray(evtNamespace)) {
            theNamespace_1 = STR_EMPTY;
            arrForEach(evtNamespace, function(name2) {
              name2 = _normalizeNamespace(name2);
              if (name2) {
                if (name2[0] !== ".") {
                  name2 = "." + name2;
                }
                theNamespace_1 += name2;
              }
            });
          } else {
            theNamespace_1 = _normalizeNamespace(evtNamespace);
          }
          if (theNamespace_1) {
            if (theNamespace_1[0] !== ".") {
              theNamespace_1 = "." + theNamespace_1;
            }
            eventName = (eventName || STR_EMPTY) + theNamespace_1;
          }
        }
        var parsedEvent = eventNamespace.exec(eventName || STR_EMPTY) || [];
        return _a2 = {}, _a2[_DYN_TYPE] = parsedEvent[1], _a2.ns = (parsedEvent[2] || STR_EMPTY).replace(rRemoveEmptyNs, ".").replace(rRemoveTrailingEmptyNs, STR_EMPTY)[_DYN_SPLIT](".").sort().join("."), _a2;
      }
      function __getRegisteredEvents(target, eventName, evtNamespace) {
        var theEvents = [];
        var eventCache = elmNodeData.get(target, strEvents, {}, false);
        var evtName = _getEvtNamespace(eventName, evtNamespace);
        objForEachKey(eventCache, function(evtType, registeredEvents) {
          arrForEach(registeredEvents, function(value) {
            var _a2;
            if (!evtName[_DYN_TYPE] || evtName[_DYN_TYPE] === value.evtName[_DYN_TYPE]) {
              if (!evtName.ns || evtName.ns === evtName.ns) {
                theEvents[_DYN_PUSH]((_a2 = {}, _a2[_DYN_NAME] = value.evtName[_DYN_TYPE] + (value.evtName.ns ? "." + value.evtName.ns : STR_EMPTY), _a2.handler = value[_DYN_HANDLER], _a2));
              }
            }
          });
        });
        return theEvents;
      }
      function _getRegisteredEvents(target, evtName, addDefault) {
        if (addDefault === void 0) {
          addDefault = true;
        }
        var aiEvts = elmNodeData.get(target, strEvents, {}, addDefault);
        var registeredEvents = aiEvts[evtName];
        if (!registeredEvents) {
          registeredEvents = aiEvts[evtName] = [];
        }
        return registeredEvents;
      }
      function _doDetach(obj, evtName, handlerRef, useCapture) {
        if (obj && evtName && evtName[_DYN_TYPE]) {
          if (obj[strRemoveEventListener]) {
            obj[strRemoveEventListener](evtName[_DYN_TYPE], handlerRef, useCapture);
          } else if (obj[strDetachEvent]) {
            obj[strDetachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
          }
        }
      }
      function _doAttach(obj, evtName, handlerRef, useCapture) {
        var result = false;
        if (obj && evtName && evtName[_DYN_TYPE] && handlerRef) {
          if (obj[strAddEventHelper]) {
            obj[strAddEventHelper](evtName[_DYN_TYPE], handlerRef, useCapture);
            result = true;
          } else if (obj[strAttachEvent]) {
            obj[strAttachEvent](strOnPrefix + evtName[_DYN_TYPE], handlerRef);
            result = true;
          }
        }
        return result;
      }
      function _doUnregister(target, events, evtName, unRegFn) {
        var idx = events[_DYN_LENGTH];
        while (idx--) {
          var theEvent = events[idx];
          if (theEvent) {
            if (!evtName.ns || evtName.ns === theEvent.evtName.ns) {
              if (!unRegFn || unRegFn(theEvent)) {
                _doDetach(target, theEvent.evtName, theEvent[_DYN_HANDLER], theEvent.capture);
                events[_DYN_SPLICE](idx, 1);
              }
            }
          }
        }
      }
      function _unregisterEvents(target, evtName, unRegFn) {
        if (evtName[_DYN_TYPE]) {
          _doUnregister(target, _getRegisteredEvents(target, evtName[_DYN_TYPE]), evtName, unRegFn);
        } else {
          var eventCache = elmNodeData.get(target, strEvents, {});
          objForEachKey(eventCache, function(evtType, events) {
            _doUnregister(target, events, evtName, unRegFn);
          });
          if (objKeys(eventCache)[_DYN_LENGTH] === 0) {
            elmNodeData.kill(target, strEvents);
          }
        }
      }
      function mergeEvtNamespace(theNamespace, namespaces) {
        var newNamespaces;
        if (namespaces) {
          if (isArray(namespaces)) {
            newNamespaces = [theNamespace].concat(namespaces);
          } else {
            newNamespaces = [theNamespace, namespaces];
          }
          newNamespaces = _getEvtNamespace("xx", newNamespaces).ns[_DYN_SPLIT](".");
        } else {
          newNamespaces = theNamespace;
        }
        return newNamespaces;
      }
      function eventOn(target, eventName, handlerRef, evtNamespace, useCapture) {
        var _a2;
        if (useCapture === void 0) {
          useCapture = false;
        }
        var result = false;
        if (target) {
          try {
            var evtName = _getEvtNamespace(eventName, evtNamespace);
            result = _doAttach(target, evtName, handlerRef, useCapture);
            if (result && elmNodeData.accept(target)) {
              var registeredEvent = (_a2 = {
                guid: _guid++,
                evtName
              }, _a2[_DYN_HANDLER] = handlerRef, _a2.capture = useCapture, _a2);
              _getRegisteredEvents(target, evtName.type)[_DYN_PUSH](registeredEvent);
            }
          } catch (e) {
          }
        }
        return result;
      }
      function eventOff(target, eventName, handlerRef, evtNamespace, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        if (target) {
          try {
            var evtName_1 = _getEvtNamespace(eventName, evtNamespace);
            var found_1 = false;
            _unregisterEvents(target, evtName_1, function(regEvent) {
              if (evtName_1.ns && !handlerRef || regEvent[_DYN_HANDLER] === handlerRef) {
                found_1 = true;
                return true;
              }
              return false;
            });
            if (!found_1) {
              _doDetach(target, evtName_1, handlerRef, useCapture);
            }
          } catch (e) {
          }
        }
      }
      function attachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        return eventOn(obj, eventNameWithoutOn, handlerRef, null, useCapture);
      }
      function detachEvent(obj, eventNameWithoutOn, handlerRef, useCapture) {
        if (useCapture === void 0) {
          useCapture = false;
        }
        eventOff(obj, eventNameWithoutOn, handlerRef, null, useCapture);
      }
      function addEventHandler(eventName, callback, evtNamespace) {
        var result = false;
        var w = getWindow();
        if (w) {
          result = eventOn(w, eventName, callback, evtNamespace);
          result = eventOn(w["body"], eventName, callback, evtNamespace) || result;
        }
        var doc = getDocument();
        if (doc) {
          result = eventOn(doc, eventName, callback, evtNamespace) || result;
        }
        return result;
      }
      function removeEventHandler(eventName, callback, evtNamespace) {
        var w = getWindow();
        if (w) {
          eventOff(w, eventName, callback, evtNamespace);
          eventOff(w["body"], eventName, callback, evtNamespace);
        }
        var doc = getDocument();
        if (doc) {
          eventOff(doc, eventName, callback, evtNamespace);
        }
      }
      function _addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && events[_DYN_LENGTH] > 0) {
          arrForEach(events, function(name2) {
            if (name2) {
              if (!excludeEvents || arrIndexOf(excludeEvents, name2) === -1) {
                added = addEventHandler(name2, listener, evtNamespace) || added;
              }
            }
          });
        }
        return added;
      }
      function addEventListeners(events, listener, excludeEvents, evtNamespace) {
        var added = false;
        if (listener && events && isArray(events)) {
          added = _addEventListeners(events, listener, excludeEvents, evtNamespace);
          if (!added && excludeEvents && excludeEvents[_DYN_LENGTH] > 0) {
            added = _addEventListeners(events, listener, null, evtNamespace);
          }
        }
        return added;
      }
      function removeEventListeners(events, listener, evtNamespace) {
        if (events && isArray(events)) {
          arrForEach(events, function(name2) {
            if (name2) {
              removeEventHandler(name2, listener, evtNamespace);
            }
          });
        }
      }
      function addPageUnloadEventListener(listener, excludeEvents, evtNamespace) {
        return addEventListeners([strBeforeUnload, strUnload, strPageHide], listener, excludeEvents, evtNamespace);
      }
      function removePageUnloadEventListener(listener, evtNamespace) {
        removeEventListeners([strBeforeUnload, strUnload, strPageHide], listener, evtNamespace);
      }
      function addPageHideEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
          var doc = getDocument();
          if (listener && doc && doc.visibilityState === "hidden") {
            listener(evt);
          }
        }
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        var pageUnloadAdded = _addEventListeners([strPageHide], listener, excludeEvents, newNamespaces);
        if (!excludeEvents || arrIndexOf(excludeEvents, strVisibilityChangeEvt) === -1) {
          pageUnloadAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageUnloadAdded;
        }
        if (!pageUnloadAdded && excludeEvents) {
          pageUnloadAdded = addPageHideEventListener(listener, null, evtNamespace);
        }
        return pageUnloadAdded;
      }
      function removePageHideEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageHideNamespace, evtNamespace);
        removeEventListeners([strPageHide], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
      }
      function addPageShowEventListener(listener, excludeEvents, evtNamespace) {
        function _handlePageVisibility(evt) {
          var doc = getDocument();
          if (listener && doc && doc.visibilityState === "visible") {
            listener(evt);
          }
        }
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        var pageShowAdded = _addEventListeners([strPageShow], listener, excludeEvents, newNamespaces);
        pageShowAdded = _addEventListeners([strVisibilityChangeEvt], _handlePageVisibility, excludeEvents, newNamespaces) || pageShowAdded;
        if (!pageShowAdded && excludeEvents) {
          pageShowAdded = addPageShowEventListener(listener, null, evtNamespace);
        }
        return pageShowAdded;
      }
      function removePageShowEventListener(listener, evtNamespace) {
        var newNamespaces = mergeEvtNamespace(strPageShowNamespace, evtNamespace);
        removeEventListeners([strPageShow], listener, newNamespaces);
        removeEventListeners([strVisibilityChangeEvt], null, newNamespaces);
      }
      var _cookieMgrs = null;
      var _canUseCookies;
      var Undefined = strShimUndefined;
      function newGuid() {
        var uuid2 = generateW3CId();
        return uuid2[_DYN_SUBSTRING](0, 8) + "-" + uuid2[_DYN_SUBSTRING](8, 12) + "-" + uuid2[_DYN_SUBSTRING](12, 16) + "-" + uuid2[_DYN_SUBSTRING](16, 20) + "-" + uuid2[_DYN_SUBSTRING](20);
      }
      function perfNow() {
        var perf = getPerformance();
        if (perf && perf.now) {
          return perf.now();
        }
        return dateNow();
      }
      function generateW3CId() {
        var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        var oct = STR_EMPTY, tmp;
        for (var a = 0; a < 4; a++) {
          tmp = random32();
          oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
        }
        var clockSequenceHi = hexValues[8 + (random32() & 3) | 0];
        return oct[_DYN_SUBSTR](0, 8) + oct[_DYN_SUBSTR](9, 4) + "4" + oct[_DYN_SUBSTR](13, 3) + clockSequenceHi + oct[_DYN_SUBSTR](16, 3) + oct[_DYN_SUBSTR](19, 12);
      }
      var CoreUtils = {
        _canUseCookies: void 0,
        isTypeof,
        isUndefined,
        isNullOrUndefined,
        hasOwnProperty,
        isFunction,
        isObject,
        isDate,
        isArray,
        isError,
        isString,
        isNumber,
        isBoolean,
        toISOString,
        arrForEach,
        arrIndexOf,
        arrMap,
        arrReduce,
        strTrim,
        objCreate: objCreateFn,
        objKeys,
        objDefineAccessors,
        addEventHandler,
        dateNow,
        isIE,
        disableCookies,
        newGuid,
        perfNow,
        newId,
        randomValue,
        random32,
        mwcRandomSeed,
        mwcRandom32,
        generateW3CId
      };
      var EventHelper = {
        Attach: attachEvent,
        AttachEvent: attachEvent,
        Detach: detachEvent,
        DetachEvent: detachEvent
      };
      function _legacyCookieMgr(config, logger) {
        var cookieMgr = _gblCookieMgr(config, logger);
        var legacyCanUseCookies = CoreUtils._canUseCookies;
        if (_cookieMgrs === null) {
          _cookieMgrs = [];
          _canUseCookies = legacyCanUseCookies;
          objDefineAccessors(CoreUtils, "_canUseCookies", function() {
            return _canUseCookies;
          }, function(value) {
            _canUseCookies = value;
            arrForEach(_cookieMgrs, function(mgr) {
              mgr[_DYN_SET_ENABLED](value);
            });
          });
        }
        if (arrIndexOf(_cookieMgrs, cookieMgr) === -1) {
          _cookieMgrs[_DYN_PUSH](cookieMgr);
        }
        if (isBoolean(legacyCanUseCookies)) {
          cookieMgr[_DYN_SET_ENABLED](legacyCanUseCookies);
        }
        if (isBoolean(_canUseCookies)) {
          cookieMgr[_DYN_SET_ENABLED](_canUseCookies);
        }
        return cookieMgr;
      }
      function disableCookies() {
        _legacyCookieMgr()[_DYN_SET_ENABLED](false);
      }
      function canUseCookies(logger) {
        return _legacyCookieMgr(null, logger).isEnabled();
      }
      function getCookie(logger, name2) {
        return _legacyCookieMgr(null, logger).get(name2);
      }
      function setCookie(logger, name2, value, domain) {
        _legacyCookieMgr(null, logger).set(name2, value, null, domain);
      }
      function deleteCookie(logger, name2) {
        return _legacyCookieMgr(null, logger).del(name2);
      }
      var TRACE_PARENT_REGEX = /^([\da-f]{2})-([\da-f]{32})-([\da-f]{16})-([\da-f]{2})(-[^\s]*)?$/;
      var DEFAULT_VERSION = "00";
      var INVALID_VERSION = "ff";
      var INVALID_TRACE_ID = "00000000000000000000000000000000";
      var INVALID_SPAN_ID = "0000000000000000";
      var SAMPLED_FLAG = 1;
      function _isValid(value, len, invalidValue) {
        if (value && value[_DYN_LENGTH] === len && value !== invalidValue) {
          return !!value.match(/^[\da-f]*$/);
        }
        return false;
      }
      function _formatValue(value, len, defValue) {
        if (_isValid(value, len)) {
          return value;
        }
        return defValue;
      }
      function _formatFlags(value) {
        if (isNaN(value) || value < 0 || value > 255) {
          value = 1;
        }
        var result = value.toString(16);
        while (result[_DYN_LENGTH] < 2) {
          result = "0" + result;
        }
        return result;
      }
      function createTraceParent(traceId, spanId, flags, version2) {
        var _a2;
        return _a2 = {}, _a2[_DYN_VERSION] = _isValid(version2, 2, INVALID_VERSION) ? version2 : DEFAULT_VERSION, _a2[_DYN_TRACE_ID] = isValidTraceId(traceId) ? traceId : generateW3CId(), _a2.spanId = isValidSpanId(spanId) ? spanId : generateW3CId()[_DYN_SUBSTR](0, 16), _a2.traceFlags = flags >= 0 && flags <= 255 ? flags : 1, _a2;
      }
      function parseTraceParent(value) {
        var _a2;
        if (!value) {
          return null;
        }
        if (isArray(value)) {
          value = value[0] || "";
        }
        if (!value || !isString(value) || value[_DYN_LENGTH] > 8192) {
          return null;
        }
        var match = TRACE_PARENT_REGEX.exec(strTrim(value));
        if (!match || match[1] === INVALID_VERSION || match[2] === INVALID_TRACE_ID || match[3] === INVALID_SPAN_ID) {
          return null;
        }
        return _a2 = {}, _a2[_DYN_VERSION] = match[1], _a2[_DYN_TRACE_ID] = match[2], _a2[_DYN_SPAN_ID] = match[3], _a2[_DYN_TRACE_FLAGS] = parseInt(match[4], 16), _a2;
      }
      function isValidTraceId(value) {
        return _isValid(value, 32, INVALID_TRACE_ID);
      }
      function isValidSpanId(value) {
        return _isValid(value, 16, INVALID_SPAN_ID);
      }
      function isValidTraceParent(value) {
        if (!value || !_isValid(value[_DYN_VERSION], 2, INVALID_VERSION) || !_isValid(value[_DYN_TRACE_ID], 32, INVALID_TRACE_ID) || !_isValid(value[_DYN_SPAN_ID], 16, INVALID_SPAN_ID) || !_isValid(_formatFlags(value[_DYN_TRACE_FLAGS]), 2)) {
          return false;
        }
        return true;
      }
      function isSampledFlag(value) {
        if (isValidTraceParent(value)) {
          return (value[_DYN_TRACE_FLAGS] & SAMPLED_FLAG) === SAMPLED_FLAG;
        }
        return false;
      }
      function formatTraceParent(value) {
        if (value) {
          var flags = _formatFlags(value[_DYN_TRACE_FLAGS]);
          if (!_isValid(flags, 2)) {
            flags = "01";
          }
          var version2 = value[_DYN_VERSION] || DEFAULT_VERSION;
          if (version2 !== "00" && version2 !== "ff") {
            version2 = DEFAULT_VERSION;
          }
          return "".concat(version2, "-").concat(_formatValue(value.traceId, 32, INVALID_TRACE_ID), "-").concat(_formatValue(value.spanId, 16, INVALID_SPAN_ID), "-").concat(flags);
        }
        return "";
      }
      function findW3cTraceParent() {
        var name2 = "traceparent";
        var traceParent = parseTraceParent(findMetaTag(name2));
        if (!traceParent) {
          traceParent = parseTraceParent(findNamedServerTiming(name2));
        }
        return traceParent;
      }
      var pluginStateData = createElmNodeData("plugin");
      function _getPluginState(plugin) {
        return pluginStateData.get(plugin, "state", {}, true);
      }
      function initializePlugins(processContext, extensions2) {
        var initPlugins = [];
        var lastPlugin = null;
        var proxy = processContext[_DYN_GET_NEXT]();
        var pluginState;
        while (proxy) {
          var thePlugin = proxy[_DYN_GET_PLUGIN]();
          if (thePlugin) {
            if (lastPlugin && isFunction(lastPlugin[_DYN_SET_NEXT_PLUGIN]) && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
              lastPlugin[_DYN_SET_NEXT_PLUGIN](thePlugin);
            }
            var isInitialized = false;
            if (isFunction(thePlugin[_DYN_IS_INITIALIZED])) {
              isInitialized = thePlugin[_DYN_IS_INITIALIZED]();
            } else {
              pluginState = _getPluginState(thePlugin);
              isInitialized = pluginState[_DYN_IS_INITIALIZED];
            }
            if (!isInitialized) {
              initPlugins[_DYN_PUSH](thePlugin);
            }
            lastPlugin = thePlugin;
            proxy = proxy[_DYN_GET_NEXT]();
          }
        }
        arrForEach(initPlugins, function(thePlugin2) {
          var core = processContext[STR_CORE]();
          thePlugin2[_DYN_INITIALIZE](processContext.getCfg(), core, extensions2, processContext[_DYN_GET_NEXT]());
          pluginState = _getPluginState(thePlugin2);
          if (!thePlugin2[STR_CORE] && !pluginState[STR_CORE]) {
            pluginState[STR_CORE] = core;
          }
          pluginState[_DYN_IS_INITIALIZED] = true;
          delete pluginState[_DYN_TEARDOWN];
        });
      }
      function sortPlugins(plugins) {
        return plugins.sort(function(extA, extB) {
          var result = 0;
          if (extB) {
            var bHasProcess = isFunction(extB[STR_PROCESS_TELEMETRY]);
            if (isFunction(extA[STR_PROCESS_TELEMETRY])) {
              result = bHasProcess ? extA[STR_PRIORITY] - extB[STR_PRIORITY] : 1;
            } else if (bHasProcess) {
              result = -1;
            }
          } else {
            result = extA ? 1 : -1;
          }
          return result;
        });
      }
      function unloadComponents(components, unloadCtx, unloadState, asyncCallback) {
        var idx = 0;
        function _doUnload() {
          while (idx < components[_DYN_LENGTH]) {
            var component = components[idx++];
            if (component) {
              var func = component._doUnload || component[_DYN__DO_TEARDOWN];
              if (isFunction(func)) {
                if (func[_DYN_CALL](component, unloadCtx, unloadState, _doUnload) === true) {
                  return true;
                }
              }
            }
          }
        }
        return _doUnload();
      }
      function createDistributedTraceContext(parentCtx) {
        var trace = {};
        return {
          getName: function() {
            return trace[_DYN_NAME];
          },
          setName: function(newValue) {
            parentCtx && parentCtx.setName(newValue);
            trace[_DYN_NAME] = newValue;
          },
          getTraceId: function() {
            return trace[_DYN_TRACE_ID];
          },
          setTraceId: function(newValue) {
            parentCtx && parentCtx.setTraceId(newValue);
            if (isValidTraceId(newValue)) {
              trace[_DYN_TRACE_ID] = newValue;
            }
          },
          getSpanId: function() {
            return trace[_DYN_SPAN_ID];
          },
          setSpanId: function(newValue) {
            parentCtx && parentCtx.setSpanId(newValue);
            if (isValidSpanId(newValue)) {
              trace[_DYN_SPAN_ID] = newValue;
            }
          },
          getTraceFlags: function() {
            return trace[_DYN_TRACE_FLAGS];
          },
          setTraceFlags: function(newTraceFlags) {
            parentCtx && parentCtx.setTraceFlags(newTraceFlags);
            trace[_DYN_TRACE_FLAGS] = newTraceFlags;
          }
        };
      }
      var strTelemetryPluginChain = "TelemetryPluginChain";
      var strHasRunFlags = "_hasRun";
      var strGetTelCtx = "_getTelCtx";
      var _chainId = 0;
      function _getNextProxyStart(proxy, core, startAt) {
        while (proxy) {
          if (proxy[_DYN_GET_PLUGIN]() === startAt) {
            return proxy;
          }
          proxy = proxy[_DYN_GET_NEXT]();
        }
        return createTelemetryProxyChain([startAt], core[_DYN_CONFIG] || {}, core);
      }
      function _createInternalContext(telemetryChain, config, core, startAt) {
        var _nextProxy = null;
        var _onComplete = [];
        if (startAt !== null) {
          _nextProxy = startAt ? _getNextProxyStart(telemetryChain, core, startAt) : telemetryChain;
        }
        var context = {
          _next: _moveNext,
          ctx: {
            core: function() {
              return core;
            },
            diagLog: function() {
              return safeGetLogger(core, config);
            },
            getCfg: function() {
              return config;
            },
            getExtCfg: _getExtCfg,
            getConfig: _getConfig,
            hasNext: function() {
              return !!_nextProxy;
            },
            getNext: function() {
              return _nextProxy;
            },
            setNext: function(nextPlugin) {
              _nextProxy = nextPlugin;
            },
            iterate: _iterateChain,
            onComplete: _addOnComplete
          }
        };
        function _addOnComplete(onComplete, that) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          if (onComplete) {
            _onComplete[_DYN_PUSH]({
              func: onComplete,
              self: !isUndefined(that) ? that : context.ctx,
              args
            });
          }
        }
        function _moveNext() {
          var nextProxy = _nextProxy;
          _nextProxy = nextProxy ? nextProxy[_DYN_GET_NEXT]() : null;
          if (!nextProxy) {
            var onComplete = _onComplete;
            if (onComplete && onComplete[_DYN_LENGTH] > 0) {
              arrForEach(onComplete, function(completeDetails) {
                try {
                  completeDetails.func[_DYN_CALL](completeDetails.self, completeDetails.args);
                } catch (e) {
                  _throwInternal(core[_DYN_LOGGER], 2, 73, "Unexpected Exception during onComplete - " + dumpObj(e));
                }
              });
              _onComplete = [];
            }
          }
          return nextProxy;
        }
        function _getExtCfg(identifier, defaultValue, mergeDefault) {
          if (defaultValue === void 0) {
            defaultValue = {};
          }
          if (mergeDefault === void 0) {
            mergeDefault = 0;
          }
          var theConfig;
          if (config) {
            var extConfig = config[STR_EXTENSION_CONFIG];
            if (extConfig && identifier) {
              theConfig = extConfig[identifier];
            }
          }
          if (!theConfig) {
            theConfig = defaultValue;
          } else if (isObject(defaultValue)) {
            if (mergeDefault !== 0) {
              var newConfig_1 = objExtend(true, defaultValue, theConfig);
              if (config && mergeDefault === 2) {
                objForEachKey(defaultValue, function(field) {
                  if (isNullOrUndefined(newConfig_1[field])) {
                    var cfgValue = config[field];
                    if (!isNullOrUndefined(cfgValue)) {
                      newConfig_1[field] = cfgValue;
                    }
                  }
                });
              }
              theConfig = newConfig_1;
            }
          }
          return theConfig;
        }
        function _getConfig(identifier, field, defaultValue) {
          if (defaultValue === void 0) {
            defaultValue = false;
          }
          var theValue;
          var extConfig = _getExtCfg(identifier, null);
          if (extConfig && !isNullOrUndefined(extConfig[field])) {
            theValue = extConfig[field];
          } else if (config && !isNullOrUndefined(config[field])) {
            theValue = config[field];
          }
          return !isNullOrUndefined(theValue) ? theValue : defaultValue;
        }
        function _iterateChain(cb) {
          var nextPlugin;
          while (!!(nextPlugin = context._next())) {
            var plugin = nextPlugin[_DYN_GET_PLUGIN]();
            if (plugin) {
              cb(plugin);
            }
          }
        }
        return context;
      }
      function createProcessTelemetryContext(telemetryChain, config, core, startAt) {
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(env2) {
          var nextPlugin = internalContext._next();
          nextPlugin && nextPlugin[STR_PROCESS_TELEMETRY](env2, context);
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config, core, startAt2);
          }
          return createProcessTelemetryContext(plugins || context[_DYN_GET_NEXT](), config, core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUnloadContext(telemetryChain, core, startAt) {
        var config = core[_DYN_CONFIG] || {};
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(unloadState) {
          var nextPlugin = internalContext._next();
          nextPlugin && nextPlugin.unload(context, unloadState);
          return !nextPlugin;
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config, core, startAt2);
          }
          return createProcessTelemetryUnloadContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createProcessTelemetryUpdateContext(telemetryChain, core, startAt) {
        var config = core[_DYN_CONFIG] || {};
        var internalContext = _createInternalContext(telemetryChain, config, core, startAt);
        var context = internalContext.ctx;
        function _processNext(updateState) {
          return context.iterate(function(plugin) {
            if (isFunction(plugin[_DYN_UPDATE])) {
              plugin[_DYN_UPDATE](context, updateState);
            }
          });
        }
        function _createNew(plugins, startAt2) {
          if (plugins === void 0) {
            plugins = null;
          }
          if (isArray(plugins)) {
            plugins = createTelemetryProxyChain(plugins, config, core, startAt2);
          }
          return createProcessTelemetryUpdateContext(plugins || context[_DYN_GET_NEXT](), core, startAt2);
        }
        context[_DYN_PROCESS_NEXT] = _processNext;
        context[_DYN_CREATE_NEW] = _createNew;
        return context;
      }
      function createTelemetryProxyChain(plugins, config, core, startAt) {
        var firstProxy = null;
        var add = startAt ? false : true;
        if (isArray(plugins) && plugins[_DYN_LENGTH] > 0) {
          var lastProxy_1 = null;
          arrForEach(plugins, function(thePlugin) {
            if (!add && startAt === thePlugin) {
              add = true;
            }
            if (add && thePlugin && isFunction(thePlugin[STR_PROCESS_TELEMETRY])) {
              var newProxy = createTelemetryPluginProxy(thePlugin, config, core);
              if (!firstProxy) {
                firstProxy = newProxy;
              }
              if (lastProxy_1) {
                lastProxy_1._setNext(newProxy);
              }
              lastProxy_1 = newProxy;
            }
          });
        }
        if (startAt && !firstProxy) {
          return createTelemetryProxyChain([startAt], config, core);
        }
        return firstProxy;
      }
      function createTelemetryPluginProxy(plugin, config, core) {
        var nextProxy = null;
        var hasProcessTelemetry = isFunction(plugin[STR_PROCESS_TELEMETRY]);
        var hasSetNext = isFunction(plugin[_DYN_SET_NEXT_PLUGIN]);
        var chainId;
        if (plugin) {
          chainId = plugin[_DYN_IDENTIFIER] + "-" + plugin[STR_PRIORITY] + "-" + _chainId++;
        } else {
          chainId = "Unknown-0-" + _chainId++;
        }
        var proxyChain = {
          getPlugin: function() {
            return plugin;
          },
          getNext: function() {
            return nextProxy;
          },
          processTelemetry: _processTelemetry,
          unload: _unloadPlugin,
          update: _updatePlugin,
          _id: chainId,
          _setNext: function(nextPlugin) {
            nextProxy = nextPlugin;
          }
        };
        function _getTelCtx() {
          var itemCtx;
          if (plugin && isFunction(plugin[strGetTelCtx])) {
            itemCtx = plugin[strGetTelCtx]();
          }
          if (!itemCtx) {
            itemCtx = createProcessTelemetryContext(proxyChain, config, core);
          }
          return itemCtx;
        }
        function _processChain(itemCtx, processPluginFn, name2, details, isAsync) {
          var hasRun = false;
          var identifier = plugin ? plugin[_DYN_IDENTIFIER] : strTelemetryPluginChain;
          var hasRunContext = itemCtx[strHasRunFlags];
          if (!hasRunContext) {
            hasRunContext = itemCtx[strHasRunFlags] = {};
          }
          itemCtx.setNext(nextProxy);
          if (plugin) {
            doPerf(itemCtx[STR_CORE](), function() {
              return identifier + ":" + name2;
            }, function() {
              hasRunContext[chainId] = true;
              try {
                var nextId = nextProxy ? nextProxy._id : STR_EMPTY;
                if (nextId) {
                  hasRunContext[nextId] = false;
                }
                hasRun = processPluginFn(itemCtx);
              } catch (error) {
                var hasNextRun = nextProxy ? hasRunContext[nextProxy._id] : true;
                if (hasNextRun) {
                  hasRun = true;
                }
                if (!nextProxy || !hasNextRun) {
                  _throwInternal(itemCtx[_DYN_DIAG_LOG](), 1, 73, "Plugin [" + identifier + "] failed during " + name2 + " - " + dumpObj(error) + ", run flags: " + dumpObj(hasRunContext));
                }
              }
            }, details, isAsync);
          }
          return hasRun;
        }
        function _processTelemetry(env2, itemCtx) {
          itemCtx = itemCtx || _getTelCtx();
          function _callProcessTelemetry(itemCtx2) {
            if (!plugin || !hasProcessTelemetry) {
              return false;
            }
            var pluginState = _getPluginState(plugin);
            if (pluginState[_DYN_TEARDOWN] || pluginState[STR_DISABLED]) {
              return false;
            }
            if (hasSetNext) {
              plugin[_DYN_SET_NEXT_PLUGIN](nextProxy);
            }
            plugin[STR_PROCESS_TELEMETRY](env2, itemCtx2);
            return true;
          }
          if (!_processChain(itemCtx, _callProcessTelemetry, "processTelemetry", function() {
            return { item: env2 };
          }, !env2.sync)) {
            itemCtx[_DYN_PROCESS_NEXT](env2);
          }
        }
        function _unloadPlugin(unloadCtx, unloadState) {
          function _callTeardown() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === unloadCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                pluginState[STR_CORE] = null;
                pluginState[_DYN_TEARDOWN] = true;
                pluginState[_DYN_IS_INITIALIZED] = false;
                if (plugin[_DYN_TEARDOWN] && plugin[_DYN_TEARDOWN](unloadCtx, unloadState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(unloadCtx, _callTeardown, "unload", function() {
          }, unloadState[_DYN_IS_ASYNC])) {
            unloadCtx[_DYN_PROCESS_NEXT](unloadState);
          }
        }
        function _updatePlugin(updateCtx, updateState) {
          function _callUpdate() {
            var hasRun = false;
            if (plugin) {
              var pluginState = _getPluginState(plugin);
              var pluginCore = plugin[STR_CORE] || pluginState[STR_CORE];
              if (plugin && (!pluginCore || pluginCore === updateCtx.core()) && !pluginState[_DYN_TEARDOWN]) {
                if (plugin[_DYN_UPDATE] && plugin[_DYN_UPDATE](updateCtx, updateState) === true) {
                  hasRun = true;
                }
              }
            }
            return hasRun;
          }
          if (!_processChain(updateCtx, _callUpdate, "update", function() {
          }, false)) {
            updateCtx[_DYN_PROCESS_NEXT](updateState);
          }
        }
        return objFreeze(proxyChain);
      }
      var ProcessTelemetryContext = (
        /** @class */
        function() {
          function ProcessTelemetryContext2(pluginChain, config, core, startAt) {
            var _self = this;
            var context = createProcessTelemetryContext(pluginChain, config, core, startAt);
            proxyFunctions(_self, context, objKeys(context));
          }
          return ProcessTelemetryContext2;
        }()
      );
      var ChannelControllerPriority = 500;
      var ChannelValidationMessage = "Channel has invalid priority - ";
      function _addChannelQueue(channelQueue, queue, core) {
        if (queue && isArray(queue) && queue[_DYN_LENGTH] > 0) {
          queue = queue.sort(function(a, b) {
            return a[STR_PRIORITY] - b[STR_PRIORITY];
          });
          arrForEach(queue, function(queueItem) {
            if (queueItem[STR_PRIORITY] < ChannelControllerPriority) {
              throwError(ChannelValidationMessage + queueItem[_DYN_IDENTIFIER]);
            }
          });
          channelQueue[_DYN_PUSH]({
            queue: objFreeze(queue),
            chain: createTelemetryProxyChain(queue, core[_DYN_CONFIG], core)
          });
        }
      }
      function createChannelControllerPlugin(channelQueue, core) {
        function _getTelCtx() {
          return createProcessTelemetryContext(null, core[_DYN_CONFIG], core, null);
        }
        function _processChannelQueue(theChannels, itemCtx, processFn, onComplete) {
          var waiting = theChannels ? theChannels[_DYN_LENGTH] + 1 : 1;
          function _runChainOnComplete() {
            waiting--;
            if (waiting === 0) {
              onComplete && onComplete();
              onComplete = null;
            }
          }
          if (waiting > 0) {
            arrForEach(theChannels, function(channels) {
              if (channels && channels.queue[_DYN_LENGTH] > 0) {
                var channelChain = channels.chain;
                var chainCtx = itemCtx[_DYN_CREATE_NEW](channelChain);
                chainCtx[_DYN_ON_COMPLETE](_runChainOnComplete);
                processFn(chainCtx);
              } else {
                waiting--;
              }
            });
          }
          _runChainOnComplete();
        }
        function _doUpdate(updateCtx, updateState) {
          var theUpdateState = updateState || {
            reason: 0
          };
          _processChannelQueue(channelQueue, updateCtx, function(chainCtx) {
            chainCtx[_DYN_PROCESS_NEXT](theUpdateState);
          }, function() {
            updateCtx[_DYN_PROCESS_NEXT](theUpdateState);
          });
          return true;
        }
        function _doTeardown(unloadCtx, unloadState) {
          var theUnloadState = unloadState || {
            reason: 0,
            isAsync: false
          };
          _processChannelQueue(channelQueue, unloadCtx, function(chainCtx) {
            chainCtx[_DYN_PROCESS_NEXT](theUnloadState);
          }, function() {
            unloadCtx[_DYN_PROCESS_NEXT](theUnloadState);
            isInitialized = false;
          });
          return true;
        }
        function _getChannel(pluginIdentifier) {
          var thePlugin = null;
          if (channelQueue && channelQueue[_DYN_LENGTH] > 0) {
            arrForEach(channelQueue, function(channels) {
              if (channels && channels.queue[_DYN_LENGTH] > 0) {
                arrForEach(channels.queue, function(ext) {
                  if (ext[_DYN_IDENTIFIER] === pluginIdentifier) {
                    thePlugin = ext;
                    return -1;
                  }
                });
                if (thePlugin) {
                  return -1;
                }
              }
            });
          }
          return thePlugin;
        }
        var isInitialized = false;
        var channelController = {
          identifier: "ChannelControllerPlugin",
          priority: ChannelControllerPriority,
          initialize: function(config, core2, extensions2, pluginChain) {
            isInitialized = true;
            arrForEach(channelQueue, function(channels) {
              if (channels && channels.queue[_DYN_LENGTH] > 0) {
                initializePlugins(createProcessTelemetryContext(channels.chain, config, core2), extensions2);
              }
            });
          },
          isInitialized: function() {
            return isInitialized;
          },
          processTelemetry: function(item, itemCtx) {
            _processChannelQueue(channelQueue, itemCtx || _getTelCtx(), function(chainCtx) {
              chainCtx[_DYN_PROCESS_NEXT](item);
            }, function() {
              itemCtx[_DYN_PROCESS_NEXT](item);
            });
          },
          update: _doUpdate,
          pause: function() {
            _processChannelQueue(channelQueue, _getTelCtx(), function(chainCtx) {
              chainCtx.iterate(function(plugin) {
                plugin.pause && plugin.pause();
              });
            }, null);
          },
          resume: function() {
            _processChannelQueue(channelQueue, _getTelCtx(), function(chainCtx) {
              chainCtx.iterate(function(plugin) {
                plugin.resume && plugin.resume();
              });
            }, null);
          },
          teardown: _doTeardown,
          getChannel: _getChannel,
          flush: function(isAsync, callBack, sendReason, cbTimeout) {
            var waiting = 1;
            var doneIterating = false;
            var cbTimer = null;
            cbTimeout = cbTimeout || 5e3;
            function doCallback() {
              waiting--;
              if (doneIterating && waiting === 0) {
                if (cbTimer) {
                  clearTimeout(cbTimer);
                  cbTimer = null;
                }
                callBack && callBack(doneIterating);
                callBack = null;
              }
            }
            _processChannelQueue(channelQueue, _getTelCtx(), function(chainCtx) {
              chainCtx.iterate(function(plugin) {
                if (plugin[_DYN_FLUSH]) {
                  waiting++;
                  var handled_1 = false;
                  if (!plugin[_DYN_FLUSH](isAsync, function() {
                    handled_1 = true;
                    doCallback();
                  }, sendReason)) {
                    if (!handled_1) {
                      if (isAsync && cbTimer == null) {
                        cbTimer = setTimeout(function() {
                          cbTimer = null;
                          doCallback();
                        }, cbTimeout);
                      } else {
                        doCallback();
                      }
                    }
                  }
                }
              });
            }, function() {
              doneIterating = true;
              doCallback();
            });
            return true;
          },
          _setQueue: function(queue) {
            channelQueue = queue;
          }
        };
        return channelController;
      }
      function createChannelQueues(channels, extensions2, core) {
        var channelQueue = [];
        if (channels) {
          arrForEach(channels, function(queue) {
            return _addChannelQueue(channelQueue, queue, core);
          });
        }
        if (extensions2) {
          var extensionQueue_1 = [];
          arrForEach(extensions2, function(plugin) {
            if (plugin[STR_PRIORITY] > ChannelControllerPriority) {
              extensionQueue_1[_DYN_PUSH](plugin);
            }
          });
          _addChannelQueue(channelQueue, extensionQueue_1, core);
        }
        return channelQueue;
      }
      function createUnloadHandlerContainer() {
        var handlers = [];
        function _addHandler(handler) {
          if (handler) {
            handlers[_DYN_PUSH](handler);
          }
        }
        function _runHandlers(unloadCtx, unloadState) {
          arrForEach(handlers, function(handler) {
            try {
              handler(unloadCtx, unloadState);
            } catch (e) {
              _throwInternal(unloadCtx[_DYN_DIAG_LOG](), 2, 73, "Unexpected error calling unload handler - " + dumpObj(e));
            }
          });
          handlers = [];
        }
        return {
          add: _addHandler,
          run: _runHandlers
        };
      }
      var strGetPlugin = "getPlugin";
      var BaseTelemetryPlugin = (
        /** @class */
        function() {
          function BaseTelemetryPlugin2() {
            var _self = this;
            var _isinitialized;
            var _rootCtx;
            var _nextPlugin;
            var _unloadHandlerContainer;
            var _hooks;
            _initDefaults();
            dynamicProto(BaseTelemetryPlugin2, _self, function(_self2) {
              _self2[_DYN_INITIALIZE] = function(config, core, extensions2, pluginChain) {
                _setDefaults(config, core, pluginChain);
                _isinitialized = true;
              };
              _self2[_DYN_TEARDOWN] = function(unloadCtx, unloadState) {
                var _a2;
                var core = _self2[STR_CORE];
                if (!core || unloadCtx && core !== unloadCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var unloadDone = false;
                var theUnloadCtx = unloadCtx || createProcessTelemetryUnloadContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUnloadState = unloadState || (_a2 = {
                  reason: 0
                }, _a2[_DYN_IS_ASYNC] = false, _a2);
                function _unloadCallback() {
                  if (!unloadDone) {
                    unloadDone = true;
                    _unloadHandlerContainer.run(theUnloadCtx, unloadState);
                    var oldHooks = _hooks;
                    _hooks = [];
                    arrForEach(oldHooks, function(fn) {
                      fn.rm();
                    });
                    if (result === true) {
                      theUnloadCtx[_DYN_PROCESS_NEXT](theUnloadState);
                    }
                    _initDefaults();
                  }
                }
                if (!_self2[_DYN__DO_TEARDOWN] || _self2[_DYN__DO_TEARDOWN](theUnloadCtx, theUnloadState, _unloadCallback) !== true) {
                  _unloadCallback();
                } else {
                  result = true;
                }
                return result;
              };
              _self2[_DYN_UPDATE] = function(updateCtx, updateState) {
                var core = _self2[STR_CORE];
                if (!core || updateCtx && core !== updateCtx[STR_CORE]()) {
                  return;
                }
                var result;
                var updateDone = false;
                var theUpdateCtx = updateCtx || createProcessTelemetryUpdateContext(null, core, _nextPlugin && _nextPlugin[strGetPlugin] ? _nextPlugin[strGetPlugin]() : _nextPlugin);
                var theUpdateState = updateState || {
                  reason: 0
                };
                function _updateCallback() {
                  if (!updateDone) {
                    updateDone = true;
                    _setDefaults(theUpdateCtx.getCfg(), theUpdateCtx.core(), theUpdateCtx[_DYN_GET_NEXT]());
                  }
                }
                if (!_self2._doUpdate || _self2._doUpdate(theUpdateCtx, theUpdateState, _updateCallback) !== true) {
                  _updateCallback();
                } else {
                  result = true;
                }
                return result;
              };
              _self2._addHook = function(hooks) {
                if (hooks) {
                  if (isArray(hooks)) {
                    _hooks = _hooks.concat(hooks);
                  } else {
                    _hooks[_DYN_PUSH](hooks);
                  }
                }
              };
              proxyFunctionAs(_self2, "_addUnloadCb", function() {
                return _unloadHandlerContainer;
              }, "add");
            });
            _self[_DYN_DIAG_LOG] = function(itemCtx) {
              return _getTelCtx(itemCtx)[_DYN_DIAG_LOG]();
            };
            _self[_DYN_IS_INITIALIZED] = function() {
              return _isinitialized;
            };
            _self.setInitialized = function(isInitialized) {
              _isinitialized = isInitialized;
            };
            _self[_DYN_SET_NEXT_PLUGIN] = function(next) {
              _nextPlugin = next;
            };
            _self[_DYN_PROCESS_NEXT] = function(env2, itemCtx) {
              if (itemCtx) {
                itemCtx[_DYN_PROCESS_NEXT](env2);
              } else if (_nextPlugin && isFunction(_nextPlugin[STR_PROCESS_TELEMETRY])) {
                _nextPlugin[STR_PROCESS_TELEMETRY](env2, null);
              }
            };
            _self._getTelCtx = _getTelCtx;
            function _getTelCtx(currentCtx) {
              if (currentCtx === void 0) {
                currentCtx = null;
              }
              var itemCtx = currentCtx;
              if (!itemCtx) {
                var rootCtx = _rootCtx || createProcessTelemetryContext(null, {}, _self[STR_CORE]);
                if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin[strGetPlugin]);
                } else {
                  itemCtx = rootCtx[_DYN_CREATE_NEW](null, _nextPlugin);
                }
              }
              return itemCtx;
            }
            function _setDefaults(config, core, pluginChain) {
              if (config) {
                setValue(config, STR_EXTENSION_CONFIG, [], null, isNullOrUndefined);
              }
              if (!pluginChain && core) {
                pluginChain = core[_DYN_GET_PROCESS_TEL_CONT0]()[_DYN_GET_NEXT]();
              }
              var nextPlugin = _nextPlugin;
              if (_nextPlugin && _nextPlugin[strGetPlugin]) {
                nextPlugin = _nextPlugin[strGetPlugin]();
              }
              _self[STR_CORE] = core;
              _rootCtx = createProcessTelemetryContext(pluginChain, config, core, nextPlugin);
            }
            function _initDefaults() {
              _isinitialized = false;
              _self[STR_CORE] = null;
              _rootCtx = null;
              _nextPlugin = null;
              _hooks = [];
              _unloadHandlerContainer = createUnloadHandlerContainer();
            }
          }
          BaseTelemetryPlugin2.__ieDyn = 1;
          return BaseTelemetryPlugin2;
        }()
      );
      var TelemetryInitializerPlugin = (
        /** @class */
        function(_super) {
          __extendsFn(TelemetryInitializerPlugin2, _super);
          function TelemetryInitializerPlugin2() {
            var _this = _super.call(this) || this;
            _this.identifier = "TelemetryInitializerPlugin";
            _this.priority = 199;
            var _id;
            var _initializers;
            _initDefaults();
            dynamicProto(TelemetryInitializerPlugin2, _this, function(_self, _base) {
              _self.addTelemetryInitializer = function(telemetryInitializer) {
                var theInitializer = {
                  id: _id++,
                  fn: telemetryInitializer
                };
                _initializers[_DYN_PUSH](theInitializer);
                var handler = {
                  remove: function() {
                    arrForEach(_initializers, function(initializer, idx) {
                      if (initializer.id === theInitializer.id) {
                        _initializers[_DYN_SPLICE](idx, 1);
                        return -1;
                      }
                    });
                  }
                };
                return handler;
              };
              _self[STR_PROCESS_TELEMETRY] = function(item, itemCtx) {
                var doNotSendItem = false;
                var telemetryInitializersCount = _initializers[_DYN_LENGTH];
                for (var i = 0; i < telemetryInitializersCount; ++i) {
                  var telemetryInitializer = _initializers[i];
                  if (telemetryInitializer) {
                    try {
                      if (telemetryInitializer.fn[_DYN_APPLY](null, [item]) === false) {
                        doNotSendItem = true;
                        break;
                      }
                    } catch (e) {
                      _throwInternal(itemCtx[_DYN_DIAG_LOG](), 1, 64, "One of telemetry initializers failed, telemetry item will not be sent: " + getExceptionName(e), { exception: dumpObj(e) }, true);
                    }
                  }
                }
                if (!doNotSendItem) {
                  _self[_DYN_PROCESS_NEXT](item, itemCtx);
                }
              };
              _self[_DYN__DO_TEARDOWN] = function() {
                _initDefaults();
              };
            });
            function _initDefaults() {
              _id = 0;
              _initializers = [];
            }
            return _this;
          }
          TelemetryInitializerPlugin2.__ieDyn = 1;
          return TelemetryInitializerPlugin2;
        }(BaseTelemetryPlugin)
      );
      var strValidationError = "Plugins must provide initialize method";
      var strNotificationManager = "_notificationManager";
      var strSdkUnloadingError = "SDK is still unloading...";
      var strSdkNotInitialized = "SDK is not initialized";
      var defaultInitConfig = {
        loggingLevelConsole: 1
      };
      function _createPerfManager(core, notificationMgr) {
        return new PerfManager(notificationMgr);
      }
      function _validateExtensions(logger, channelPriority, allExtensions) {
        var _a2;
        var coreExtensions = [];
        var extPriorities = {};
        arrForEach(allExtensions, function(ext) {
          if (isNullOrUndefined(ext) || isNullOrUndefined(ext[_DYN_INITIALIZE])) {
            throwError(strValidationError);
          }
          var extPriority = ext[STR_PRIORITY];
          var identifier = ext[_DYN_IDENTIFIER];
          if (ext && extPriority) {
            if (!isNullOrUndefined(extPriorities[extPriority])) {
              _warnToConsole(logger, "Two extensions have same priority #" + extPriority + " - " + extPriorities[extPriority] + ", " + identifier);
            } else {
              extPriorities[extPriority] = identifier;
            }
          }
          if (!extPriority || extPriority < channelPriority) {
            coreExtensions[_DYN_PUSH](ext);
          }
        });
        return _a2 = {
          all: allExtensions
        }, _a2[STR_CORE] = coreExtensions, _a2;
      }
      function _isPluginPresent(thePlugin, plugins) {
        var exists = false;
        arrForEach(plugins, function(plugin) {
          if (plugin === thePlugin) {
            exists = true;
            return -1;
          }
        });
        return exists;
      }
      function _createDummyNotificationManager() {
        var _a2;
        return objCreateFn((_a2 = {}, _a2[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
        }, _a2[_DYN_REMOVE_NOTIFICATION_2] = function(listener) {
        }, _a2[STR_EVENTS_SENT] = function(events) {
        }, _a2[STR_EVENTS_DISCARDED] = function(events, reason) {
        }, _a2[STR_EVENTS_SEND_REQUEST] = function(sendReason, isAsync) {
        }, _a2));
      }
      var BaseCore = (
        /** @class */
        function() {
          function BaseCore2() {
            var _config;
            var _isInitialized;
            var _eventQueue;
            var _notificationManager;
            var _perfManager;
            var _cfgPerfManager;
            var _cookieManager;
            var _pluginChain;
            var _configExtensions;
            var _coreExtensions;
            var _channelControl;
            var _channelConfig;
            var _channelQueue;
            var _isUnloading;
            var _telemetryInitializerPlugin;
            var _internalLogsEventName;
            var _evtNamespace;
            var _unloadHandlers;
            var _debugListener2;
            var _traceCtx;
            var _internalLogPoller = 0;
            var _forceStopInternalLogPoller = false;
            dynamicProto(BaseCore2, this, function(_self) {
              _initDefaults();
              _self[_DYN_IS_INITIALIZED] = function() {
                return _isInitialized;
              };
              _self[_DYN_INITIALIZE] = function(config, extensions2, logger, notificationManager) {
                if (_isUnloading) {
                  throwError(strSdkUnloadingError);
                }
                if (_self[_DYN_IS_INITIALIZED]()) {
                  throwError("Core should not be initialized more than once");
                }
                _config = config || {};
                _self[_DYN_CONFIG] = _config;
                if (isNullOrUndefined(config[_DYN_INSTRUMENTATION_KEY])) {
                  throwError("Please provide instrumentation key");
                }
                _notificationManager = notificationManager;
                _self[strNotificationManager] = notificationManager;
                _initDebugListener();
                _initPerfManager();
                _initExtConfig();
                if (logger) {
                  _self[_DYN_LOGGER] = logger;
                }
                var cfgExtensions = getSetValue(_config, STR_EXTENSIONS, []);
                _configExtensions = [];
                _configExtensions[_DYN_PUSH].apply(_configExtensions, __spreadArrayFn(__spreadArrayFn([], extensions2, false), cfgExtensions));
                _channelConfig = getSetValue(_config, STR_CHANNELS, []);
                _initPluginChain(null);
                if (!_channelQueue || _channelQueue[_DYN_LENGTH] === 0) {
                  throwError("No " + STR_CHANNELS + " available");
                }
                _isInitialized = true;
                _self.releaseQueue();
              };
              _self.getTransmissionControls = function() {
                var controls = [];
                if (_channelQueue) {
                  arrForEach(_channelQueue, function(channels) {
                    controls[_DYN_PUSH](channels.queue);
                  });
                }
                return objFreeze(controls);
              };
              _self.track = function(telemetryItem) {
                telemetryItem.iKey = telemetryItem.iKey || _config[_DYN_INSTRUMENTATION_KEY];
                telemetryItem[_DYN_TIME] = telemetryItem[_DYN_TIME] || toISOString(/* @__PURE__ */ new Date());
                telemetryItem.ver = telemetryItem.ver || "4.0";
                if (!_isUnloading && _self[_DYN_IS_INITIALIZED]()) {
                  _createTelCtx()[_DYN_PROCESS_NEXT](telemetryItem);
                } else {
                  _eventQueue[_DYN_PUSH](telemetryItem);
                }
              };
              _self[_DYN_GET_PROCESS_TEL_CONT0] = _createTelCtx;
              _self[_DYN_GET_NOTIFY_MGR] = function() {
                if (!_notificationManager) {
                  _notificationManager = _createDummyNotificationManager();
                  _self[strNotificationManager] = _notificationManager;
                }
                return _notificationManager;
              };
              _self[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
                if (_notificationManager) {
                  _notificationManager[_DYN_ADD_NOTIFICATION_LIS1](listener);
                }
              };
              _self[_DYN_REMOVE_NOTIFICATION_2] = function(listener) {
                if (_notificationManager) {
                  _notificationManager[_DYN_REMOVE_NOTIFICATION_2](listener);
                }
              };
              _self.getCookieMgr = function() {
                if (!_cookieManager) {
                  _cookieManager = createCookieMgr(_config, _self[_DYN_LOGGER]);
                }
                return _cookieManager;
              };
              _self.setCookieMgr = function(cookieMgr) {
                _cookieManager = cookieMgr;
              };
              _self[STR_GET_PERF_MGR] = function() {
                if (!_perfManager && !_cfgPerfManager) {
                  if (getCfgValue(_config.enablePerfMgr)) {
                    var createPerfMgr = getCfgValue(_config[STR_CREATE_PERF_MGR]);
                    if (isFunction(createPerfMgr)) {
                      _cfgPerfManager = createPerfMgr(_self, _self[_DYN_GET_NOTIFY_MGR]());
                    }
                  }
                }
                return _perfManager || _cfgPerfManager || getGblPerfMgr();
              };
              _self.setPerfMgr = function(perfMgr) {
                _perfManager = perfMgr;
              };
              _self.eventCnt = function() {
                return _eventQueue[_DYN_LENGTH];
              };
              _self.releaseQueue = function() {
                if (_isInitialized && _eventQueue[_DYN_LENGTH] > 0) {
                  var eventQueue = _eventQueue;
                  _eventQueue = [];
                  arrForEach(eventQueue, function(event) {
                    _createTelCtx()[_DYN_PROCESS_NEXT](event);
                  });
                }
              };
              _self.pollInternalLogs = function(eventName) {
                _internalLogsEventName = eventName || null;
                _forceStopInternalLogPoller = false;
                if (_internalLogPoller) {
                  clearInterval(_internalLogPoller);
                  _internalLogPoller = null;
                }
                return _startInternalLogTimer(true);
              };
              function _startInternalLogTimer(alwaysStart) {
                if (!_internalLogPoller && !_forceStopInternalLogPoller) {
                  var shouldStart = alwaysStart || _self[_DYN_LOGGER] && _self[_DYN_LOGGER].queue[_DYN_LENGTH] > 0;
                  if (shouldStart) {
                    var interval = getCfgValue(_config.diagnosticLogInterval);
                    if (!interval || !(interval > 0)) {
                      interval = 1e4;
                    }
                    _internalLogPoller = setInterval(function() {
                      clearInterval(_internalLogPoller);
                      _internalLogPoller = 0;
                      _flushInternalLogs();
                    }, interval);
                  }
                }
                return _internalLogPoller;
              }
              _self[_DYN_STOP_POLLING_INTERNA3] = function() {
                _forceStopInternalLogPoller = true;
                if (_internalLogPoller) {
                  clearInterval(_internalLogPoller);
                  _internalLogPoller = 0;
                  _flushInternalLogs();
                }
              };
              proxyFunctions(_self, function() {
                return _telemetryInitializerPlugin;
              }, ["addTelemetryInitializer"]);
              _self.unload = function(isAsync, unloadComplete, cbTimeout) {
                var _a2;
                if (isAsync === void 0) {
                  isAsync = true;
                }
                if (!_isInitialized) {
                  throwError(strSdkNotInitialized);
                }
                if (_isUnloading) {
                  throwError(strSdkUnloadingError);
                }
                var unloadState = (_a2 = {
                  reason: 50
                }, _a2[_DYN_IS_ASYNC] = isAsync, _a2.flushComplete = false, _a2);
                var processUnloadCtx = createProcessTelemetryUnloadContext(_getPluginChain(), _self);
                processUnloadCtx[_DYN_ON_COMPLETE](function() {
                  _initDefaults();
                  unloadComplete && unloadComplete(unloadState);
                }, _self);
                function _doUnload(flushComplete) {
                  unloadState.flushComplete = flushComplete;
                  _isUnloading = true;
                  _unloadHandlers.run(processUnloadCtx, unloadState);
                  _self[_DYN_STOP_POLLING_INTERNA3]();
                  processUnloadCtx[_DYN_PROCESS_NEXT](unloadState);
                }
                _flushInternalLogs();
                if (!_flushChannels(isAsync, _doUnload, 6, cbTimeout)) {
                  _doUnload(false);
                }
              };
              _self[_DYN_GET_PLUGIN] = _getPlugin;
              _self.addPlugin = function(plugin, replaceExisting, isAsync, addCb) {
                if (!plugin) {
                  addCb && addCb(false);
                  _logOrThrowError(strValidationError);
                  return;
                }
                var existingPlugin = _getPlugin(plugin[_DYN_IDENTIFIER]);
                if (existingPlugin && !replaceExisting) {
                  addCb && addCb(false);
                  _logOrThrowError("Plugin [" + plugin[_DYN_IDENTIFIER] + "] is already loaded!");
                  return;
                }
                var updateState = {
                  reason: 16
                };
                function _addPlugin(removed) {
                  _configExtensions[_DYN_PUSH](plugin);
                  updateState.added = [plugin];
                  _initPluginChain(updateState);
                  addCb && addCb(true);
                }
                if (existingPlugin) {
                  var removedPlugins_1 = [existingPlugin.plugin];
                  var unloadState = {
                    reason: 2,
                    isAsync: !!isAsync
                  };
                  _removePlugins(removedPlugins_1, unloadState, function(removed) {
                    if (!removed) {
                      addCb && addCb(false);
                    } else {
                      updateState.removed = removedPlugins_1;
                      updateState.reason |= 32;
                      _addPlugin();
                    }
                  });
                } else {
                  _addPlugin();
                }
              };
              _self.evtNamespace = function() {
                return _evtNamespace;
              };
              _self[_DYN_FLUSH] = _flushChannels;
              _self.getTraceCtx = function(createNew) {
                if (!_traceCtx) {
                  _traceCtx = createDistributedTraceContext();
                }
                return _traceCtx;
              };
              _self.setTraceCtx = function(traceCtx) {
                _traceCtx = traceCtx || null;
              };
              proxyFunctionAs(_self, "addUnloadCb", function() {
                return _unloadHandlers;
              }, "add");
              function _initDefaults() {
                _isInitialized = false;
                _config = objExtend(true, {}, defaultInitConfig);
                _self[_DYN_CONFIG] = _config;
                _self[_DYN_LOGGER] = new DiagnosticLogger(_config);
                _self[_DYN__EXTENSIONS] = [];
                _telemetryInitializerPlugin = new TelemetryInitializerPlugin();
                _eventQueue = [];
                _notificationManager = null;
                _perfManager = null;
                _cfgPerfManager = null;
                _cookieManager = null;
                _pluginChain = null;
                _coreExtensions = null;
                _configExtensions = [];
                _channelControl = null;
                _channelConfig = null;
                _channelQueue = null;
                _isUnloading = false;
                _internalLogsEventName = null;
                _evtNamespace = createUniqueNamespace("AIBaseCore", true);
                _unloadHandlers = createUnloadHandlerContainer();
                _traceCtx = null;
              }
              function _createTelCtx() {
                var theCtx = createProcessTelemetryContext(_getPluginChain(), _config, _self);
                theCtx[_DYN_ON_COMPLETE](_startInternalLogTimer);
                return theCtx;
              }
              function _initPluginChain(updateState) {
                var theExtensions = _validateExtensions(_self[_DYN_LOGGER], ChannelControllerPriority, _configExtensions);
                _coreExtensions = theExtensions[STR_CORE];
                _pluginChain = null;
                var allExtensions = theExtensions.all;
                _channelQueue = objFreeze(createChannelQueues(_channelConfig, allExtensions, _self));
                if (_channelControl) {
                  var idx = arrIndexOf(allExtensions, _channelControl);
                  if (idx !== -1) {
                    allExtensions[_DYN_SPLICE](idx, 1);
                  }
                  idx = arrIndexOf(_coreExtensions, _channelControl);
                  if (idx !== -1) {
                    _coreExtensions[_DYN_SPLICE](idx, 1);
                  }
                  _channelControl._setQueue(_channelQueue);
                } else {
                  _channelControl = createChannelControllerPlugin(_channelQueue, _self);
                }
                allExtensions[_DYN_PUSH](_channelControl);
                _coreExtensions[_DYN_PUSH](_channelControl);
                _self[_DYN__EXTENSIONS] = sortPlugins(allExtensions);
                _channelControl[_DYN_INITIALIZE](_config, _self, allExtensions);
                var initCtx = _createTelCtx();
                initializePlugins(initCtx, allExtensions);
                _self[_DYN__EXTENSIONS] = objFreeze(sortPlugins(_coreExtensions || [])).slice();
                if (updateState) {
                  _doUpdate(updateState);
                }
              }
              function _getPlugin(pluginIdentifier) {
                var _a2;
                var theExt = null;
                var thePlugin = null;
                arrForEach(_self[_DYN__EXTENSIONS], function(ext) {
                  if (ext[_DYN_IDENTIFIER] === pluginIdentifier && ext !== _channelControl && ext !== _telemetryInitializerPlugin) {
                    thePlugin = ext;
                    return -1;
                  }
                });
                if (!thePlugin && _channelControl) {
                  thePlugin = _channelControl.getChannel(pluginIdentifier);
                }
                if (thePlugin) {
                  theExt = (_a2 = {
                    plugin: thePlugin
                  }, _a2[_DYN_SET_ENABLED] = function(enabled) {
                    _getPluginState(thePlugin)[STR_DISABLED] = !enabled;
                  }, _a2.isEnabled = function() {
                    var pluginState = _getPluginState(thePlugin);
                    return !pluginState[_DYN_TEARDOWN] && !pluginState[STR_DISABLED];
                  }, _a2.remove = function(isAsync, removeCb) {
                    var _a3;
                    if (isAsync === void 0) {
                      isAsync = true;
                    }
                    var pluginsToRemove = [thePlugin];
                    var unloadState = (_a3 = {
                      reason: 1
                    }, _a3[_DYN_IS_ASYNC] = isAsync, _a3);
                    _removePlugins(pluginsToRemove, unloadState, function(removed) {
                      if (removed) {
                        _initPluginChain({
                          reason: 32,
                          removed: pluginsToRemove
                        });
                      }
                      removeCb && removeCb(removed);
                    });
                  }, _a2);
                }
                return theExt;
              }
              function _getPluginChain() {
                if (!_pluginChain) {
                  var extensions2 = (_coreExtensions || []).slice();
                  if (arrIndexOf(extensions2, _telemetryInitializerPlugin) === -1) {
                    extensions2[_DYN_PUSH](_telemetryInitializerPlugin);
                  }
                  _pluginChain = createTelemetryProxyChain(sortPlugins(extensions2), _config, _self);
                }
                return _pluginChain;
              }
              function _removePlugins(thePlugins, unloadState, removeComplete) {
                if (thePlugins && thePlugins[_DYN_LENGTH] > 0) {
                  var unloadChain = createTelemetryProxyChain(thePlugins, _config, _self);
                  var unloadCtx = createProcessTelemetryUnloadContext(unloadChain, _self);
                  unloadCtx[_DYN_ON_COMPLETE](function() {
                    var removed = false;
                    var newConfigExtensions = [];
                    arrForEach(_configExtensions, function(plugin, idx) {
                      if (!_isPluginPresent(plugin, thePlugins)) {
                        newConfigExtensions[_DYN_PUSH](plugin);
                      } else {
                        removed = true;
                      }
                    });
                    _configExtensions = newConfigExtensions;
                    var newChannelConfig = [];
                    if (_channelConfig) {
                      arrForEach(_channelConfig, function(queue, idx) {
                        var newQueue = [];
                        arrForEach(queue, function(channel) {
                          if (!_isPluginPresent(channel, thePlugins)) {
                            newQueue[_DYN_PUSH](channel);
                          } else {
                            removed = true;
                          }
                        });
                        newChannelConfig[_DYN_PUSH](newQueue);
                      });
                      _channelConfig = newChannelConfig;
                    }
                    removeComplete && removeComplete(removed);
                    _startInternalLogTimer();
                  });
                  unloadCtx[_DYN_PROCESS_NEXT](unloadState);
                } else {
                  removeComplete(false);
                }
              }
              function _flushInternalLogs() {
                if (_self[_DYN_LOGGER] && _self[_DYN_LOGGER].queue) {
                  var queue = _self[_DYN_LOGGER].queue.slice(0);
                  _self[_DYN_LOGGER].queue[_DYN_LENGTH] = 0;
                  arrForEach(queue, function(logMessage2) {
                    var _a2;
                    var item = (_a2 = {}, _a2[_DYN_NAME] = _internalLogsEventName ? _internalLogsEventName : "InternalMessageId: " + logMessage2[_DYN_MESSAGE_ID], _a2.iKey = getCfgValue(_config[_DYN_INSTRUMENTATION_KEY]), _a2.time = toISOString(/* @__PURE__ */ new Date()), _a2.baseType = _InternalLogMessage.dataType, _a2.baseData = { message: logMessage2[_DYN_MESSAGE] }, _a2);
                    _self.track(item);
                  });
                }
              }
              function _flushChannels(isAsync, callBack, sendReason, cbTimeout) {
                if (_channelControl) {
                  return _channelControl[_DYN_FLUSH](isAsync, callBack, sendReason || 6, cbTimeout);
                }
                callBack && callBack(false);
                return true;
              }
              function _initDebugListener() {
                var disableDbgExt = getCfgValue(_config.disableDbgExt);
                if (disableDbgExt === true && _debugListener2) {
                  _notificationManager[_DYN_REMOVE_NOTIFICATION_2](_debugListener2);
                  _debugListener2 = null;
                }
                if (_notificationManager && !_debugListener2 && disableDbgExt !== true) {
                  _debugListener2 = getDebugListener(_config);
                  _notificationManager[_DYN_ADD_NOTIFICATION_LIS1](_debugListener2);
                }
              }
              function _initPerfManager() {
                var enablePerfMgr = getCfgValue(_config.enablePerfMgr);
                if (!enablePerfMgr && _cfgPerfManager) {
                  _cfgPerfManager = null;
                }
                if (enablePerfMgr) {
                  getSetValue(_config, STR_CREATE_PERF_MGR, _createPerfManager);
                }
              }
              function _initExtConfig() {
                var extConfig = getSetValue(_config, STR_EXTENSION_CONFIG, {});
                extConfig.NotificationManager = _notificationManager;
              }
              function _doUpdate(updateState) {
                var updateCtx = createProcessTelemetryUpdateContext(_getPluginChain(), _self);
                updateCtx[_DYN_ON_COMPLETE](_startInternalLogTimer);
                if (!_self._updateHook || _self._updateHook(updateCtx, updateState) !== true) {
                  updateCtx[_DYN_PROCESS_NEXT](updateState);
                }
              }
              function _logOrThrowError(message) {
                var logger = _self[_DYN_LOGGER];
                if (logger) {
                  _throwInternal(logger, 2, 73, message);
                  _startInternalLogTimer();
                } else {
                  throwError(message);
                }
              }
            });
          }
          BaseCore2.__ieDyn = 1;
          return BaseCore2;
        }()
      );
      function _runListeners(listeners, name2, isAsync, callback) {
        arrForEach(listeners, function(listener) {
          if (listener && listener[name2]) {
            if (isAsync) {
              setTimeout(function() {
                return callback(listener);
              }, 0);
            } else {
              try {
                callback(listener);
              } catch (e) {
              }
            }
          }
        });
      }
      var NotificationManager = (
        /** @class */
        function() {
          function NotificationManager2(config) {
            this.listeners = [];
            var perfEvtsSendAll = !!(config || {}).perfEvtsSendAll;
            dynamicProto(NotificationManager2, this, function(_self) {
              _self[_DYN_ADD_NOTIFICATION_LIS1] = function(listener) {
                _self.listeners[_DYN_PUSH](listener);
              };
              _self[_DYN_REMOVE_NOTIFICATION_2] = function(listener) {
                var index = arrIndexOf(_self[_DYN_LISTENERS], listener);
                while (index > -1) {
                  _self.listeners[_DYN_SPLICE](index, 1);
                  index = arrIndexOf(_self[_DYN_LISTENERS], listener);
                }
              };
              _self[STR_EVENTS_SENT] = function(events) {
                _runListeners(_self[_DYN_LISTENERS], STR_EVENTS_SENT, true, function(listener) {
                  listener[STR_EVENTS_SENT](events);
                });
              };
              _self[STR_EVENTS_DISCARDED] = function(events, reason) {
                _runListeners(_self[_DYN_LISTENERS], STR_EVENTS_DISCARDED, true, function(listener) {
                  listener[STR_EVENTS_DISCARDED](events, reason);
                });
              };
              _self[STR_EVENTS_SEND_REQUEST] = function(sendReason, isAsync) {
                _runListeners(_self[_DYN_LISTENERS], STR_EVENTS_SEND_REQUEST, isAsync, function(listener) {
                  listener[STR_EVENTS_SEND_REQUEST](sendReason, isAsync);
                });
              };
              _self[STR_PERF_EVENT] = function(perfEvent) {
                if (perfEvent) {
                  if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT]()) {
                    _runListeners(_self[_DYN_LISTENERS], STR_PERF_EVENT, false, function(listener) {
                      if (perfEvent[_DYN_IS_ASYNC]) {
                        setTimeout(function() {
                          return listener[STR_PERF_EVENT](perfEvent);
                        }, 0);
                      } else {
                        listener[STR_PERF_EVENT](perfEvent);
                      }
                    });
                  }
                }
              };
            });
          }
          NotificationManager2.__ieDyn = 1;
          return NotificationManager2;
        }()
      );
      var AppInsightsCore = (
        /** @class */
        function(_super) {
          __extendsFn(AppInsightsCore2, _super);
          function AppInsightsCore2() {
            var _this = _super.call(this) || this;
            dynamicProto(AppInsightsCore2, _this, function(_self, _base) {
              _self[_DYN_INITIALIZE] = function(config, extensions2, logger, notificationManager) {
                _base[_DYN_INITIALIZE](config, extensions2, logger || new DiagnosticLogger(config), notificationManager || new NotificationManager(config));
              };
              _self.track = function(telemetryItem) {
                doPerf(_self[STR_GET_PERF_MGR](), function() {
                  return "AppInsightsCore:track";
                }, function() {
                  if (telemetryItem === null) {
                    _notifyInvalidEvent(telemetryItem);
                    throwError("Invalid telemetry item");
                  }
                  _validateTelemetryItem(telemetryItem);
                  _base.track(telemetryItem);
                }, function() {
                  return { item: telemetryItem };
                }, !telemetryItem.sync);
              };
              function _validateTelemetryItem(telemetryItem) {
                if (isNullOrUndefined(telemetryItem[_DYN_NAME])) {
                  _notifyInvalidEvent(telemetryItem);
                  throwError("telemetry name required");
                }
              }
              function _notifyInvalidEvent(telemetryItem) {
                var manager = _self[_DYN_GET_NOTIFY_MGR]();
                if (manager) {
                  manager[STR_EVENTS_DISCARDED]([telemetryItem], 2);
                }
              }
            });
            return _this;
          }
          AppInsightsCore2.__ieDyn = 1;
          return AppInsightsCore2;
        }(BaseCore)
      );
      var _a;
      var FAILED = "Failed";
      var FAILED_MONITOR_AJAX = FAILED + "MonitorAjax";
      var TRACK = "Track";
      var START = "Start";
      var STOP = "Stop";
      var EVENT = "Event";
      var AUTH_CONTEXT = "AuthContext";
      var EXCEPTION = "Exception";
      var LOCAL = "Local";
      var SESSION = "Session";
      var STORAGE = "Storage";
      var BROWSER = "Browser";
      var CANNOT = "Cannot";
      var BUFFER = "Buffer";
      var INSTRUMENTATION_KEY = "InstrumentationKey";
      var LoggingSeverity = createEnumStyle({
        CRITICAL: 1,
        WARNING: 2
      });
      var _InternalMessageId = createEnumStyle((_a = {}, _a[BROWSER + "DoesNotSupport" + LOCAL + STORAGE] = 0, _a[BROWSER + CANNOT + "Read" + LOCAL + STORAGE] = 1, _a[BROWSER + CANNOT + "Read" + SESSION + STORAGE] = 2, _a[BROWSER + CANNOT + "Write" + LOCAL + STORAGE] = 3, _a[BROWSER + CANNOT + "Write" + SESSION + STORAGE] = 4, _a[BROWSER + FAILED + "RemovalFrom" + LOCAL + STORAGE] = 5, _a[BROWSER + FAILED + "RemovalFrom" + SESSION + STORAGE] = 6, _a[CANNOT + "SendEmptyTelemetry"] = 7, _a.ClientPerformanceMathError = 8, _a["ErrorParsingAI" + SESSION + "Cookie"] = 9, _a.ErrorPVCalc = 10, _a[EXCEPTION + "WhileLoggingError"] = 11, _a[FAILED + "AddingTelemetryTo" + BUFFER] = 12, _a[FAILED_MONITOR_AJAX + "Abort"] = 13, _a[FAILED_MONITOR_AJAX + "Dur"] = 14, _a[FAILED_MONITOR_AJAX + "Open"] = 15, _a[FAILED_MONITOR_AJAX + "RSC"] = 16, _a[FAILED_MONITOR_AJAX + "Send"] = 17, _a[FAILED_MONITOR_AJAX + "GetCorrelationHeader"] = 18, _a[FAILED + "ToAddHandlerForOnBeforeUnload"] = 19, _a[FAILED + "ToSendQueuedTelemetry"] = 20, _a[FAILED + "ToReportDataLoss"] = 21, _a["Flush" + FAILED] = 22, _a.MessageLimitPerPVExceeded = 23, _a.MissingRequiredFieldSpecification = 24, _a.NavigationTimingNotSupported = 25, _a.OnError = 26, _a[SESSION + "RenewalDateIsZero"] = 27, _a.SenderNotInitialized = 28, _a[START + TRACK + EVENT + FAILED] = 29, _a[STOP + TRACK + EVENT + FAILED] = 30, _a[START + TRACK + FAILED] = 31, _a[STOP + TRACK + FAILED] = 32, _a.TelemetrySampledAndNotSent = 33, _a[TRACK + EVENT + FAILED] = 34, _a[TRACK + EXCEPTION + FAILED] = 35, _a[TRACK + "Metric" + FAILED] = 36, _a[TRACK + "PV" + FAILED] = 37, _a[TRACK + "PV" + FAILED + "Calc"] = 38, _a[TRACK + "Trace" + FAILED] = 39, _a["Transmission" + FAILED] = 40, _a[FAILED + "ToSet" + STORAGE + BUFFER] = 41, _a[FAILED + "ToRestore" + STORAGE + BUFFER] = 42, _a.InvalidBackendResponse = 43, _a[FAILED + "ToFixDepricatedValues"] = 44, _a.InvalidDurationValue = 45, _a.TelemetryEnvelopeInvalid = 46, _a.CreateEnvelopeError = 47, _a[CANNOT + "SerializeObject"] = 48, _a[CANNOT + "SerializeObjectNonSerializable"] = 49, _a.CircularReferenceDetected = 50, _a["Clear" + AUTH_CONTEXT + FAILED] = 51, _a[EXCEPTION + "Truncated"] = 52, _a.IllegalCharsInName = 53, _a.ItemNotInArray = 54, _a.MaxAjaxPerPVExceeded = 55, _a.MessageTruncated = 56, _a.NameTooLong = 57, _a.SampleRateOutOfRange = 58, _a["Set" + AUTH_CONTEXT + FAILED] = 59, _a["Set" + AUTH_CONTEXT + FAILED + "AccountName"] = 60, _a.StringValueTooLong = 61, _a.StartCalledMoreThanOnce = 62, _a.StopCalledWithoutStart = 63, _a["TelemetryInitializer" + FAILED] = 64, _a.TrackArgumentsNotSpecified = 65, _a.UrlTooLong = 66, _a[SESSION + STORAGE + BUFFER + "Full"] = 67, _a[CANNOT + "AccessCookie"] = 68, _a.IdTooLong = 69, _a.InvalidEvent = 70, _a[FAILED_MONITOR_AJAX + "SetRequestHeader"] = 71, _a["Send" + BROWSER + "InfoOnUserInit"] = 72, _a["Plugin" + EXCEPTION] = 73, _a["Notification" + EXCEPTION] = 74, _a.SnippetScriptLoadFailure = 99, _a["Invalid" + INSTRUMENTATION_KEY] = 100, _a[CANNOT + "ParseAiBlobValue"] = 101, _a.InvalidContentBlob = 102, _a[TRACK + "PageAction" + EVENT + FAILED] = 103, _a[FAILED + "AddingCustomDefinedRequestContext"] = 104, _a["InMemory" + STORAGE + BUFFER + "Full"] = 105, _a[INSTRUMENTATION_KEY + "Deprecation"] = 106, _a));
      var aiInstrumentHooks = "_aiHooks";
      var cbNames = [
        "req",
        "rsp",
        "hkErr",
        "fnErr"
      ];
      function _arrLoop(arr, fn) {
        if (arr) {
          for (var lp = 0; lp < arr[_DYN_LENGTH]; lp++) {
            if (fn(arr[lp], lp)) {
              break;
            }
          }
        }
      }
      function _doCallbacks(hooks, callDetails, cbArgs, hookCtx, type) {
        if (type >= 0 && type <= 2) {
          _arrLoop(hooks, function(hook, idx) {
            var cbks = hook.cbks;
            var cb = cbks[cbNames[type]];
            if (cb) {
              callDetails.ctx = function() {
                var ctx = hookCtx[idx] = hookCtx[idx] || {};
                return ctx;
              };
              try {
                cb[_DYN_APPLY](callDetails.inst, cbArgs);
              } catch (err) {
                var orgEx = callDetails.err;
                try {
                  var hookErrorCb = cbks[cbNames[2]];
                  if (hookErrorCb) {
                    callDetails.err = err;
                    hookErrorCb[_DYN_APPLY](callDetails.inst, cbArgs);
                  }
                } catch (e) {
                } finally {
                  callDetails.err = orgEx;
                }
              }
            }
          });
        }
      }
      function _createFunctionHook(aiHook) {
        return function() {
          var _a2;
          var funcThis = this;
          var orgArgs = arguments;
          var hooks = aiHook.h;
          var funcArgs = (_a2 = {}, _a2[_DYN_NAME] = aiHook.n, _a2.inst = funcThis, _a2.ctx = null, _a2.set = _replaceArg, _a2);
          var hookCtx = [];
          var cbArgs = _createArgs([funcArgs], orgArgs);
          funcArgs.evt = getGlobalInst("event");
          function _createArgs(target, theArgs) {
            _arrLoop(theArgs, function(arg) {
              target[_DYN_PUSH](arg);
            });
            return target;
          }
          function _replaceArg(idx, value) {
            orgArgs = _createArgs([], orgArgs);
            orgArgs[idx] = value;
            cbArgs = _createArgs([funcArgs], orgArgs);
          }
          _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 0);
          var theFunc = aiHook.f;
          if (theFunc) {
            try {
              funcArgs.rslt = theFunc[_DYN_APPLY](funcThis, orgArgs);
            } catch (err) {
              funcArgs.err = err;
              _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 3);
              throw err;
            }
          }
          _doCallbacks(hooks, funcArgs, cbArgs, hookCtx, 1);
          return funcArgs.rslt;
        };
      }
      function _getOwner(target, name2, checkPrototype, checkParentProto) {
        var owner = null;
        if (target) {
          if (hasOwnProperty(target, name2)) {
            owner = target;
          } else if (checkPrototype) {
            owner = _getOwner(_getObjProto$1(target), name2, checkParentProto, false);
          }
        }
        return owner;
      }
      function InstrumentProto(target, funcName, callbacks) {
        if (target) {
          return InstrumentFunc(target[strShimPrototype], funcName, callbacks, false);
        }
        return null;
      }
      function InstrumentProtos(target, funcNames, callbacks) {
        if (target) {
          return InstrumentFuncs(target[strShimPrototype], funcNames, callbacks, false);
        }
        return null;
      }
      function _createInstrumentHook(owner, funcName, fn, callbacks) {
        var aiHook = fn && fn[aiInstrumentHooks];
        if (!aiHook) {
          aiHook = {
            i: 0,
            n: funcName,
            f: fn,
            h: []
          };
          var newFunc = _createFunctionHook(aiHook);
          newFunc[aiInstrumentHooks] = aiHook;
          owner[funcName] = newFunc;
        }
        var theHook = {
          id: aiHook.i,
          cbks: callbacks,
          rm: function() {
            var id = this.id;
            _arrLoop(aiHook.h, function(hook, idx) {
              if (hook.id === id) {
                aiHook.h[_DYN_SPLICE](idx, 1);
                return 1;
              }
            });
          }
        };
        aiHook.i++;
        aiHook.h[_DYN_PUSH](theHook);
        return theHook;
      }
      function InstrumentFunc(target, funcName, callbacks, checkPrototype, checkParentProto) {
        if (checkPrototype === void 0) {
          checkPrototype = true;
        }
        if (target && funcName && callbacks) {
          var owner = _getOwner(target, funcName, checkPrototype, checkParentProto);
          if (owner) {
            var fn = owner[funcName];
            if (typeof fn === strShimFunction) {
              return _createInstrumentHook(owner, funcName, fn, callbacks);
            }
          }
        }
        return null;
      }
      function InstrumentFuncs(target, funcNames, callbacks, checkPrototype, checkParentProto) {
        if (checkPrototype === void 0) {
          checkPrototype = true;
        }
        var hooks = null;
        _arrLoop(funcNames, function(funcName) {
          var hook = InstrumentFunc(target, funcName, callbacks, checkPrototype, checkParentProto);
          if (hook) {
            if (!hooks) {
              hooks = [];
            }
            hooks[_DYN_PUSH](hook);
          }
        });
        return hooks;
      }
      function InstrumentEvent(target, evtName, callbacks, checkPrototype, checkParentProto) {
        if (target && evtName && callbacks) {
          var owner = _getOwner(target, evtName, checkPrototype, checkParentProto) || target;
          if (owner) {
            return _createInstrumentHook(owner, evtName, owner[evtName], callbacks);
          }
        }
        return null;
      }
      exports3.AppInsightsCore = AppInsightsCore;
      exports3.BaseCore = BaseCore;
      exports3.BaseTelemetryPlugin = BaseTelemetryPlugin;
      exports3.CoreUtils = CoreUtils;
      exports3.DiagnosticLogger = DiagnosticLogger;
      exports3.EventHelper = EventHelper;
      exports3.EventsDiscardedReason = EventsDiscardedReason;
      exports3.InstrumentEvent = InstrumentEvent;
      exports3.InstrumentFunc = InstrumentFunc;
      exports3.InstrumentFuncs = InstrumentFuncs;
      exports3.InstrumentProto = InstrumentProto;
      exports3.InstrumentProtos = InstrumentProtos;
      exports3.LoggingSeverity = LoggingSeverity;
      exports3.MinChannelPriorty = MinChannelPriorty;
      exports3.NotificationManager = NotificationManager;
      exports3.PerfEvent = PerfEvent;
      exports3.PerfManager = PerfManager;
      exports3.ProcessTelemetryContext = ProcessTelemetryContext;
      exports3.Undefined = Undefined;
      exports3._InternalLogMessage = _InternalLogMessage;
      exports3._InternalMessageId = _InternalMessageId;
      exports3.__getRegisteredEvents = __getRegisteredEvents;
      exports3._legacyCookieMgr = _legacyCookieMgr;
      exports3._logInternalMessage = _logInternalMessage;
      exports3._throwInternal = _throwInternal;
      exports3._warnToConsole = _warnToConsole;
      exports3.addEventHandler = addEventHandler;
      exports3.addEventListeners = addEventListeners;
      exports3.addPageHideEventListener = addPageHideEventListener;
      exports3.addPageShowEventListener = addPageShowEventListener;
      exports3.addPageUnloadEventListener = addPageUnloadEventListener;
      exports3.areCookiesSupported = areCookiesSupported;
      exports3.arrForEach = arrForEach;
      exports3.arrIndexOf = arrIndexOf;
      exports3.arrMap = arrMap;
      exports3.arrReduce = arrReduce;
      exports3.attachEvent = attachEvent;
      exports3.canUseCookies = canUseCookies;
      exports3.createClassFromInterface = createClassFromInterface;
      exports3.createCookieMgr = createCookieMgr;
      exports3.createCustomDomEvent = createCustomDomEvent;
      exports3.createEnumMap = createEnumMap;
      exports3.createEnumStyle = createEnumStyle;
      exports3.createProcessTelemetryContext = createProcessTelemetryContext;
      exports3.createTraceParent = createTraceParent;
      exports3.createUniqueNamespace = createUniqueNamespace;
      exports3.createUnloadHandlerContainer = createUnloadHandlerContainer;
      exports3.createValueMap = createValueMap;
      exports3.dateNow = dateNow;
      exports3.deepFreeze = deepFreeze;
      exports3.deleteCookie = deleteCookie;
      exports3.detachEvent = detachEvent;
      exports3.disableCookies = disableCookies;
      exports3.dispatchEvent = dispatchEvent;
      exports3.doPerf = doPerf;
      exports3.dumpObj = dumpObj;
      exports3.eventOff = eventOff;
      exports3.eventOn = eventOn;
      exports3.findMetaTag = findMetaTag;
      exports3.findNamedServerTiming = findNamedServerTiming;
      exports3.findW3cTraceParent = findW3cTraceParent;
      exports3.formatTraceParent = formatTraceParent;
      exports3.generateW3CId = generateW3CId;
      exports3.getConsole = getConsole;
      exports3.getCookie = getCookie;
      exports3.getCrypto = getCrypto;
      exports3.getDebugExt = getDebugExt;
      exports3.getDebugListener = getDebugListener;
      exports3.getDocument = getDocument;
      exports3.getExceptionName = getExceptionName;
      exports3.getGblPerfMgr = getGblPerfMgr;
      exports3.getGlobal = getGlobal;
      exports3.getGlobalInst = getGlobalInst;
      exports3.getHistory = getHistory;
      exports3.getIEVersion = getIEVersion;
      exports3.getJSON = getJSON;
      exports3.getLocation = getLocation;
      exports3.getMsCrypto = getMsCrypto;
      exports3.getNavigator = getNavigator;
      exports3.getPerformance = getPerformance;
      exports3.getSetValue = getSetValue;
      exports3.getWindow = getWindow;
      exports3.hasDocument = hasDocument;
      exports3.hasHistory = hasHistory;
      exports3.hasJSON = hasJSON;
      exports3.hasNavigator = hasNavigator;
      exports3.hasOwnProperty = hasOwnProperty;
      exports3.hasWindow = hasWindow;
      exports3.initializePlugins = initializePlugins;
      exports3.isArray = isArray;
      exports3.isBeaconsSupported = isBeaconsSupported;
      exports3.isBoolean = isBoolean;
      exports3.isDate = isDate;
      exports3.isError = isError;
      exports3.isFetchSupported = isFetchSupported;
      exports3.isFunction = isFunction;
      exports3.isIE = isIE;
      exports3.isNotNullOrUndefined = isNotNullOrUndefined;
      exports3.isNotTruthy = isNotTruthy;
      exports3.isNotUndefined = isNotUndefined;
      exports3.isNullOrUndefined = isNullOrUndefined;
      exports3.isNumber = isNumber;
      exports3.isObject = isObject;
      exports3.isPlainObject = isPlainObject;
      exports3.isReactNative = isReactNative;
      exports3.isSafari = isSafari;
      exports3.isSampledFlag = isSampledFlag;
      exports3.isString = isString;
      exports3.isSymbol = isSymbol;
      exports3.isTruthy = isTruthy;
      exports3.isTypeof = isTypeof;
      exports3.isUndefined = isUndefined;
      exports3.isValidSpanId = isValidSpanId;
      exports3.isValidTraceId = isValidTraceId;
      exports3.isValidTraceParent = isValidTraceParent;
      exports3.isXhrSupported = isXhrSupported;
      exports3.mergeEvtNamespace = mergeEvtNamespace;
      exports3.mwcRandom32 = mwcRandom32;
      exports3.mwcRandomSeed = mwcRandomSeed;
      exports3.newGuid = newGuid;
      exports3.newId = newId;
      exports3.normalizeJsName = normalizeJsName;
      exports3.objCreate = objCreateFn;
      exports3.objDefineAccessors = objDefineAccessors;
      exports3.objExtend = objExtend;
      exports3.objForEachKey = objForEachKey;
      exports3.objFreeze = objFreeze;
      exports3.objKeys = objKeys;
      exports3.objSeal = objSeal;
      exports3.objToString = objToString;
      exports3.optimizeObject = optimizeObject;
      exports3.parseTraceParent = parseTraceParent;
      exports3.perfNow = perfNow;
      exports3.proxyAssign = proxyAssign;
      exports3.proxyFunctionAs = proxyFunctionAs;
      exports3.proxyFunctions = proxyFunctions;
      exports3.random32 = random32;
      exports3.randomValue = randomValue;
      exports3.removeEventHandler = removeEventHandler;
      exports3.removeEventListeners = removeEventListeners;
      exports3.removePageHideEventListener = removePageHideEventListener;
      exports3.removePageShowEventListener = removePageShowEventListener;
      exports3.removePageUnloadEventListener = removePageUnloadEventListener;
      exports3.safeGetCookieMgr = safeGetCookieMgr;
      exports3.safeGetLogger = safeGetLogger;
      exports3.sendCustomEvent = sendCustomEvent;
      exports3.setCookie = setCookie;
      exports3.setEnableEnvMocks = setEnableEnvMocks;
      exports3.setGblPerfMgr = setGblPerfMgr;
      exports3.setValue = setValue;
      exports3.sortPlugins = sortPlugins;
      exports3.strContains = strContains;
      exports3.strEndsWith = strEndsWith;
      exports3.strFunction = strShimFunction;
      exports3.strObject = strShimObject;
      exports3.strPrototype = strShimPrototype;
      exports3.strStartsWith = strStartsWith;
      exports3.strTrim = strTrim;
      exports3.strUndefined = strShimUndefined;
      exports3.throwError = throwError;
      exports3.toISOString = toISOString;
      exports3.uaDisallowsSameSiteNone = uaDisallowsSameSiteNone;
      exports3.unloadComponents = unloadComponents;
      exports3.useXDomainRequest = useXDomainRequest;
      (function(obj, prop, descriptor) {
        var func = Object["defineProperty"];
        if (func) {
          try {
            return func(obj, prop, descriptor);
          } catch (e) {
          }
        }
        if (descriptor && typeof descriptor.value !== void 0) {
          obj[prop] = descriptor.value;
        }
        return obj;
      })(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@microsoft/dynamicproto-js/lib/dist/node/dynamicproto-js.js
var require_dynamicproto_js = __commonJS({
  "node_modules/@microsoft/dynamicproto-js/lib/dist/node/dynamicproto-js.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Microsoft = global2.Microsoft || {}, global2.Microsoft["DynamicProto-JS"] = factory());
    })(exports2, function() {
      "use strict";
      var _a;
      var UNDEFINED = "undefined";
      var Constructor = "constructor";
      var Prototype = "prototype";
      var strFunction = "function";
      var DynInstFuncTable = "_dynInstFuncs";
      var DynProxyTag = "_isDynProxy";
      var DynClassName = "_dynClass";
      var DynClassNamePrefix = "_dynCls$";
      var DynInstChkTag = "_dynInstChk";
      var DynAllowInstChkTag = DynInstChkTag;
      var DynProtoDefaultOptions = "_dfOpts";
      var UnknownValue = "_unknown_";
      var str__Proto = "__proto__";
      var DynProtoBaseProto = "_dyn" + str__Proto;
      var DynProtoGlobalSettings = "__dynProto$Gbl";
      var DynProtoCurrent = "_dynInstProto";
      var strUseBaseInst = "useBaseInst";
      var strSetInstFuncs = "setInstFuncs";
      var Obj = Object;
      var _objGetPrototypeOf = Obj["getPrototypeOf"];
      var _objGetOwnProps = Obj["getOwnPropertyNames"];
      function _getGlobal() {
        var result;
        if (typeof globalThis !== UNDEFINED) {
          result = globalThis;
        }
        if (!result && typeof self !== UNDEFINED) {
          result = self;
        }
        if (!result && typeof window !== UNDEFINED) {
          result = window;
        }
        if (!result && typeof global !== UNDEFINED) {
          result = global;
        }
        return result || {};
      }
      var _gbl = _getGlobal();
      var _gblInst = _gbl[DynProtoGlobalSettings] || (_gbl[DynProtoGlobalSettings] = {
        o: (_a = {}, _a[strSetInstFuncs] = true, _a[strUseBaseInst] = true, _a),
        n: 1e3
        // Start new global index @ 1000 so we "fix" some cases when mixed with 1.1.6 or earlier
      });
      function _hasOwnProperty(obj, prop) {
        return obj && Obj[Prototype].hasOwnProperty.call(obj, prop);
      }
      function _isObjectOrArrayPrototype(target) {
        return target && (target === Obj[Prototype] || target === Array[Prototype]);
      }
      function _isObjectArrayOrFunctionPrototype(target) {
        return _isObjectOrArrayPrototype(target) || target === Function[Prototype];
      }
      function _getObjProto(target) {
        var newProto;
        if (target) {
          if (_objGetPrototypeOf) {
            return _objGetPrototypeOf(target);
          }
          var curProto = target[str__Proto] || target[Prototype] || (target[Constructor] ? target[Constructor][Prototype] : null);
          newProto = target[DynProtoBaseProto] || curProto;
          if (!_hasOwnProperty(target, DynProtoBaseProto)) {
            delete target[DynProtoCurrent];
            newProto = target[DynProtoBaseProto] = target[DynProtoCurrent] || target[DynProtoBaseProto];
            target[DynProtoCurrent] = curProto;
          }
        }
        return newProto;
      }
      function _forEachProp(target, func) {
        var props = [];
        if (_objGetOwnProps) {
          props = _objGetOwnProps(target);
        } else {
          for (var name_1 in target) {
            if (typeof name_1 === "string" && _hasOwnProperty(target, name_1)) {
              props.push(name_1);
            }
          }
        }
        if (props && props.length > 0) {
          for (var lp = 0; lp < props.length; lp++) {
            func(props[lp]);
          }
        }
      }
      function _isDynamicCandidate(target, funcName, skipOwn) {
        return funcName !== Constructor && typeof target[funcName] === strFunction && (skipOwn || _hasOwnProperty(target, funcName));
      }
      function _throwTypeError(message) {
        throw new TypeError("DynamicProto: " + message);
      }
      function _getInstanceFuncs(thisTarget) {
        var instFuncs = {};
        _forEachProp(thisTarget, function(name2) {
          if (!instFuncs[name2] && _isDynamicCandidate(thisTarget, name2, false)) {
            instFuncs[name2] = thisTarget[name2];
          }
        });
        return instFuncs;
      }
      function _hasVisited(values, value) {
        for (var lp = values.length - 1; lp >= 0; lp--) {
          if (values[lp] === value) {
            return true;
          }
        }
        return false;
      }
      function _getBaseFuncs(classProto, thisTarget, instFuncs, useBaseInst) {
        function _instFuncProxy(target, funcHost, funcName) {
          var theFunc = funcHost[funcName];
          if (theFunc[DynProxyTag] && useBaseInst) {
            var instFuncTable = target[DynInstFuncTable] || {};
            if (instFuncTable[DynAllowInstChkTag] !== false) {
              theFunc = (instFuncTable[funcHost[DynClassName]] || {})[funcName] || theFunc;
            }
          }
          return function() {
            return theFunc.apply(target, arguments);
          };
        }
        var baseFuncs = {};
        _forEachProp(instFuncs, function(name2) {
          baseFuncs[name2] = _instFuncProxy(thisTarget, instFuncs, name2);
        });
        var baseProto = _getObjProto(classProto);
        var visited = [];
        while (baseProto && !_isObjectArrayOrFunctionPrototype(baseProto) && !_hasVisited(visited, baseProto)) {
          _forEachProp(baseProto, function(name2) {
            if (!baseFuncs[name2] && _isDynamicCandidate(baseProto, name2, !_objGetPrototypeOf)) {
              baseFuncs[name2] = _instFuncProxy(thisTarget, baseProto, name2);
            }
          });
          visited.push(baseProto);
          baseProto = _getObjProto(baseProto);
        }
        return baseFuncs;
      }
      function _getInstFunc(target, funcName, proto, currentDynProtoProxy) {
        var instFunc = null;
        if (target && _hasOwnProperty(proto, DynClassName)) {
          var instFuncTable = target[DynInstFuncTable] || {};
          instFunc = (instFuncTable[proto[DynClassName]] || {})[funcName];
          if (!instFunc) {
            _throwTypeError("Missing [" + funcName + "] " + strFunction);
          }
          if (!instFunc[DynInstChkTag] && instFuncTable[DynAllowInstChkTag] !== false) {
            var canAddInst = !_hasOwnProperty(target, funcName);
            var objProto = _getObjProto(target);
            var visited = [];
            while (canAddInst && objProto && !_isObjectArrayOrFunctionPrototype(objProto) && !_hasVisited(visited, objProto)) {
              var protoFunc = objProto[funcName];
              if (protoFunc) {
                canAddInst = protoFunc === currentDynProtoProxy;
                break;
              }
              visited.push(objProto);
              objProto = _getObjProto(objProto);
            }
            try {
              if (canAddInst) {
                target[funcName] = instFunc;
              }
              instFunc[DynInstChkTag] = 1;
            } catch (e) {
              instFuncTable[DynAllowInstChkTag] = false;
            }
          }
        }
        return instFunc;
      }
      function _getProtoFunc(funcName, proto, currentDynProtoProxy) {
        var protoFunc = proto[funcName];
        if (protoFunc === currentDynProtoProxy) {
          protoFunc = _getObjProto(proto)[funcName];
        }
        if (typeof protoFunc !== strFunction) {
          _throwTypeError("[" + funcName + "] is not a " + strFunction);
        }
        return protoFunc;
      }
      function _populatePrototype(proto, className, target, baseInstFuncs, setInstanceFunc) {
        function _createDynamicPrototype(proto2, funcName) {
          var dynProtoProxy = function() {
            var instFunc = _getInstFunc(this, funcName, proto2, dynProtoProxy) || _getProtoFunc(funcName, proto2, dynProtoProxy);
            return instFunc.apply(this, arguments);
          };
          dynProtoProxy[DynProxyTag] = 1;
          return dynProtoProxy;
        }
        if (!_isObjectOrArrayPrototype(proto)) {
          var instFuncTable = target[DynInstFuncTable] = target[DynInstFuncTable] || {};
          var instFuncs_1 = instFuncTable[className] = instFuncTable[className] || {};
          if (instFuncTable[DynAllowInstChkTag] !== false) {
            instFuncTable[DynAllowInstChkTag] = !!setInstanceFunc;
          }
          _forEachProp(target, function(name2) {
            if (_isDynamicCandidate(target, name2, false) && target[name2] !== baseInstFuncs[name2]) {
              instFuncs_1[name2] = target[name2];
              delete target[name2];
              if (!_hasOwnProperty(proto, name2) || proto[name2] && !proto[name2][DynProxyTag]) {
                proto[name2] = _createDynamicPrototype(proto, name2);
              }
            }
          });
        }
      }
      function _checkPrototype(classProto, thisTarget) {
        if (_objGetPrototypeOf) {
          var visited = [];
          var thisProto = _getObjProto(thisTarget);
          while (thisProto && !_isObjectArrayOrFunctionPrototype(thisProto) && !_hasVisited(visited, thisProto)) {
            if (thisProto === classProto) {
              return true;
            }
            visited.push(thisProto);
            thisProto = _getObjProto(thisProto);
          }
          return false;
        }
        return true;
      }
      function _getObjName(target, unknownValue) {
        if (_hasOwnProperty(target, Prototype)) {
          return target.name || unknownValue || UnknownValue;
        }
        return ((target || {})[Constructor] || {}).name || unknownValue || UnknownValue;
      }
      function dynamicProto(theClass, target, delegateFunc, options) {
        if (!_hasOwnProperty(theClass, Prototype)) {
          _throwTypeError("theClass is an invalid class definition.");
        }
        var classProto = theClass[Prototype];
        if (!_checkPrototype(classProto, target)) {
          _throwTypeError("[" + _getObjName(theClass) + "] not in hierarchy of [" + _getObjName(target) + "]");
        }
        var className = null;
        if (_hasOwnProperty(classProto, DynClassName)) {
          className = classProto[DynClassName];
        } else {
          className = DynClassNamePrefix + _getObjName(theClass, "_") + "$" + _gblInst.n;
          _gblInst.n++;
          classProto[DynClassName] = className;
        }
        var perfOptions = dynamicProto[DynProtoDefaultOptions];
        var useBaseInst = !!perfOptions[strUseBaseInst];
        if (useBaseInst && options && options[strUseBaseInst] !== void 0) {
          useBaseInst = !!options[strUseBaseInst];
        }
        var instFuncs = _getInstanceFuncs(target);
        var baseFuncs = _getBaseFuncs(classProto, target, instFuncs, useBaseInst);
        delegateFunc(target, baseFuncs);
        var setInstanceFunc = !!_objGetPrototypeOf && !!perfOptions[strSetInstFuncs];
        if (setInstanceFunc && options) {
          setInstanceFunc = !!options[strSetInstFuncs];
        }
        _populatePrototype(classProto, className, target, instFuncs, setInstanceFunc !== false);
      }
      dynamicProto[DynProtoDefaultOptions] = _gblInst.o;
      return dynamicProto;
    });
  }
});

// node_modules/@microsoft/1ds-core-js/dist/ms.core.js
var require_ms_core = __commonJS({
  "node_modules/@microsoft/1ds-core-js/dist/ms.core.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_applicationinsights_shims(), require_applicationinsights_core_js(), require_dynamicproto_js()) : typeof define === "function" && define.amd ? define(["exports", "@microsoft/applicationinsights-shims", "@microsoft/applicationinsights-core-js", "@microsoft/dynamicproto-js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.oneDS = global2.oneDS || {}, global2.applicationinsightsShims, global2.applicationinsightsCoreJs, global2.dynamicProto));
    })(exports2, function(exports3, applicationinsightsShims, applicationinsightsCoreJs, dynamicProto) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      var dynamicProto__default = /* @__PURE__ */ _interopDefaultLegacy(dynamicProto);
      var ValueKind = applicationinsightsCoreJs.createEnumStyle({
        NotSet: 0,
        Pii_DistinguishedName: 1,
        Pii_GenericData: 2,
        Pii_IPV4Address: 3,
        Pii_IPv6Address: 4,
        Pii_MailSubject: 5,
        Pii_PhoneNumber: 6,
        Pii_QueryString: 7,
        Pii_SipAddress: 8,
        Pii_SmtpAddress: 9,
        Pii_Identity: 10,
        Pii_Uri: 11,
        Pii_Fqdn: 12,
        Pii_IPV4AddressLegacy: 13,
        CustomerContent_GenericContent: 32
      });
      var EventLatency = applicationinsightsCoreJs.createEnumStyle({
        Normal: 1,
        CostDeferred: 2,
        RealTime: 3,
        Immediate: 4
      });
      var EventPropertyType = applicationinsightsCoreJs.createEnumStyle({
        Unspecified: 0,
        String: 1,
        Int32: 2,
        UInt32: 3,
        Int64: 4,
        UInt64: 5,
        Double: 6,
        Bool: 7,
        Guid: 8,
        DateTime: 9
      });
      var EventPersistence = applicationinsightsCoreJs.createEnumStyle({
        Normal: 1,
        Critical: 2
      });
      var TraceLevel = applicationinsightsCoreJs.createEnumStyle({
        NONE: 0,
        ERROR: 1,
        WARNING: 2,
        INFORMATION: 3
      });
      var _ExtendedInternalMessageId = applicationinsightsCoreJs.objFreeze(applicationinsightsShims.__assignFn(applicationinsightsShims.__assignFn({}, applicationinsightsCoreJs._InternalMessageId), applicationinsightsCoreJs.createEnumStyle({
        AuthHandShakeError: 501,
        AuthRedirectFail: 502,
        BrowserCannotReadLocalStorage: 503,
        BrowserCannotWriteLocalStorage: 504,
        BrowserDoesNotSupportLocalStorage: 505,
        CannotParseBiBlobValue: 506,
        CannotParseDataAttribute: 507,
        CVPluginNotAvailable: 508,
        DroppedEvent: 509,
        ErrorParsingAISessionCookie: 510,
        ErrorProvidedChannels: 511,
        FailedToGetCookies: 512,
        FailedToInitializeCorrelationVector: 513,
        FailedToInitializeSDK: 514,
        InvalidContentBlob: 515,
        InvalidCorrelationValue: 516,
        SessionRenewalDateIsZero: 517,
        SendPostOnCompleteFailure: 518,
        PostResponseHandler: 519,
        SDKNotInitialized: 520
      })));
      var STR_EMPTY = "";
      var STR_DEFAULT_ENDPOINT_URL = "https://browser.events.data.microsoft.com/OneCollector/1.0/";
      var STR_VERSION = "version";
      var STR_PROPERTIES = "properties";
      var _a;
      var Version = "3.2.13";
      var FullVersionString = "1DS-Web-JS-" + Version;
      var strDisabledPropertyName = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var strWithCredentials = "withCredentials";
      var strTimeout = "timeout";
      var _fieldTypeEventPropMap = (_a = {}, _a[0] = 0, _a[2] = 6, _a[1] = 1, _a[3] = 7, _a[4096 | 2] = 6, _a[4096 | 1] = 1, _a[4096 | 3] = 7, _a);
      var uInt8ArraySupported = null;
      var isDocumentObjectAvailable = Boolean(applicationinsightsCoreJs.getDocument());
      var isWindowObjectAvailable = Boolean(applicationinsightsCoreJs.getWindow());
      function isValueAssigned(value) {
        return !(value === STR_EMPTY || applicationinsightsCoreJs.isNullOrUndefined(value));
      }
      function getTenantId(apiKey) {
        if (apiKey) {
          var indexTenantId = apiKey.indexOf("-");
          if (indexTenantId > -1) {
            return apiKey.substring(0, indexTenantId);
          }
        }
        return STR_EMPTY;
      }
      function isUint8ArrayAvailable() {
        if (uInt8ArraySupported === null) {
          uInt8ArraySupported = !applicationinsightsCoreJs.isUndefined(Uint8Array) && !isSafariOrFirefox() && !applicationinsightsCoreJs.isReactNative();
        }
        return uInt8ArraySupported;
      }
      function isLatency(value) {
        if (value && applicationinsightsCoreJs.isNumber(value) && value >= 1 && value <= 4) {
          return true;
        }
        return false;
      }
      function sanitizeProperty(name2, property, stringifyObjects) {
        if (!property && !isValueAssigned(property) || typeof name2 !== "string") {
          return null;
        }
        var propType = typeof property;
        if (propType === "string" || propType === "number" || propType === "boolean" || applicationinsightsCoreJs.isArray(property)) {
          property = { value: property };
        } else if (propType === "object" && !applicationinsightsShims.ObjHasOwnProperty.call(property, "value")) {
          property = { value: stringifyObjects ? JSON.stringify(property) : property };
        } else if (applicationinsightsCoreJs.isNullOrUndefined(property.value) || property.value === STR_EMPTY || !applicationinsightsCoreJs.isString(property.value) && !applicationinsightsCoreJs.isNumber(property.value) && !applicationinsightsCoreJs.isBoolean(property.value) && !applicationinsightsCoreJs.isArray(property.value)) {
          return null;
        }
        if (applicationinsightsCoreJs.isArray(property.value) && !isArrayValid(property.value)) {
          return null;
        }
        if (!applicationinsightsCoreJs.isNullOrUndefined(property.kind)) {
          if (applicationinsightsCoreJs.isArray(property.value) || !isValueKind(property.kind)) {
            return null;
          }
          property.value = property.value.toString();
        }
        return property;
      }
      function getCommonSchemaMetaData(value, kind, type) {
        var encodedTypeValue = -1;
        if (!applicationinsightsCoreJs.isUndefined(value)) {
          if (kind > 0) {
            if (kind === 32) {
              encodedTypeValue = 1 << 13;
            } else if (kind <= 13) {
              encodedTypeValue = kind << 5;
            }
          }
          if (isDataType(type)) {
            if (encodedTypeValue === -1) {
              encodedTypeValue = 0;
            }
            encodedTypeValue |= type;
          } else {
            var propType = _fieldTypeEventPropMap[getFieldValueType(value)] || -1;
            if (encodedTypeValue !== -1 && propType !== -1) {
              encodedTypeValue |= propType;
            } else if (propType === 6) {
              encodedTypeValue = propType;
            }
          }
        }
        return encodedTypeValue;
      }
      function disableCookies() {
        applicationinsightsCoreJs.safeGetCookieMgr(null).setEnabled(false);
      }
      function setCookie(name2, value, days) {
        if (applicationinsightsCoreJs.areCookiesSupported(null)) {
          applicationinsightsCoreJs.safeGetCookieMgr(null).set(name2, value, days * 86400, null, "/");
        }
      }
      function deleteCookie(name2) {
        if (applicationinsightsCoreJs.areCookiesSupported(null)) {
          applicationinsightsCoreJs.safeGetCookieMgr(null).del(name2);
        }
      }
      function getCookie(name2) {
        if (applicationinsightsCoreJs.areCookiesSupported(null)) {
          return getCookieValue(applicationinsightsCoreJs.safeGetCookieMgr(null), name2);
        }
        return STR_EMPTY;
      }
      function getCookieValue(cookieMgr, name2, decode) {
        if (decode === void 0) {
          decode = true;
        }
        var cookieValue;
        if (cookieMgr) {
          cookieValue = cookieMgr.get(name2);
          if (decode && cookieValue && decodeURIComponent) {
            cookieValue = decodeURIComponent(cookieValue);
          }
        }
        return cookieValue || STR_EMPTY;
      }
      function createGuid(style) {
        if (style === void 0) {
          style = "D";
        }
        var theGuid = applicationinsightsCoreJs.newGuid();
        if (style === "B") {
          theGuid = "{" + theGuid + "}";
        } else if (style === "P") {
          theGuid = "(" + theGuid + ")";
        } else if (style === "N") {
          theGuid = theGuid.replace(/-/g, STR_EMPTY);
        }
        return theGuid;
      }
      function extend(obj, obj2, obj3, obj4, obj5) {
        var extended = {};
        var deep = false;
        var i = 0;
        var length = arguments.length;
        var objProto = Object[applicationinsightsShims.strShimPrototype];
        var theArgs = arguments;
        if (objProto.toString.call(theArgs[0]) === "[object Boolean]") {
          deep = theArgs[0];
          i++;
        }
        for (; i < length; i++) {
          var obj = theArgs[i];
          applicationinsightsCoreJs.objForEachKey(obj, function(prop, value) {
            if (deep && value && applicationinsightsCoreJs.isObject(value)) {
              if (applicationinsightsCoreJs.isArray(value)) {
                extended[prop] = extended[prop] || [];
                applicationinsightsCoreJs.arrForEach(value, function(arrayValue, arrayIndex) {
                  if (arrayValue && applicationinsightsCoreJs.isObject(arrayValue)) {
                    extended[prop][arrayIndex] = extend(true, extended[prop][arrayIndex], arrayValue);
                  } else {
                    extended[prop][arrayIndex] = arrayValue;
                  }
                });
              } else {
                extended[prop] = extend(true, extended[prop], value);
              }
            } else {
              extended[prop] = value;
            }
          });
        }
        return extended;
      }
      var getTime = applicationinsightsCoreJs.perfNow;
      function isValueKind(value) {
        if (value === 0 || (value > 0 && value <= 13 || value === 32)) {
          return true;
        }
        return false;
      }
      function isDataType(value) {
        if (value >= 0 && value <= 9) {
          return true;
        }
        return false;
      }
      function isSafariOrFirefox() {
        var nav = applicationinsightsCoreJs.getNavigator();
        if (!applicationinsightsCoreJs.isUndefined(nav) && nav.userAgent) {
          var ua = nav.userAgent.toLowerCase();
          if ((ua.indexOf("safari") >= 0 || ua.indexOf("firefox") >= 0) && ua.indexOf("chrome") < 0) {
            return true;
          }
        }
        return false;
      }
      function isArrayValid(value) {
        return value.length > 0;
      }
      function setProcessTelemetryTimings(event, identifier) {
        var evt = event;
        evt.timings = evt.timings || {};
        evt.timings.processTelemetryStart = evt.timings.processTelemetryStart || {};
        evt.timings.processTelemetryStart[identifier] = getTime();
      }
      function getFieldValueType(value) {
        var theType = 0;
        if (value !== null && value !== void 0) {
          var objType = typeof value;
          if (objType === "string") {
            theType = 1;
          } else if (objType === "number") {
            theType = 2;
          } else if (objType === "boolean") {
            theType = 3;
          } else if (objType === applicationinsightsShims.strShimObject) {
            theType = 4;
            if (applicationinsightsCoreJs.isArray(value)) {
              theType = 4096;
              if (value.length > 0) {
                theType |= getFieldValueType(value[0]);
              }
            } else if (applicationinsightsShims.ObjHasOwnProperty.call(value, "value")) {
              theType = 8192 | getFieldValueType(value.value);
            }
          }
        }
        return theType;
      }
      var Utils = {
        Version,
        FullVersionString,
        strUndefined: applicationinsightsCoreJs.strUndefined,
        strObject: applicationinsightsCoreJs.strObject,
        Undefined: applicationinsightsCoreJs.strUndefined,
        arrForEach: applicationinsightsCoreJs.arrForEach,
        arrIndexOf: applicationinsightsCoreJs.arrIndexOf,
        arrMap: applicationinsightsCoreJs.arrMap,
        arrReduce: applicationinsightsCoreJs.arrReduce,
        objKeys: applicationinsightsCoreJs.objKeys,
        toISOString: applicationinsightsCoreJs.toISOString,
        isReactNative: applicationinsightsCoreJs.isReactNative,
        isString: applicationinsightsCoreJs.isString,
        isNumber: applicationinsightsCoreJs.isNumber,
        isBoolean: applicationinsightsCoreJs.isBoolean,
        isFunction: applicationinsightsCoreJs.isFunction,
        isArray: applicationinsightsCoreJs.isArray,
        isObject: applicationinsightsCoreJs.isObject,
        strTrim: applicationinsightsCoreJs.strTrim,
        isDocumentObjectAvailable,
        isWindowObjectAvailable,
        isValueAssigned,
        getTenantId,
        isBeaconsSupported: applicationinsightsCoreJs.isBeaconsSupported,
        isUint8ArrayAvailable,
        isLatency,
        sanitizeProperty,
        getISOString: applicationinsightsCoreJs.toISOString,
        useXDomainRequest: applicationinsightsCoreJs.useXDomainRequest,
        getCommonSchemaMetaData,
        cookieAvailable: applicationinsightsCoreJs.areCookiesSupported,
        disallowsSameSiteNone: applicationinsightsCoreJs.uaDisallowsSameSiteNone,
        setCookie,
        deleteCookie,
        getCookie,
        createGuid,
        extend,
        getTime,
        isValueKind,
        isArrayValid,
        objDefineAccessors: applicationinsightsCoreJs.objDefineAccessors,
        addPageUnloadEventListener: applicationinsightsCoreJs.addPageUnloadEventListener,
        setProcessTelemetryTimings,
        addEventHandler: applicationinsightsCoreJs.addEventHandler,
        getFieldValueType,
        strEndsWith: applicationinsightsCoreJs.strEndsWith,
        objForEachKey: applicationinsightsCoreJs.objForEachKey
      };
      var CoreUtils = {
        _canUseCookies: void 0,
        isTypeof: applicationinsightsCoreJs.isTypeof,
        isUndefined: applicationinsightsCoreJs.isUndefined,
        isNullOrUndefined: applicationinsightsCoreJs.isNullOrUndefined,
        hasOwnProperty: applicationinsightsCoreJs.hasOwnProperty,
        isFunction: applicationinsightsCoreJs.isFunction,
        isObject: applicationinsightsCoreJs.isObject,
        isDate: applicationinsightsCoreJs.isDate,
        isArray: applicationinsightsCoreJs.isArray,
        isError: applicationinsightsCoreJs.isError,
        isString: applicationinsightsCoreJs.isString,
        isNumber: applicationinsightsCoreJs.isNumber,
        isBoolean: applicationinsightsCoreJs.isBoolean,
        toISOString: applicationinsightsCoreJs.toISOString,
        arrForEach: applicationinsightsCoreJs.arrForEach,
        arrIndexOf: applicationinsightsCoreJs.arrIndexOf,
        arrMap: applicationinsightsCoreJs.arrMap,
        arrReduce: applicationinsightsCoreJs.arrReduce,
        strTrim: applicationinsightsCoreJs.strTrim,
        objCreate: applicationinsightsShims.objCreateFn,
        objKeys: applicationinsightsCoreJs.objKeys,
        objDefineAccessors: applicationinsightsCoreJs.objDefineAccessors,
        addEventHandler: applicationinsightsCoreJs.addEventHandler,
        dateNow: applicationinsightsCoreJs.dateNow,
        isIE: applicationinsightsCoreJs.isIE,
        disableCookies,
        newGuid: applicationinsightsCoreJs.newGuid,
        perfNow: applicationinsightsCoreJs.perfNow,
        newId: applicationinsightsCoreJs.newId,
        randomValue: applicationinsightsCoreJs.randomValue,
        random32: applicationinsightsCoreJs.random32,
        mwcRandomSeed: applicationinsightsCoreJs.mwcRandomSeed,
        mwcRandom32: applicationinsightsCoreJs.mwcRandom32,
        generateW3CId: applicationinsightsCoreJs.generateW3CId
      };
      function isChromium() {
        return !!applicationinsightsCoreJs.getGlobalInst("chrome");
      }
      function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
        if (disabled === void 0) {
          disabled = false;
        }
        if (isSync === void 0) {
          isSync = false;
        }
        function _wrapSetXhrProp(xhr2, prop, value) {
          try {
            xhr2[prop] = value;
          } catch (e) {
          }
        }
        var xhr = new XMLHttpRequest();
        if (disabled) {
          _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
        }
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        xhr.open(method, urlString, !isSync);
        if (withCredentials) {
          _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
        }
        if (!isSync && timeout) {
          _wrapSetXhrProp(xhr, strTimeout, timeout);
        }
        return xhr;
      }
      var AppInsightsCore = (
        /** @class */
        function(_super) {
          applicationinsightsShims.__extendsFn(AppInsightsCore2, _super);
          function AppInsightsCore2() {
            var _this = _super.call(this) || this;
            _this.pluginVersionStringArr = [];
            dynamicProto__default(AppInsightsCore2, _this, function(_self, _base) {
              if (!_self.logger || !_self.logger.queue) {
                _self.logger = new applicationinsightsCoreJs.DiagnosticLogger({ loggingLevelConsole: 1 });
              }
              _self.initialize = function(config, extensions2, logger, notificationManager) {
                applicationinsightsCoreJs.doPerf(_self, function() {
                  return "AppInsightsCore.initialize";
                }, function() {
                  var _pluginVersionStringArr = _self.pluginVersionStringArr;
                  if (config) {
                    if (!config.endpointUrl) {
                      config.endpointUrl = STR_DEFAULT_ENDPOINT_URL;
                    }
                    var propertyStorageOverride = config.propertyStorageOverride;
                    if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {
                      applicationinsightsCoreJs.throwError("Invalid property storage override passed.");
                    }
                    if (config.channels) {
                      applicationinsightsCoreJs.arrForEach(config.channels, function(channels) {
                        if (channels) {
                          applicationinsightsCoreJs.arrForEach(channels, function(channel) {
                            if (channel.identifier && channel.version) {
                              var ver = channel.identifier + "=" + channel.version;
                              _pluginVersionStringArr.push(ver);
                            }
                          });
                        }
                      });
                    }
                  }
                  _self.getWParam = function() {
                    return typeof document !== "undefined" || !!config.enableWParam ? 0 : -1;
                  };
                  if (extensions2) {
                    applicationinsightsCoreJs.arrForEach(extensions2, function(ext) {
                      if (ext && ext.identifier && ext.version) {
                        var ver = ext.identifier + "=" + ext.version;
                        _pluginVersionStringArr.push(ver);
                      }
                    });
                  }
                  _self.pluginVersionString = _pluginVersionStringArr.join(";");
                  _self.pluginVersionStringArr = _pluginVersionStringArr;
                  try {
                    _base.initialize(config, extensions2, logger, notificationManager);
                    _self.pollInternalLogs("InternalLog");
                  } catch (e) {
                    var logger_1 = _self.logger;
                    var message = applicationinsightsCoreJs.dumpObj(e);
                    if (message.indexOf("channels") !== -1) {
                      message += "\n - Channels must be provided through config.channels only!";
                    }
                    applicationinsightsCoreJs._throwInternal(logger_1, 1, 514, "SDK Initialization Failed - no telemetry will be sent: " + message);
                  }
                }, function() {
                  return { config, extensions: extensions2, logger, notificationManager };
                });
              };
              _self.track = function(item) {
                applicationinsightsCoreJs.doPerf(_self, function() {
                  return "AppInsightsCore.track";
                }, function() {
                  var telemetryItem = item;
                  if (telemetryItem) {
                    telemetryItem.timings = telemetryItem.timings || {};
                    telemetryItem.timings.trackStart = getTime();
                    if (!isLatency(telemetryItem.latency)) {
                      telemetryItem.latency = 1;
                    }
                    var itemExt = telemetryItem.ext = telemetryItem.ext || {};
                    itemExt.sdk = itemExt.sdk || {};
                    itemExt.sdk.ver = FullVersionString;
                    var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
                    baseData[STR_PROPERTIES] = baseData[STR_PROPERTIES] || {};
                    var itemProperties = baseData[STR_PROPERTIES];
                    itemProperties[STR_VERSION] = itemProperties[STR_VERSION] || _self.pluginVersionString || STR_EMPTY;
                  }
                  _base.track(telemetryItem);
                }, function() {
                  return { item };
                }, !item.sync);
              };
            });
            return _this;
          }
          AppInsightsCore2.__ieDyn = 1;
          return AppInsightsCore2;
        }(applicationinsightsCoreJs.AppInsightsCore)
      );
      var BaseCore = (
        /** @class */
        function(_super) {
          applicationinsightsShims.__extendsFn(BaseCore2, _super);
          function BaseCore2() {
            var _this = _super.call(this) || this;
            dynamicProto__default(BaseCore2, _this, function(_self, _base) {
              _self.initialize = function(config, extensions2, logger, notificationManager) {
                if (config && !config.endpointUrl) {
                  config.endpointUrl = STR_DEFAULT_ENDPOINT_URL;
                }
                _self.getWParam = function() {
                  return isDocumentObjectAvailable || !!config.enableWParam ? 0 : -1;
                };
                try {
                  _base.initialize(config, extensions2, logger, notificationManager);
                } catch (e) {
                  applicationinsightsCoreJs._throwInternal(_self.logger, 1, 514, "Initialization Failed: " + applicationinsightsCoreJs.dumpObj(e) + "\n - Note: Channels must be provided through config.channels only");
                }
              };
              _self.track = function(item) {
                var telemetryItem = item;
                if (telemetryItem) {
                  var ext = telemetryItem.ext = telemetryItem.ext || {};
                  ext.sdk = ext.sdk || {};
                  ext.sdk.ver = FullVersionString;
                }
                _base.track(telemetryItem);
              };
            });
            return _this;
          }
          BaseCore2.__ieDyn = 1;
          return BaseCore2;
        }(applicationinsightsCoreJs.BaseCore)
      );
      var _isFunction = applicationinsightsCoreJs.isFunction;
      function _createPromiseAllOnResolvedFunction(values, index, resolvedCallback) {
        return function(value) {
          values[index] = value;
          resolvedCallback();
        };
      }
      var ESPromise = (
        /** @class */
        function() {
          function ESPromise2(resolverFunc) {
            var _state = 0;
            var _settledValue = null;
            var _queue = [];
            dynamicProto__default(ESPromise2, this, function(_this) {
              _this.then = function(onResolved, onRejected) {
                return new ESPromise2(function(resolve, reject) {
                  _enqueue(onResolved, onRejected, resolve, reject);
                });
              };
              _this["catch"] = function(onRejected) {
                return _this.then(null, onRejected);
              };
            });
            function _enqueue(onResolved, onRejected, resolve, reject) {
              _queue.push(function() {
                var value;
                try {
                  if (_state === 1) {
                    value = _isFunction(onResolved) ? onResolved(_settledValue) : _settledValue;
                  } else {
                    value = _isFunction(onRejected) ? onRejected(_settledValue) : _settledValue;
                  }
                  if (value instanceof ESPromise2) {
                    value.then(resolve, reject);
                  } else if (_state === 2 && !_isFunction(onRejected)) {
                    reject(value);
                  } else {
                    resolve(value);
                  }
                } catch (error) {
                  reject(error);
                  return;
                }
              });
              if (_state !== 0) {
                _processQueue();
              }
            }
            function _processQueue() {
              if (_queue.length > 0) {
                var pending_1 = _queue.slice();
                _queue = [];
                setTimeout(function() {
                  for (var i = 0, len = pending_1.length; i < len; ++i) {
                    try {
                      pending_1[i]();
                    } catch (e) {
                    }
                  }
                }, 0);
              }
            }
            function _resolve(value) {
              if (_state === 0) {
                _settledValue = value;
                _state = 1;
                _processQueue();
              }
            }
            function _reject(reason) {
              if (_state === 0) {
                _settledValue = reason;
                _state = 2;
                _processQueue();
              }
            }
            (function _initialize() {
              if (!_isFunction(resolverFunc)) {
                throw new TypeError("ESPromise: resolvedFunc argument is not a Function");
              }
              try {
                resolverFunc(_resolve, _reject);
              } catch (error) {
                _reject(error);
              }
            })();
          }
          ESPromise2.resolve = function(value) {
            if (value instanceof ESPromise2) {
              return value;
            } else if (value && _isFunction(value.then)) {
              return new ESPromise2(function(resolve, reject) {
                try {
                  value.then(resolve, reject);
                } catch (error) {
                  reject(error);
                }
              });
            }
            return new ESPromise2(function(resolve) {
              resolve(value);
            });
          };
          ESPromise2.reject = function(reason) {
            return new ESPromise2(function(resolve, reject) {
              reject(reason);
            });
          };
          ESPromise2.all = function(iterable) {
            if (!iterable || !iterable.length) {
              return;
            }
            return new ESPromise2(function(resolve, reject) {
              try {
                var values_1 = [];
                var pending_2 = 0;
                for (var lp = 0; lp < iterable.length; lp++) {
                  var item = iterable[lp];
                  if (item && _isFunction(item.then)) {
                    pending_2++;
                    item.then(_createPromiseAllOnResolvedFunction(values_1, lp, function() {
                      if (--pending_2 === 0) {
                        resolve(values_1);
                      }
                    }), reject);
                  } else {
                    values_1[lp] = item;
                  }
                }
                if (pending_2 === 0) {
                  setTimeout(function() {
                    resolve(values_1);
                  }, 0);
                }
              } catch (error) {
                reject(error);
              }
            });
          };
          ESPromise2.race = function(iterable) {
            return new ESPromise2(function(resolve, reject) {
              if (!iterable || !iterable.length) {
                return;
              }
              try {
                var _loop_1 = function(lp2) {
                  var item = iterable[lp2];
                  if (item && _isFunction(item.then)) {
                    item.then(resolve, reject);
                  } else {
                    setTimeout(function() {
                      resolve(item);
                    }, 0);
                  }
                };
                for (var lp = 0; lp < iterable.length; lp++) {
                  _loop_1(lp);
                }
              } catch (error) {
                reject(error);
              }
            });
          };
          return ESPromise2;
        }()
      );
      var LazyRejectPeriod = 6e5;
      var _schedulerId = 0;
      var _running = [];
      var _waiting = [];
      var _timedOut = [];
      function _getTime() {
        return (/* @__PURE__ */ new Date()).getTime();
      }
      var ESPromiseScheduler = (
        /** @class */
        function() {
          function ESPromiseScheduler2(name2, diagLog) {
            var _promiseId = 0;
            var _scheduledName = (name2 || "<unnamed>") + "." + _schedulerId;
            _schedulerId++;
            dynamicProto__default(ESPromiseScheduler2, this, function(_this) {
              var _lastEvent = null;
              var _eventCount = 0;
              _this.scheduleEvent = function(startEventAction, eventName, timeout) {
                var uniqueId = _scheduledName + "." + _eventCount;
                _eventCount++;
                if (eventName) {
                  uniqueId += "-(" + eventName + ")";
                }
                var uniqueEventId = uniqueId + "{" + _promiseId + "}";
                _promiseId++;
                var newScheduledEvent = {
                  evt: null,
                  tm: _getTime(),
                  id: uniqueEventId,
                  isRunning: false,
                  isAborted: false
                };
                if (!_lastEvent) {
                  newScheduledEvent.evt = _startWaitingEvent(newScheduledEvent);
                } else {
                  newScheduledEvent.evt = _waitForPreviousEvent(newScheduledEvent, _lastEvent);
                }
                _lastEvent = newScheduledEvent;
                _lastEvent.evt._schId = uniqueEventId;
                return newScheduledEvent.evt;
                function _abortAndRemoveOldEvents(eventQueue) {
                  var now = _getTime();
                  var expired = now - LazyRejectPeriod;
                  var len = eventQueue.length;
                  var lp = 0;
                  while (lp < len) {
                    var evt = eventQueue[lp];
                    if (evt && evt.tm < expired) {
                      var message = null;
                      if (evt.abort) {
                        message = "Aborting [" + evt.id + "] due to Excessive runtime (" + (now - evt.tm) + " ms)";
                        evt.abort(message);
                      } else {
                        message = "Removing [" + evt.id + "] due to Excessive runtime (" + (now - evt.tm) + " ms)";
                      }
                      _warnLog(message);
                      eventQueue.splice(lp, 1);
                      len--;
                    } else {
                      lp++;
                    }
                  }
                }
                function _cleanup(eventId, completed) {
                  var toQueue = false;
                  var removed = _removeQueuedEvent(_running, eventId);
                  if (!removed) {
                    removed = _removeQueuedEvent(_timedOut, eventId);
                    toQueue = true;
                  }
                  if (removed) {
                    if (removed.to) {
                      clearTimeout(removed.to);
                      removed.to = null;
                    }
                    var tm = _getTime() - removed.tm;
                    if (completed) {
                      if (!toQueue) {
                        _debugLog("Promise [" + eventId + "] Complete -- " + tm + " ms");
                      } else {
                        _warnLog("Timed out event [" + eventId + "] finally complete -- " + tm + " ms");
                      }
                    } else {
                      _timedOut.push(removed);
                      _warnLog("Event [" + eventId + "] Timed out and removed -- " + tm + " ms");
                    }
                  } else {
                    _debugLog("Failed to remove [" + eventId + "] from running queue");
                  }
                  if (_lastEvent && _lastEvent.id === eventId) {
                    _lastEvent = null;
                  }
                  _abortAndRemoveOldEvents(_running);
                  _abortAndRemoveOldEvents(_waiting);
                  _abortAndRemoveOldEvents(_timedOut);
                }
                function _removeScheduledEvent(eventId, callback) {
                  return function(value) {
                    _cleanup(eventId, true);
                    callback && callback(value);
                    return value;
                  };
                }
                function _waitForFinalResult(eventId, startResult, schEventResolve, schEventReject) {
                  startResult.then(function(value) {
                    if (value instanceof ESPromise) {
                      _debugLog("Event [" + eventId + "] returned a promise -- waiting");
                      _waitForFinalResult(eventId, value, schEventResolve, schEventReject);
                      return value;
                    } else {
                      return _removeScheduledEvent(eventId, schEventResolve)(value);
                    }
                  }, _removeScheduledEvent(eventId, schEventReject));
                }
                function _createScheduledEvent(eventDetails, startEvent) {
                  var eventId = eventDetails.id;
                  return new ESPromise(function(schEventResolve, schEventReject) {
                    _debugLog("Event [" + eventId + "] Starting -- waited for " + (eventDetails.wTm || "--") + " ms");
                    eventDetails.isRunning = true;
                    eventDetails.abort = function(message) {
                      eventDetails.abort = null;
                      eventDetails.isAborted = true;
                      _cleanup(eventId, false);
                      schEventReject(new Error(message));
                    };
                    var startResult = startEvent(eventId);
                    if (startResult instanceof ESPromise) {
                      if (timeout) {
                        eventDetails.to = setTimeout(function() {
                          _cleanup(eventId, false);
                          schEventReject(new Error("Timed out after [" + timeout + "] ms"));
                        }, timeout);
                      }
                      _waitForFinalResult(eventId, startResult, function(theResult) {
                        _debugLog("Event [" + eventId + "] Resolving after " + (_getTime() - eventDetails.tm) + " ms");
                        schEventResolve(theResult);
                      }, schEventReject);
                    } else {
                      _debugLog("Promise [" + eventId + "] Auto completed as the start action did not return a promise");
                      schEventResolve();
                    }
                  });
                }
                function _startWaitingEvent(eventDetails) {
                  var now = _getTime();
                  eventDetails.wTm = now - eventDetails.tm;
                  eventDetails.tm = now;
                  if (eventDetails.isAborted) {
                    return ESPromise.reject(new Error("[" + uniqueId + "] was aborted"));
                  }
                  _running.push(eventDetails);
                  return _createScheduledEvent(eventDetails, startEventAction);
                }
                function _waitForPreviousEvent(eventDetails, waitForEvent) {
                  var waitEvent = new ESPromise(function(waitResolve, waitReject) {
                    var runTime = _getTime() - waitForEvent.tm;
                    var prevId = waitForEvent.id;
                    _debugLog("[" + uniqueId + "] is waiting for [" + prevId + ":" + runTime + " ms] to complete before starting -- [" + _waiting.length + "] waiting and [" + _running.length + "] running");
                    eventDetails.abort = function(message) {
                      eventDetails.abort = null;
                      _removeQueuedEvent(_waiting, uniqueId);
                      eventDetails.isAborted = true;
                      waitReject(new Error(message));
                    };
                    waitForEvent.evt.then(function(value) {
                      _removeQueuedEvent(_waiting, uniqueId);
                      _startWaitingEvent(eventDetails).then(waitResolve, waitReject);
                    }, function(reason) {
                      _removeQueuedEvent(_waiting, uniqueId);
                      _startWaitingEvent(eventDetails).then(waitResolve, waitReject);
                    });
                  });
                  _waiting.push(eventDetails);
                  return waitEvent;
                }
              };
              function _removeQueuedEvent(queue, eventId) {
                for (var lp = 0; lp < queue.length; lp++) {
                  if (queue[lp].id === eventId) {
                    return queue.splice(lp, 1)[0];
                  }
                }
                return null;
              }
            });
            function _debugLog(message) {
              var global2 = applicationinsightsCoreJs.getGlobal();
              if (global2 && global2["QUnit"]) {
                console && console.log("ESPromiseScheduler[" + _scheduledName + "] " + message);
              }
            }
            function _warnLog(message) {
              applicationinsightsCoreJs._warnToConsole(diagLog, "ESPromiseScheduler[" + _scheduledName + "] " + message);
            }
          }
          ESPromiseScheduler2.incomplete = function() {
            return _running;
          };
          ESPromiseScheduler2.waitingToStart = function() {
            return _waiting;
          };
          return ESPromiseScheduler2;
        }()
      );
      var ValueSanitizer = (
        /** @class */
        function() {
          function ValueSanitizer2(fieldSanitizerProvider) {
            var _self = this;
            var _sanitizerMap = {};
            var _sanitizers = [];
            var _fieldSanitizers = [];
            if (fieldSanitizerProvider) {
              _fieldSanitizers.push(fieldSanitizerProvider);
            }
            function _getFieldSanitizer(path2, name2) {
              var result;
              var fieldLookup = _sanitizerMap[path2];
              if (fieldLookup) {
                result = fieldLookup[name2];
              }
              if (!result && result !== null) {
                if (applicationinsightsCoreJs.isString(path2) && applicationinsightsCoreJs.isString(name2)) {
                  if (_fieldSanitizers.length > 0) {
                    for (var lp = 0; lp < _fieldSanitizers.length; lp++) {
                      if (_fieldSanitizers[lp].handleField(path2, name2)) {
                        result = {
                          canHandle: true,
                          fieldHandler: _fieldSanitizers[lp]
                        };
                        break;
                      }
                    }
                  } else if (_sanitizers.length === 0) {
                    result = {
                      canHandle: true
                    };
                  }
                }
                if (!result && result !== null) {
                  result = null;
                  for (var lp = 0; lp < _sanitizers.length; lp++) {
                    if (_sanitizers[lp].handleField(path2, name2)) {
                      result = {
                        canHandle: true,
                        handler: _sanitizers[lp],
                        fieldHandler: null
                      };
                      break;
                    }
                  }
                }
                if (!fieldLookup) {
                  fieldLookup = _sanitizerMap[path2] = {};
                }
                fieldLookup[name2] = result;
              }
              return result;
            }
            _self.addSanitizer = function(newSanitizer) {
              if (newSanitizer) {
                _sanitizers.push(newSanitizer);
                _sanitizerMap = {};
              }
            };
            _self.addFieldSanitizer = function(fieldSanitizer) {
              if (fieldSanitizer) {
                _fieldSanitizers.push(fieldSanitizer);
                _sanitizerMap = {};
              }
            };
            _self.handleField = function(path2, name2) {
              var mapValue = _getFieldSanitizer(path2, name2);
              return mapValue ? mapValue.canHandle : false;
            };
            _self.value = function(path2, name2, value, stringifyObjects) {
              var mapValue = _getFieldSanitizer(path2, name2);
              if (mapValue && mapValue.canHandle) {
                if (!mapValue || !mapValue.canHandle) {
                  return null;
                }
                if (mapValue.handler) {
                  return mapValue.handler.value(path2, name2, value, stringifyObjects);
                }
                if (!applicationinsightsCoreJs.isString(name2) || applicationinsightsCoreJs.isNullOrUndefined(value) || value === STR_EMPTY) {
                  return null;
                }
                var property = null;
                var fieldType = getFieldValueType(value);
                if ((fieldType & 8192) === 8192) {
                  var subType = fieldType & ~8192;
                  property = value;
                  if (!isValueAssigned(property.value) || subType !== 1 && subType !== 2 && subType !== 3 && (subType & 4096) !== 4096) {
                    return null;
                  }
                } else if (fieldType === 1 || fieldType === 2 || fieldType === 3 || (fieldType & 4096) === 4096) {
                  property = _convertToProperty(path2, name2, value);
                } else if (fieldType === 4) {
                  property = _convertToProperty(path2, name2, !!stringifyObjects ? JSON.stringify(value) : value);
                }
                if (property) {
                  return _handleProperty(mapValue, path2, name2, fieldType, property, stringifyObjects);
                }
              }
              return null;
            };
            _self.property = function(path2, name2, property, stringifyObjects) {
              var mapValue = _getFieldSanitizer(path2, name2);
              if (!mapValue || !mapValue.canHandle) {
                return null;
              }
              if (!applicationinsightsCoreJs.isString(name2) || applicationinsightsCoreJs.isNullOrUndefined(property) || !isValueAssigned(property.value)) {
                return null;
              }
              var fieldType = getFieldValueType(property.value);
              if (fieldType === 0) {
                return null;
              }
              return _handleProperty(mapValue, path2, name2, fieldType, property, stringifyObjects);
            };
            function _handleProperty(mapValue, path2, name2, fieldType, property, stringifyObjects) {
              if (mapValue.handler) {
                return mapValue.handler.property(path2, name2, property, stringifyObjects);
              }
              if (!applicationinsightsCoreJs.isNullOrUndefined(property.kind)) {
                if ((fieldType & 4096) === 4096 || !isValueKind(property.kind)) {
                  return null;
                }
                property.value = property.value.toString();
              }
              return _callFieldSanitizer(mapValue.fieldHandler, path2, name2, fieldType, property);
            }
            function _convertToProperty(path2, name2, value) {
              if (isValueAssigned(value)) {
                return { value };
              }
              return null;
            }
            function _callFieldSanitizer(fieldProvider, path2, name2, theType, property) {
              if (property && fieldProvider) {
                var sanitizer = fieldProvider.getSanitizer(path2, name2, theType, property.kind, property.propertyType);
                if (sanitizer) {
                  if (theType === 4) {
                    var newValue_1 = {};
                    var propValue = property.value;
                    applicationinsightsCoreJs.objForEachKey(propValue, function(propKey, theValue) {
                      var newPath = path2 + "." + name2;
                      if (isValueAssigned(theValue)) {
                        var newProp = _convertToProperty(newPath, propKey, theValue);
                        newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, getFieldValueType(theValue), newProp);
                        if (newProp) {
                          newValue_1[propKey] = newProp.value;
                        }
                      }
                    });
                    property.value = newValue_1;
                  } else {
                    var details = {
                      path: path2,
                      name: name2,
                      type: theType,
                      prop: property,
                      sanitizer: _self
                    };
                    property = sanitizer.call(_self, details);
                  }
                }
              }
              return property;
            }
          }
          ValueSanitizer2.getFieldType = getFieldValueType;
          return ValueSanitizer2;
        }()
      );
      exports3.BaseTelemetryPlugin = applicationinsightsCoreJs.BaseTelemetryPlugin;
      exports3.DiagnosticLogger = applicationinsightsCoreJs.DiagnosticLogger;
      exports3.EventHelper = applicationinsightsCoreJs.EventHelper;
      exports3.EventsDiscardedReason = applicationinsightsCoreJs.EventsDiscardedReason;
      exports3.InternalAppInsightsCore = applicationinsightsCoreJs.AppInsightsCore;
      exports3.InternalBaseCore = applicationinsightsCoreJs.BaseCore;
      exports3.LoggingSeverity = applicationinsightsCoreJs.LoggingSeverity;
      exports3.MinChannelPriorty = applicationinsightsCoreJs.MinChannelPriorty;
      exports3.NotificationManager = applicationinsightsCoreJs.NotificationManager;
      exports3.PerfEvent = applicationinsightsCoreJs.PerfEvent;
      exports3.PerfManager = applicationinsightsCoreJs.PerfManager;
      exports3.ProcessTelemetryContext = applicationinsightsCoreJs.ProcessTelemetryContext;
      exports3.Undefined = applicationinsightsCoreJs.strUndefined;
      exports3._InternalLogMessage = applicationinsightsCoreJs._InternalLogMessage;
      exports3._InternalMessageId = applicationinsightsCoreJs._InternalMessageId;
      exports3.__getRegisteredEvents = applicationinsightsCoreJs.__getRegisteredEvents;
      exports3._logInternalMessage = applicationinsightsCoreJs._logInternalMessage;
      exports3._throwInternal = applicationinsightsCoreJs._throwInternal;
      exports3._warnToConsole = applicationinsightsCoreJs._warnToConsole;
      exports3.addEventHandler = applicationinsightsCoreJs.addEventHandler;
      exports3.addEventListeners = applicationinsightsCoreJs.addEventListeners;
      exports3.addPageHideEventListener = applicationinsightsCoreJs.addPageHideEventListener;
      exports3.addPageShowEventListener = applicationinsightsCoreJs.addPageShowEventListener;
      exports3.addPageUnloadEventListener = applicationinsightsCoreJs.addPageUnloadEventListener;
      exports3.areCookiesSupported = applicationinsightsCoreJs.areCookiesSupported;
      exports3.arrForEach = applicationinsightsCoreJs.arrForEach;
      exports3.arrIndexOf = applicationinsightsCoreJs.arrIndexOf;
      exports3.arrMap = applicationinsightsCoreJs.arrMap;
      exports3.arrReduce = applicationinsightsCoreJs.arrReduce;
      exports3.attachEvent = applicationinsightsCoreJs.attachEvent;
      exports3.cookieAvailable = applicationinsightsCoreJs.areCookiesSupported;
      exports3.createCookieMgr = applicationinsightsCoreJs.createCookieMgr;
      exports3.createEnumStyle = applicationinsightsCoreJs.createEnumStyle;
      exports3.createProcessTelemetryContext = applicationinsightsCoreJs.createProcessTelemetryContext;
      exports3.createTraceParent = applicationinsightsCoreJs.createTraceParent;
      exports3.createUniqueNamespace = applicationinsightsCoreJs.createUniqueNamespace;
      exports3.createUnloadHandlerContainer = applicationinsightsCoreJs.createUnloadHandlerContainer;
      exports3.dateNow = applicationinsightsCoreJs.dateNow;
      exports3.detachEvent = applicationinsightsCoreJs.detachEvent;
      exports3.disallowsSameSiteNone = applicationinsightsCoreJs.uaDisallowsSameSiteNone;
      exports3.doPerf = applicationinsightsCoreJs.doPerf;
      exports3.dumpObj = applicationinsightsCoreJs.dumpObj;
      exports3.eventOff = applicationinsightsCoreJs.eventOff;
      exports3.eventOn = applicationinsightsCoreJs.eventOn;
      exports3.findW3cTraceParent = applicationinsightsCoreJs.findW3cTraceParent;
      exports3.formatTraceParent = applicationinsightsCoreJs.formatTraceParent;
      exports3.generateW3CId = applicationinsightsCoreJs.generateW3CId;
      exports3.getConsole = applicationinsightsCoreJs.getConsole;
      exports3.getCrypto = applicationinsightsCoreJs.getCrypto;
      exports3.getDocument = applicationinsightsCoreJs.getDocument;
      exports3.getExceptionName = applicationinsightsCoreJs.getExceptionName;
      exports3.getGlobal = applicationinsightsCoreJs.getGlobal;
      exports3.getGlobalInst = applicationinsightsCoreJs.getGlobalInst;
      exports3.getHistory = applicationinsightsCoreJs.getHistory;
      exports3.getIEVersion = applicationinsightsCoreJs.getIEVersion;
      exports3.getISOString = applicationinsightsCoreJs.toISOString;
      exports3.getJSON = applicationinsightsCoreJs.getJSON;
      exports3.getLocation = applicationinsightsCoreJs.getLocation;
      exports3.getMsCrypto = applicationinsightsCoreJs.getMsCrypto;
      exports3.getNavigator = applicationinsightsCoreJs.getNavigator;
      exports3.getPerformance = applicationinsightsCoreJs.getPerformance;
      exports3.getSetValue = applicationinsightsCoreJs.getSetValue;
      exports3.getWindow = applicationinsightsCoreJs.getWindow;
      exports3.hasDocument = applicationinsightsCoreJs.hasDocument;
      exports3.hasHistory = applicationinsightsCoreJs.hasHistory;
      exports3.hasJSON = applicationinsightsCoreJs.hasJSON;
      exports3.hasNavigator = applicationinsightsCoreJs.hasNavigator;
      exports3.hasOwnProperty = applicationinsightsCoreJs.hasOwnProperty;
      exports3.hasWindow = applicationinsightsCoreJs.hasWindow;
      exports3.isArray = applicationinsightsCoreJs.isArray;
      exports3.isBeaconsSupported = applicationinsightsCoreJs.isBeaconsSupported;
      exports3.isBoolean = applicationinsightsCoreJs.isBoolean;
      exports3.isDate = applicationinsightsCoreJs.isDate;
      exports3.isError = applicationinsightsCoreJs.isError;
      exports3.isFetchSupported = applicationinsightsCoreJs.isFetchSupported;
      exports3.isFunction = applicationinsightsCoreJs.isFunction;
      exports3.isIE = applicationinsightsCoreJs.isIE;
      exports3.isNotTruthy = applicationinsightsCoreJs.isNotTruthy;
      exports3.isNullOrUndefined = applicationinsightsCoreJs.isNullOrUndefined;
      exports3.isNumber = applicationinsightsCoreJs.isNumber;
      exports3.isObject = applicationinsightsCoreJs.isObject;
      exports3.isReactNative = applicationinsightsCoreJs.isReactNative;
      exports3.isSampledFlag = applicationinsightsCoreJs.isSampledFlag;
      exports3.isString = applicationinsightsCoreJs.isString;
      exports3.isTruthy = applicationinsightsCoreJs.isTruthy;
      exports3.isTypeof = applicationinsightsCoreJs.isTypeof;
      exports3.isUndefined = applicationinsightsCoreJs.isUndefined;
      exports3.isValidSpanId = applicationinsightsCoreJs.isValidSpanId;
      exports3.isValidTraceId = applicationinsightsCoreJs.isValidTraceId;
      exports3.isValidTraceParent = applicationinsightsCoreJs.isValidTraceParent;
      exports3.isXhrSupported = applicationinsightsCoreJs.isXhrSupported;
      exports3.mergeEvtNamespace = applicationinsightsCoreJs.mergeEvtNamespace;
      exports3.newGuid = applicationinsightsCoreJs.newGuid;
      exports3.newId = applicationinsightsCoreJs.newId;
      exports3.normalizeJsName = applicationinsightsCoreJs.normalizeJsName;
      exports3.objCreate = applicationinsightsCoreJs.objCreate;
      exports3.objDefineAccessors = applicationinsightsCoreJs.objDefineAccessors;
      exports3.objForEachKey = applicationinsightsCoreJs.objForEachKey;
      exports3.objFreeze = applicationinsightsCoreJs.objFreeze;
      exports3.objKeys = applicationinsightsCoreJs.objKeys;
      exports3.objSeal = applicationinsightsCoreJs.objSeal;
      exports3.optimizeObject = applicationinsightsCoreJs.optimizeObject;
      exports3.parseTraceParent = applicationinsightsCoreJs.parseTraceParent;
      exports3.perfNow = applicationinsightsCoreJs.perfNow;
      exports3.proxyAssign = applicationinsightsCoreJs.proxyAssign;
      exports3.proxyFunctionAs = applicationinsightsCoreJs.proxyFunctionAs;
      exports3.proxyFunctions = applicationinsightsCoreJs.proxyFunctions;
      exports3.random32 = applicationinsightsCoreJs.random32;
      exports3.randomValue = applicationinsightsCoreJs.randomValue;
      exports3.removeEventHandler = applicationinsightsCoreJs.removeEventHandler;
      exports3.removeEventListeners = applicationinsightsCoreJs.removeEventListeners;
      exports3.removePageHideEventListener = applicationinsightsCoreJs.removePageHideEventListener;
      exports3.removePageShowEventListener = applicationinsightsCoreJs.removePageShowEventListener;
      exports3.removePageUnloadEventListener = applicationinsightsCoreJs.removePageUnloadEventListener;
      exports3.safeGetCookieMgr = applicationinsightsCoreJs.safeGetCookieMgr;
      exports3.safeGetLogger = applicationinsightsCoreJs.safeGetLogger;
      exports3.setEnableEnvMocks = applicationinsightsCoreJs.setEnableEnvMocks;
      exports3.setValue = applicationinsightsCoreJs.setValue;
      exports3.strContains = applicationinsightsCoreJs.strContains;
      exports3.strEndsWith = applicationinsightsCoreJs.strEndsWith;
      exports3.strFunction = applicationinsightsCoreJs.strFunction;
      exports3.strObject = applicationinsightsCoreJs.strObject;
      exports3.strPrototype = applicationinsightsCoreJs.strPrototype;
      exports3.strStartsWith = applicationinsightsCoreJs.strStartsWith;
      exports3.strTrim = applicationinsightsCoreJs.strTrim;
      exports3.strUndefined = applicationinsightsCoreJs.strUndefined;
      exports3.throwError = applicationinsightsCoreJs.throwError;
      exports3.toISOString = applicationinsightsCoreJs.toISOString;
      exports3.useXDomainRequest = applicationinsightsCoreJs.useXDomainRequest;
      exports3.AppInsightsCore = AppInsightsCore;
      exports3.BaseCore = BaseCore;
      exports3.CoreUtils = CoreUtils;
      exports3.ESPromise = ESPromise;
      exports3.ESPromiseScheduler = ESPromiseScheduler;
      exports3.EventLatency = EventLatency;
      exports3.EventPersistence = EventPersistence;
      exports3.EventPropertyType = EventPropertyType;
      exports3.FullVersionString = FullVersionString;
      exports3.TraceLevel = TraceLevel;
      exports3.Utils = Utils;
      exports3.ValueKind = ValueKind;
      exports3.ValueSanitizer = ValueSanitizer;
      exports3.Version = Version;
      exports3._ExtendedInternalMessageId = _ExtendedInternalMessageId;
      exports3.createGuid = createGuid;
      exports3.deleteCookie = deleteCookie;
      exports3.disableCookies = disableCookies;
      exports3.extend = extend;
      exports3.getCommonSchemaMetaData = getCommonSchemaMetaData;
      exports3.getCookie = getCookie;
      exports3.getCookieValue = getCookieValue;
      exports3.getFieldValueType = getFieldValueType;
      exports3.getTenantId = getTenantId;
      exports3.getTime = getTime;
      exports3.isArrayValid = isArrayValid;
      exports3.isChromium = isChromium;
      exports3.isDocumentObjectAvailable = isDocumentObjectAvailable;
      exports3.isLatency = isLatency;
      exports3.isUint8ArrayAvailable = isUint8ArrayAvailable;
      exports3.isValueAssigned = isValueAssigned;
      exports3.isValueKind = isValueKind;
      exports3.isWindowObjectAvailable = isWindowObjectAvailable;
      exports3.openXhr = openXhr;
      exports3.sanitizeProperty = sanitizeProperty;
      exports3.setCookie = setCookie;
      exports3.setProcessTelemetryTimings = setProcessTelemetryTimings;
      (function(obj, prop, descriptor) {
        var func = Object["defineProperty"];
        if (func) {
          try {
            return func(obj, prop, descriptor);
          } catch (e) {
          }
        }
        if (descriptor && typeof descriptor.value !== void 0) {
          obj[prop] = descriptor.value;
        }
        return obj;
      })(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@microsoft/1ds-post-js/dist/ms.post.js
var require_ms_post = __commonJS({
  "node_modules/@microsoft/1ds-post-js/dist/ms.post.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_applicationinsights_shims(), require_dynamicproto_js(), require_ms_core()) : typeof define === "function" && define.amd ? define(["exports", "@microsoft/applicationinsights-shims", "@microsoft/dynamicproto-js", "@microsoft/1ds-core-js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.oneDS = global2.oneDS || {}, global2.applicationinsightsShims, global2.dynamicProto, global2._1dsCoreJs));
    })(exports2, function(exports3, applicationinsightsShims, dynamicProto, _1dsCoreJs) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e["default"] : e;
      }
      var dynamicProto__default = /* @__PURE__ */ _interopDefaultLegacy(dynamicProto);
      var RT_PROFILE = "REAL_TIME";
      var NRT_PROFILE = "NEAR_REAL_TIME";
      var BE_PROFILE = "BEST_EFFORT";
      var STR_EMPTY = "";
      var STR_POST_METHOD = "POST";
      var STR_DISABLED_PROPERTY_NAME = "Microsoft_ApplicationInsights_BypassAjaxInstrumentation";
      var STR_DROPPED = "drop";
      var STR_SENDING = "send";
      var STR_REQUEUE = "requeue";
      var STR_RESPONSE_FAIL = "rspFail";
      var STR_OTHER = "oth";
      var DEFAULT_CACHE_CONTROL = "no-cache, no-store";
      var DEFAULT_CONTENT_TYPE = "application/x-json-stream";
      var STR_CACHE_CONTROL = "cache-control";
      var STR_CONTENT_TYPE_HEADER = "content-type";
      var STR_KILL_TOKENS_HEADER = "kill-tokens";
      var STR_KILL_DURATION_HEADER = "kill-duration";
      var STR_KILL_DURATION_SECONDS_HEADER = "kill-duration-seconds";
      var STR_TIME_DELTA_HEADER = "time-delta-millis";
      var STR_CLIENT_VERSION = "client-version";
      var STR_CLIENT_ID = "client-id";
      var STR_TIME_DELTA_TO_APPLY = "time-delta-to-apply-millis";
      var STR_UPLOAD_TIME = "upload-time";
      var STR_API_KEY = "apikey";
      var STR_MSA_DEVICE_TICKET = "AuthMsaDeviceTicket";
      var STR_AUTH_XTOKEN = "AuthXToken";
      var STR_NO_RESPONSE_BODY = "NoResponseBody";
      var STR_MSFPC = "msfpc";
      var STR_TRACE = "trace";
      var STR_USER = "user";
      function _getEventMsfpc(theEvent) {
        var intWeb = (theEvent.ext || {})["intweb"];
        if (intWeb && _1dsCoreJs.isValueAssigned(intWeb[STR_MSFPC])) {
          return intWeb[STR_MSFPC];
        }
        return null;
      }
      function _getMsfpc(theEvents) {
        var msfpc = null;
        for (var lp = 0; msfpc === null && lp < theEvents.length; lp++) {
          msfpc = _getEventMsfpc(theEvents[lp]);
        }
        return msfpc;
      }
      var EventBatch = (
        /** @class */
        function() {
          function EventBatch2(iKey, addEvents) {
            var events = addEvents ? [].concat(addEvents) : [];
            var _self = this;
            var _msfpc = _getMsfpc(events);
            _self.iKey = function() {
              return iKey;
            };
            _self.Msfpc = function() {
              return _msfpc || STR_EMPTY;
            };
            _self.count = function() {
              return events.length;
            };
            _self.events = function() {
              return events;
            };
            _self.addEvent = function(theEvent) {
              if (theEvent) {
                events.push(theEvent);
                if (!_msfpc) {
                  _msfpc = _getEventMsfpc(theEvent);
                }
                return true;
              }
              return false;
            };
            _self.split = function(fromEvent, numEvents) {
              var theEvents;
              if (fromEvent < events.length) {
                var cnt = events.length - fromEvent;
                if (!_1dsCoreJs.isNullOrUndefined(numEvents)) {
                  cnt = numEvents < cnt ? numEvents : cnt;
                }
                theEvents = events.splice(fromEvent, cnt);
                _msfpc = _getMsfpc(events);
              }
              return new EventBatch2(iKey, theEvents);
            };
          }
          EventBatch2.create = function(iKey, theEvents) {
            return new EventBatch2(iKey, theEvents);
          };
          return EventBatch2;
        }()
      );
      var ClockSkewManager = (
        /** @class */
        function() {
          function ClockSkewManager2() {
            var _allowRequestSending = true;
            var _shouldAddClockSkewHeaders = true;
            var _isFirstRequest = true;
            var _clockSkewHeaderValue = "use-collector-delta";
            var _clockSkewSet = false;
            dynamicProto__default(ClockSkewManager2, this, function(_self) {
              _self.allowRequestSending = function() {
                return _allowRequestSending;
              };
              _self.firstRequestSent = function() {
                if (_isFirstRequest) {
                  _isFirstRequest = false;
                  if (!_clockSkewSet) {
                    _allowRequestSending = false;
                  }
                }
              };
              _self.shouldAddClockSkewHeaders = function() {
                return _shouldAddClockSkewHeaders;
              };
              _self.getClockSkewHeaderValue = function() {
                return _clockSkewHeaderValue;
              };
              _self.setClockSkew = function(timeDeltaInMillis) {
                if (!_clockSkewSet) {
                  if (timeDeltaInMillis) {
                    _clockSkewHeaderValue = timeDeltaInMillis;
                    _shouldAddClockSkewHeaders = true;
                    _clockSkewSet = true;
                  } else {
                    _shouldAddClockSkewHeaders = false;
                  }
                  _allowRequestSending = true;
                }
              };
            });
          }
          ClockSkewManager2.__ieDyn = 1;
          return ClockSkewManager2;
        }()
      );
      var SecToMsMultiplier = 1e3;
      var KillSwitch = (
        /** @class */
        function() {
          function KillSwitch2() {
            var _killedTokenDictionary = {};
            function _normalizeTenants(values) {
              var result = [];
              if (values) {
                _1dsCoreJs.arrForEach(values, function(value) {
                  result.push(_1dsCoreJs.strTrim(value));
                });
              }
              return result;
            }
            dynamicProto__default(KillSwitch2, this, function(_self) {
              _self.setKillSwitchTenants = function(killTokens, killDuration) {
                if (killTokens && killDuration) {
                  try {
                    var killedTokens = _normalizeTenants(killTokens.split(","));
                    if (killDuration === "this-request-only") {
                      return killedTokens;
                    }
                    var durationMs = parseInt(killDuration, 10) * SecToMsMultiplier;
                    for (var i = 0; i < killedTokens.length; ++i) {
                      _killedTokenDictionary[killedTokens[i]] = _1dsCoreJs.dateNow() + durationMs;
                    }
                  } catch (ex) {
                    return [];
                  }
                }
                return [];
              };
              _self.isTenantKilled = function(tenantToken) {
                var killDictionary = _killedTokenDictionary;
                var name2 = _1dsCoreJs.strTrim(tenantToken);
                if (killDictionary[name2] !== void 0 && killDictionary[name2] > _1dsCoreJs.dateNow()) {
                  return true;
                }
                delete killDictionary[name2];
                return false;
              };
            });
          }
          KillSwitch2.__ieDyn = 1;
          return KillSwitch2;
        }()
      );
      var RandomizationLowerThreshold = 0.8;
      var RandomizationUpperThreshold = 1.2;
      var BaseBackoff = 3e3;
      var MaxBackoff = 6e5;
      function retryPolicyShouldRetryForStatus(httpStatusCode) {
        return !(httpStatusCode >= 300 && httpStatusCode < 500 && httpStatusCode != 408 && httpStatusCode != 429 || httpStatusCode == 501 || httpStatusCode == 505);
      }
      function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {
        var waitDuration = 0;
        var minBackoff = BaseBackoff * RandomizationLowerThreshold;
        var maxBackoff = BaseBackoff * RandomizationUpperThreshold;
        var randomBackoff = Math.floor(Math.random() * (maxBackoff - minBackoff)) + minBackoff;
        waitDuration = Math.pow(2, retriesSoFar) * randomBackoff;
        return Math.min(waitDuration, MaxBackoff);
      }
      var _MAX_STRING_JOINS = 20;
      var RequestSizeLimitBytes = 3984588;
      var BeaconRequestSizeLimitBytes = 65e3;
      var MaxRecordSize = 2e6;
      var MaxBeaconRecordSize = Math.min(MaxRecordSize, BeaconRequestSizeLimitBytes);
      var metadata = "metadata";
      var f = "f";
      var rCheckDot = /\./;
      var Serializer = (
        /** @class */
        function() {
          function Serializer2(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey) {
            var strData = "data";
            var strBaseData = "baseData";
            var strExt = "ext";
            var _checkForCompoundkey = !!enableCompoundKey;
            var _processSubMetaData = true;
            var _theSanitizer = valueSanitizer;
            var _isReservedCache = {};
            dynamicProto__default(Serializer2, this, function(_self) {
              _self.createPayload = function(retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {
                return {
                  apiKeys: [],
                  payloadBlob: STR_EMPTY,
                  overflow: null,
                  sizeExceed: [],
                  failedEvts: [],
                  batches: [],
                  numEvents: 0,
                  retryCnt,
                  isTeardown,
                  isSync,
                  isBeacon: isReducedPayload,
                  sendType,
                  sendReason
                };
              };
              _self.appendPayload = function(payload, theBatch, maxEventsPerBatch) {
                var canAddEvents = payload && theBatch && !payload.overflow;
                if (canAddEvents) {
                  _1dsCoreJs.doPerf(perfManager, function() {
                    return "Serializer:appendPayload";
                  }, function() {
                    var theEvents = theBatch.events();
                    var payloadBlob = payload.payloadBlob;
                    var payloadEvents = payload.numEvents;
                    var eventsAdded = false;
                    var sizeExceeded = [];
                    var failedEvts = [];
                    var isBeaconPayload = payload.isBeacon;
                    var requestMaxSize = isBeaconPayload ? BeaconRequestSizeLimitBytes : RequestSizeLimitBytes;
                    var recordMaxSize = isBeaconPayload ? MaxBeaconRecordSize : MaxRecordSize;
                    var lp = 0;
                    var joinCount = 0;
                    while (lp < theEvents.length) {
                      var theEvent = theEvents[lp];
                      if (theEvent) {
                        if (payloadEvents >= maxEventsPerBatch) {
                          payload.overflow = theBatch.split(lp);
                          break;
                        }
                        var eventBlob = _self.getEventBlob(theEvent);
                        if (eventBlob && eventBlob.length <= recordMaxSize) {
                          var blobLength = eventBlob.length;
                          var currentSize = payloadBlob.length;
                          if (currentSize + blobLength > requestMaxSize) {
                            payload.overflow = theBatch.split(lp);
                            break;
                          }
                          if (payloadBlob) {
                            payloadBlob += "\n";
                          }
                          payloadBlob += eventBlob;
                          joinCount++;
                          if (joinCount > _MAX_STRING_JOINS) {
                            payloadBlob.substr(0, 1);
                            joinCount = 0;
                          }
                          eventsAdded = true;
                          payloadEvents++;
                        } else {
                          if (eventBlob) {
                            sizeExceeded.push(theEvent);
                          } else {
                            failedEvts.push(theEvent);
                          }
                          theEvents.splice(lp, 1);
                          lp--;
                        }
                      }
                      lp++;
                    }
                    if (sizeExceeded && sizeExceeded.length > 0) {
                      payload.sizeExceed.push(EventBatch.create(theBatch.iKey(), sizeExceeded));
                    }
                    if (failedEvts && failedEvts.length > 0) {
                      payload.failedEvts.push(EventBatch.create(theBatch.iKey(), failedEvts));
                    }
                    if (eventsAdded) {
                      payload.batches.push(theBatch);
                      payload.payloadBlob = payloadBlob;
                      payload.numEvents = payloadEvents;
                      var apiKey = theBatch.iKey();
                      if (_1dsCoreJs.arrIndexOf(payload.apiKeys, apiKey) === -1) {
                        payload.apiKeys.push(apiKey);
                      }
                    }
                  }, function() {
                    return { payload, theBatch: { iKey: theBatch.iKey(), evts: theBatch.events() }, max: maxEventsPerBatch };
                  });
                }
                return canAddEvents;
              };
              _self.getEventBlob = function(eventData) {
                try {
                  return _1dsCoreJs.doPerf(perfManager, function() {
                    return "Serializer.getEventBlob";
                  }, function() {
                    var serializedEvent = {};
                    serializedEvent.name = eventData.name;
                    serializedEvent.time = eventData.time;
                    serializedEvent.ver = eventData.ver;
                    serializedEvent.iKey = "o:" + _1dsCoreJs.getTenantId(eventData.iKey);
                    var serializedExt = {};
                    var eventExt = eventData[strExt];
                    if (eventExt) {
                      serializedEvent[strExt] = serializedExt;
                      _1dsCoreJs.objForEachKey(eventExt, function(key, value) {
                        var data = serializedExt[key] = {};
                        _processPathKeys(value, data, "ext." + key, true, null, null, true);
                      });
                    }
                    var serializedData = serializedEvent[strData] = {};
                    serializedData.baseType = eventData.baseType;
                    var serializedBaseData = serializedData[strBaseData] = {};
                    _processPathKeys(eventData.baseData, serializedBaseData, strBaseData, false, [strBaseData], function(pathKeys, name2, value) {
                      _addJSONPropertyMetaData(serializedExt, pathKeys, name2, value);
                    }, _processSubMetaData);
                    _processPathKeys(eventData.data, serializedData, strData, false, [], function(pathKeys, name2, value) {
                      _addJSONPropertyMetaData(serializedExt, pathKeys, name2, value);
                    }, _processSubMetaData);
                    return JSON.stringify(serializedEvent);
                  }, function() {
                    return { item: eventData };
                  });
                } catch (e) {
                  return null;
                }
              };
              function _isReservedField(path2, name2) {
                var result = _isReservedCache[path2];
                if (result === void 0) {
                  if (path2.length >= 7) {
                    result = _1dsCoreJs.strStartsWith(path2, "ext.metadata") || _1dsCoreJs.strStartsWith(path2, "ext.web");
                  }
                  _isReservedCache[path2] = result;
                }
                return result;
              }
              function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {
                _1dsCoreJs.objForEachKey(srcObj, function(key, srcValue) {
                  var prop = null;
                  if (srcValue || _1dsCoreJs.isValueAssigned(srcValue)) {
                    var path2 = thePath;
                    var name_1 = key;
                    var theMetaPathKeys = metadataPathKeys;
                    var destObj = target;
                    if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {
                      var subKeys = key.split(".");
                      var keyLen = subKeys.length;
                      if (keyLen > 1) {
                        if (theMetaPathKeys) {
                          theMetaPathKeys = theMetaPathKeys.slice();
                        }
                        for (var lp = 0; lp < keyLen - 1; lp++) {
                          var subKey = subKeys[lp];
                          destObj = destObj[subKey] = destObj[subKey] || {};
                          path2 += "." + subKey;
                          if (theMetaPathKeys) {
                            theMetaPathKeys.push(subKey);
                          }
                        }
                        name_1 = subKeys[keyLen - 1];
                      }
                    }
                    var isReserved = checkReserved && _isReservedField(path2);
                    if (!isReserved && _theSanitizer && _theSanitizer.handleField(path2, name_1)) {
                      prop = _theSanitizer.value(path2, name_1, srcValue, stringifyObjects);
                    } else {
                      prop = _1dsCoreJs.sanitizeProperty(name_1, srcValue, stringifyObjects);
                    }
                    if (prop) {
                      var newValue = prop.value;
                      destObj[name_1] = newValue;
                      if (metadataCallback) {
                        metadataCallback(theMetaPathKeys, name_1, prop);
                      }
                      if (processSubKeys && typeof newValue === "object" && !_1dsCoreJs.isArray(newValue)) {
                        var newPath = theMetaPathKeys;
                        if (newPath) {
                          newPath = newPath.slice();
                          newPath.push(name_1);
                        }
                        _processPathKeys(srcValue, newValue, path2 + "." + name_1, checkReserved, newPath, metadataCallback, processSubKeys);
                      }
                    }
                  }
                });
              }
            });
          }
          Serializer2.__ieDyn = 1;
          return Serializer2;
        }()
      );
      function _addJSONPropertyMetaData(json, propKeys, name2, propertyValue) {
        if (propertyValue && json) {
          var encodedTypeValue = _1dsCoreJs.getCommonSchemaMetaData(propertyValue.value, propertyValue.kind, propertyValue.propertyType);
          if (encodedTypeValue > -1) {
            var metaData = json[metadata];
            if (!metaData) {
              metaData = json[metadata] = { f: {} };
            }
            var metaTarget = metaData[f];
            if (!metaTarget) {
              metaTarget = metaData[f] = {};
            }
            if (propKeys) {
              for (var lp = 0; lp < propKeys.length; lp++) {
                var key = propKeys[lp];
                if (!metaTarget[key]) {
                  metaTarget[key] = { f: {} };
                }
                var newTarget = metaTarget[key][f];
                if (!newTarget) {
                  newTarget = metaTarget[key][f] = {};
                }
                metaTarget = newTarget;
              }
            }
            metaTarget = metaTarget[name2] = {};
            if (_1dsCoreJs.isArray(propertyValue.value)) {
              metaTarget["a"] = {
                t: encodedTypeValue
              };
            } else {
              metaTarget["t"] = encodedTypeValue;
            }
          }
        }
      }
      var _a;
      var strSendAttempt = "sendAttempt";
      var _noResponseQs = "&" + STR_NO_RESPONSE_BODY + "=true";
      var _eventActionMap = (_a = {}, _a[1] = STR_REQUEUE, _a[100] = STR_REQUEUE, _a[200] = "sent", _a[8004] = STR_DROPPED, _a[8003] = STR_DROPPED, _a);
      var _collectorQsHeaders = {};
      var _collectorHeaderToQs = {};
      function _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {
        _collectorQsHeaders[qsName] = headerName;
        if (allowQs !== false) {
          _collectorHeaderToQs[headerName] = qsName;
        }
      }
      _addCollectorHeaderQsMapping(STR_MSA_DEVICE_TICKET, STR_MSA_DEVICE_TICKET, false);
      _addCollectorHeaderQsMapping(STR_CLIENT_VERSION, STR_CLIENT_VERSION);
      _addCollectorHeaderQsMapping(STR_CLIENT_ID, "Client-Id");
      _addCollectorHeaderQsMapping(STR_API_KEY, STR_API_KEY);
      _addCollectorHeaderQsMapping(STR_TIME_DELTA_TO_APPLY, STR_TIME_DELTA_TO_APPLY);
      _addCollectorHeaderQsMapping(STR_UPLOAD_TIME, STR_UPLOAD_TIME);
      _addCollectorHeaderQsMapping(STR_AUTH_XTOKEN, STR_AUTH_XTOKEN);
      function _getResponseText(xhr) {
        try {
          return xhr.responseText;
        } catch (e) {
        }
        return STR_EMPTY;
      }
      function _hasHeader(headers, header) {
        var hasHeader = false;
        if (headers && header) {
          var keys = _1dsCoreJs.objKeys(headers);
          if (keys && keys.length > 0) {
            var lowerHeader = header.toLowerCase();
            for (var lp = 0; lp < keys.length; lp++) {
              var value = keys[lp];
              if (value && _1dsCoreJs.hasOwnProperty(header, value) && value.toLowerCase() === lowerHeader) {
                hasHeader = true;
                break;
              }
            }
          }
        }
        return hasHeader;
      }
      function _addRequestDetails(details, name2, value, useHeaders) {
        if (name2 && value && value.length > 0) {
          if (useHeaders && _collectorQsHeaders[name2]) {
            details.hdrs[_collectorQsHeaders[name2]] = value;
            details.useHdrs = true;
          } else {
            details.url += "&" + name2 + "=" + value;
          }
        }
      }
      function _prependTransports(theTransports, newTransports) {
        if (newTransports) {
          if (_1dsCoreJs.isNumber(newTransports)) {
            theTransports = [newTransports].concat(theTransports);
          } else if (_1dsCoreJs.isArray(newTransports)) {
            theTransports = newTransports.concat(theTransports);
          }
        }
        return theTransports;
      }
      var HttpManager = (
        /** @class */
        function() {
          function HttpManager2(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions, timeoutOverride) {
            this._responseHandlers = [];
            var _urlString = "?cors=true&" + STR_CONTENT_TYPE_HEADER.toLowerCase() + "=" + DEFAULT_CONTENT_TYPE;
            var _killSwitch = new KillSwitch();
            var _paused = false;
            var _clockSkewManager = new ClockSkewManager();
            var _useBeacons = false;
            var _outstandingRequests = 0;
            var _postManager;
            var _logger;
            var _sendInterfaces;
            var _core;
            var _customHttpInterface = true;
            var _queryStringParameters = [];
            var _headers = {};
            var _batchQueue = [];
            var _serializer = null;
            var _enableEventTimings = false;
            var _cookieMgr;
            var _isUnloading = false;
            var _useHeaders = false;
            var _xhrTimeout;
            var _disableXhrSync;
            var _disableFetchKeepAlive;
            var _canHaveReducedPayload;
            var _addNoResponse;
            dynamicProto__default(HttpManager2, this, function(_self) {
              var _sendCredentials = true;
              _self.initialize = function(endpointUrl, core, postChannel, httpInterface, channelConfig) {
                var _a2;
                if (!channelConfig) {
                  channelConfig = {};
                }
                _urlString = endpointUrl + _urlString;
                _useHeaders = !_1dsCoreJs.isUndefined(channelConfig.avoidOptions) ? !channelConfig.avoidOptions : true;
                _core = core;
                _cookieMgr = core.getCookieMgr();
                _enableEventTimings = !_core.config.disableEventTimings;
                var enableCompoundKey = !!_core.config.enableCompoundKey;
                _postManager = postChannel;
                _logger = _postManager.diagLog();
                var valueSanitizer = channelConfig.valueSanitizer;
                var stringifyObjects = channelConfig.stringifyObjects;
                if (!_1dsCoreJs.isUndefined(channelConfig.enableCompoundKey)) {
                  enableCompoundKey = !!channelConfig.enableCompoundKey;
                }
                _xhrTimeout = channelConfig.xhrTimeout;
                _disableXhrSync = !!channelConfig.disableXhrSync;
                _disableFetchKeepAlive = !!channelConfig.disableFetchKeepAlive;
                _addNoResponse = channelConfig.addNoResponse !== false;
                _useBeacons = !_1dsCoreJs.isReactNative();
                _serializer = new Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey);
                if (!_1dsCoreJs.isNullOrUndefined(channelConfig.useSendBeacon)) {
                  _useBeacons = !!channelConfig.useSendBeacon;
                }
                var syncHttpInterface = httpInterface;
                var beaconHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null;
                var fetchSyncHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null;
                var beaconUnloadTransports = [3, 2];
                if (!httpInterface) {
                  _customHttpInterface = false;
                  var location_1 = _1dsCoreJs.getLocation();
                  if (location_1 && location_1.protocol && location_1.protocol.toLowerCase() === "file:") {
                    _sendCredentials = false;
                  }
                  var theTransports = [];
                  if (_1dsCoreJs.isReactNative()) {
                    theTransports = [2, 1];
                    beaconUnloadTransports = [2, 1, 3];
                  } else {
                    theTransports = [1, 2, 3];
                  }
                  theTransports = _prependTransports(theTransports, channelConfig.transports);
                  httpInterface = _getSenderInterface(theTransports, false);
                  if (!httpInterface) {
                    _1dsCoreJs._warnToConsole(_logger, "No available transport to send events");
                  }
                  syncHttpInterface = _getSenderInterface(theTransports, true);
                }
                if (!beaconHttpInterface) {
                  beaconUnloadTransports = _prependTransports(beaconUnloadTransports, channelConfig.unloadTransports);
                  beaconHttpInterface = _getSenderInterface(beaconUnloadTransports, true);
                }
                _canHaveReducedPayload = !_customHttpInterface && (_useBeacons && _1dsCoreJs.isBeaconsSupported() || !_disableFetchKeepAlive && _1dsCoreJs.isFetchSupported(true));
                _sendInterfaces = (_a2 = {}, _a2[0] = httpInterface, _a2[1] = syncHttpInterface || _getSenderInterface([1, 2, 3], true), _a2[2] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([1], true), _a2[3] = fetchSyncHttpInterface || _getSenderInterface([2, 3], true) || syncHttpInterface || _getSenderInterface([1], true), _a2);
              };
              function _getSenderInterface(transports, syncSupport) {
                var transportType = 0;
                var sendPostFunc = null;
                var lp = 0;
                while (sendPostFunc == null && lp < transports.length) {
                  transportType = transports[lp];
                  if (transportType === 1) {
                    if (_1dsCoreJs.useXDomainRequest()) {
                      sendPostFunc = _xdrSendPost;
                    } else if (_1dsCoreJs.isXhrSupported()) {
                      sendPostFunc = _xhrSendPost;
                    }
                  } else if (transportType === 2 && _1dsCoreJs.isFetchSupported(syncSupport) && (!syncSupport || syncSupport && !_disableFetchKeepAlive)) {
                    sendPostFunc = _fetchSendPost;
                  } else if (_useBeacons && transportType === 3 && _1dsCoreJs.isBeaconsSupported()) {
                    sendPostFunc = _beaconSendPost;
                  }
                  lp++;
                }
                if (sendPostFunc) {
                  return {
                    _transport: transportType,
                    _isSync: syncSupport,
                    sendPOST: sendPostFunc
                  };
                }
                return null;
              }
              _self["_getDbgPlgTargets"] = function() {
                return [_sendInterfaces[0], _killSwitch, _serializer, _sendInterfaces];
              };
              function _xdrSendPost(payload, oncomplete, sync) {
                var xdr = new XDomainRequest();
                xdr.open(STR_POST_METHOD, payload.urlString);
                if (payload.timeout) {
                  xdr.timeout = payload.timeout;
                }
                xdr.onload = function() {
                  var response = _getResponseText(xdr);
                  _doOnComplete(oncomplete, 200, {}, response);
                  _handleCollectorResponse(response);
                };
                xdr.onerror = function() {
                  _doOnComplete(oncomplete, 400, {});
                };
                xdr.ontimeout = function() {
                  _doOnComplete(oncomplete, 500, {});
                };
                xdr.onprogress = function() {
                };
                if (sync) {
                  xdr.send(payload.data);
                } else {
                  timeoutOverride.set(function() {
                    xdr.send(payload.data);
                  }, 0);
                }
              }
              function _fetchSendPost(payload, oncomplete, sync) {
                var _a2;
                var theUrl = payload.urlString;
                var ignoreResponse = false;
                var responseHandled = false;
                var requestInit = (_a2 = {
                  body: payload.data,
                  method: STR_POST_METHOD
                }, _a2[STR_DISABLED_PROPERTY_NAME] = true, _a2);
                if (sync) {
                  requestInit.keepalive = true;
                  if (payload._sendReason === 2) {
                    ignoreResponse = true;
                    if (_addNoResponse) {
                      theUrl += _noResponseQs;
                    }
                  }
                }
                if (_sendCredentials) {
                  requestInit.credentials = "include";
                }
                if (payload.headers && _1dsCoreJs.objKeys(payload.headers).length > 0) {
                  requestInit.headers = payload.headers;
                }
                fetch(theUrl, requestInit).then(function(response) {
                  var headerMap = {};
                  var responseText = STR_EMPTY;
                  var headers = response.headers;
                  if (headers) {
                    headers["forEach"](function(value, name2) {
                      headerMap[name2] = value;
                    });
                  }
                  if (response.body) {
                    response.text().then(function(text) {
                      responseText = text;
                    });
                  }
                  if (!responseHandled) {
                    responseHandled = true;
                    _doOnComplete(oncomplete, response.status, headerMap, responseText);
                    _handleCollectorResponse(responseText);
                  }
                })["catch"](function(error) {
                  if (!responseHandled) {
                    responseHandled = true;
                    _doOnComplete(oncomplete, 0, {});
                  }
                });
                if (ignoreResponse && !responseHandled) {
                  responseHandled = true;
                  _doOnComplete(oncomplete, 200, {});
                }
                if (!responseHandled && payload.timeout > 0) {
                  timeoutOverride.set(function() {
                    if (!responseHandled) {
                      responseHandled = true;
                      _doOnComplete(oncomplete, 500, {});
                    }
                  }, payload.timeout);
                }
              }
              function _xhrSendPost(payload, oncomplete, sync) {
                var theUrl = payload.urlString;
                function _appendHeader(theHeaders, xhr, name2) {
                  if (!theHeaders[name2] && xhr && xhr.getResponseHeader) {
                    var value = xhr.getResponseHeader(name2);
                    if (value) {
                      theHeaders[name2] = _1dsCoreJs.strTrim(value);
                    }
                  }
                  return theHeaders;
                }
                function _getAllResponseHeaders(xhr) {
                  var theHeaders = {};
                  if (!xhr.getAllResponseHeaders) {
                    theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);
                    theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);
                    theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);
                  } else {
                    theHeaders = _convertAllHeadersToMap(xhr.getAllResponseHeaders());
                  }
                  return theHeaders;
                }
                function xhrComplete(xhr, responseTxt) {
                  _doOnComplete(oncomplete, xhr.status, _getAllResponseHeaders(xhr), responseTxt);
                }
                if (sync && payload.disableXhrSync) {
                  sync = false;
                }
                var xhrRequest = _1dsCoreJs.openXhr(STR_POST_METHOD, theUrl, _sendCredentials, true, sync, payload.timeout);
                _1dsCoreJs.objForEachKey(payload.headers, function(name2, value) {
                  xhrRequest.setRequestHeader(name2, value);
                });
                xhrRequest.onload = function() {
                  var response = _getResponseText(xhrRequest);
                  xhrComplete(xhrRequest, response);
                  _handleCollectorResponse(response);
                };
                xhrRequest.onerror = function() {
                  xhrComplete(xhrRequest);
                };
                xhrRequest.ontimeout = function() {
                  xhrComplete(xhrRequest);
                };
                xhrRequest.send(payload.data);
              }
              function _doOnComplete(oncomplete, status, headers, response) {
                try {
                  oncomplete(status, headers, response);
                } catch (e) {
                  _1dsCoreJs._throwInternal(_logger, 2, 518, _1dsCoreJs.dumpObj(e));
                }
              }
              function _beaconSendPost(payload, oncomplete, sync) {
                var internalPayloadData = payload;
                var status = 200;
                var thePayload = internalPayloadData._thePayload;
                var theUrl = payload.urlString + (_addNoResponse ? _noResponseQs : STR_EMPTY);
                try {
                  var nav_1 = _1dsCoreJs.getNavigator();
                  if (!nav_1.sendBeacon(theUrl, payload.data)) {
                    if (thePayload) {
                      var droppedBatches_1 = [];
                      _1dsCoreJs.arrForEach(thePayload.batches, function(theBatch) {
                        if (droppedBatches_1 && theBatch && theBatch.count() > 0) {
                          var theEvents = theBatch.events();
                          for (var lp = 0; lp < theEvents.length; lp++) {
                            if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {
                              droppedBatches_1.push(theBatch.split(lp));
                              break;
                            }
                          }
                        } else {
                          droppedBatches_1.push(theBatch.split(0));
                        }
                      });
                      _sendBatchesNotification(droppedBatches_1, 8003, thePayload.sendType, true);
                    } else {
                      status = 0;
                    }
                  }
                } catch (ex) {
                  _1dsCoreJs._warnToConsole(_logger, "Failed to send telemetry using sendBeacon API. Ex:" + _1dsCoreJs.dumpObj(ex));
                  status = 0;
                } finally {
                  _doOnComplete(oncomplete, status, {}, STR_EMPTY);
                }
              }
              function _isBeaconPayload(sendType) {
                return sendType === 2 || sendType === 3;
              }
              function _adjustSendType(sendType) {
                if (_isUnloading && _isBeaconPayload(sendType)) {
                  sendType = 2;
                }
                return sendType;
              }
              _self.addQueryStringParameter = function(name2, value) {
                for (var i = 0; i < _queryStringParameters.length; i++) {
                  if (_queryStringParameters[i].name === name2) {
                    _queryStringParameters[i].value = value;
                    return;
                  }
                }
                _queryStringParameters.push({ name: name2, value });
              };
              _self.addHeader = function(name2, value) {
                _headers[name2] = value;
              };
              _self.canSendRequest = function() {
                return _hasIdleConnection() && _clockSkewManager.allowRequestSending();
              };
              _self.sendQueuedRequests = function(sendType, sendReason) {
                if (_1dsCoreJs.isUndefined(sendType)) {
                  sendType = 0;
                }
                if (_isUnloading) {
                  sendType = _adjustSendType(sendType);
                  sendReason = 2;
                }
                if (_canSendPayload(_batchQueue, sendType, 0)) {
                  _sendBatches(_clearQueue(), 0, false, sendType, sendReason || 0);
                }
              };
              _self.isCompletelyIdle = function() {
                return !_paused && _outstandingRequests === 0 && _batchQueue.length === 0;
              };
              _self.setUnloading = function(value) {
                _isUnloading = value;
              };
              _self.addBatch = function(theBatch) {
                if (theBatch && theBatch.count() > 0) {
                  if (_killSwitch.isTenantKilled(theBatch.iKey())) {
                    return false;
                  }
                  _batchQueue.push(theBatch);
                }
                return true;
              };
              _self.teardown = function() {
                if (_batchQueue.length > 0) {
                  _sendBatches(_clearQueue(), 0, true, 2, 2);
                }
              };
              _self.pause = function() {
                _paused = true;
              };
              _self.resume = function() {
                _paused = false;
                _self.sendQueuedRequests(0, 4);
              };
              _self.sendSynchronousBatch = function(batch, sendType, sendReason) {
                if (batch && batch.count() > 0) {
                  if (_1dsCoreJs.isNullOrUndefined(sendType)) {
                    sendType = 1;
                  }
                  if (_isUnloading) {
                    sendType = _adjustSendType(sendType);
                    sendReason = 2;
                  }
                  _sendBatches([batch], 0, false, sendType, sendReason || 0);
                }
              };
              function _hasIdleConnection() {
                return !_paused && _outstandingRequests < maxConnections;
              }
              function _clearQueue() {
                var theQueue = _batchQueue;
                _batchQueue = [];
                return theQueue;
              }
              function _canSendPayload(theBatches, sendType, retryCnt) {
                var result = false;
                if (theBatches && theBatches.length > 0 && !_paused && _sendInterfaces[sendType] && _serializer) {
                  result = sendType !== 0 || _hasIdleConnection() && (retryCnt > 0 || _clockSkewManager.allowRequestSending());
                }
                return result;
              }
              function _createDebugBatches(theBatches) {
                var values = {};
                if (theBatches) {
                  _1dsCoreJs.arrForEach(theBatches, function(theBatch, idx) {
                    values[idx] = {
                      iKey: theBatch.iKey(),
                      evts: theBatch.events()
                    };
                  });
                }
                return values;
              }
              function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {
                if (!theBatches || theBatches.length === 0) {
                  return;
                }
                if (_paused) {
                  _sendBatchesNotification(theBatches, 1, sendType);
                  return;
                }
                sendType = _adjustSendType(sendType);
                try {
                  var orgBatches_1 = theBatches;
                  var isSynchronous_1 = sendType !== 0;
                  _1dsCoreJs.doPerf(_core, function() {
                    return "HttpManager:_sendBatches";
                  }, function(perfEvt) {
                    if (perfEvt) {
                      theBatches = theBatches.slice(0);
                    }
                    var droppedBatches = [];
                    var thePayload = null;
                    var serializationStart = _1dsCoreJs.getTime();
                    var sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1] : _sendInterfaces[0]);
                    var sendTransport = sendInterface && sendInterface._transport;
                    var isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || (sendTransport === 3 || sendInterface._isSync && sendTransport === 2));
                    while (_canSendPayload(theBatches, sendType, retryCount)) {
                      var theBatch = theBatches.shift();
                      if (theBatch && theBatch.count() > 0) {
                        if (!_killSwitch.isTenantKilled(theBatch.iKey())) {
                          thePayload = thePayload || _serializer.createPayload(retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType);
                          if (!_serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch)) {
                            _doPayloadSend(thePayload, serializationStart, _1dsCoreJs.getTime(), sendReason);
                            serializationStart = _1dsCoreJs.getTime();
                            theBatches = [theBatch].concat(theBatches);
                            thePayload = null;
                          } else if (thePayload.overflow !== null) {
                            theBatches = [thePayload.overflow].concat(theBatches);
                            thePayload.overflow = null;
                            _doPayloadSend(thePayload, serializationStart, _1dsCoreJs.getTime(), sendReason);
                            serializationStart = _1dsCoreJs.getTime();
                            thePayload = null;
                          }
                        } else {
                          droppedBatches.push(theBatch);
                        }
                      }
                    }
                    if (thePayload) {
                      _doPayloadSend(thePayload, serializationStart, _1dsCoreJs.getTime(), sendReason);
                    }
                    if (theBatches.length > 0) {
                      _batchQueue = theBatches.concat(_batchQueue);
                    }
                    _sendBatchesNotification(droppedBatches, 8004, sendType);
                  }, function() {
                    return { batches: _createDebugBatches(orgBatches_1), retryCount, isTeardown, isSynchronous: isSynchronous_1, sendReason, useSendBeacon: _isBeaconPayload(sendType), sendType };
                  }, !isSynchronous_1);
                } catch (ex) {
                  _1dsCoreJs._throwInternal(_logger, 2, 48, "Unexpected Exception sending batch: " + _1dsCoreJs.dumpObj(ex));
                }
              }
              function _buildRequestDetails(thePayload, useHeaders) {
                var requestDetails = {
                  url: _urlString,
                  hdrs: {},
                  useHdrs: false
                };
                if (!useHeaders) {
                  _1dsCoreJs.objForEachKey(_headers, function(name2, value) {
                    if (_collectorHeaderToQs[name2]) {
                      _addRequestDetails(requestDetails, _collectorHeaderToQs[name2], value, false);
                    } else {
                      requestDetails.hdrs[name2] = value;
                      requestDetails.useHdrs = true;
                    }
                  });
                } else {
                  requestDetails.hdrs = _1dsCoreJs.extend(requestDetails.hdrs, _headers);
                  requestDetails.useHdrs = _1dsCoreJs.objKeys(requestDetails.hdrs).length > 0;
                }
                _addRequestDetails(requestDetails, STR_CLIENT_ID, "NO_AUTH", useHeaders);
                _addRequestDetails(requestDetails, STR_CLIENT_VERSION, _1dsCoreJs.FullVersionString, useHeaders);
                var apiQsKeys = STR_EMPTY;
                _1dsCoreJs.arrForEach(thePayload.apiKeys, function(apiKey) {
                  if (apiQsKeys.length > 0) {
                    apiQsKeys += ",";
                  }
                  apiQsKeys += apiKey;
                });
                _addRequestDetails(requestDetails, STR_API_KEY, apiQsKeys, useHeaders);
                _addRequestDetails(requestDetails, STR_UPLOAD_TIME, _1dsCoreJs.dateNow().toString(), useHeaders);
                var msfpc = _getMsfpc2(thePayload);
                if (_1dsCoreJs.isValueAssigned(msfpc)) {
                  requestDetails.url += "&ext.intweb.msfpc=" + msfpc;
                }
                if (_clockSkewManager.shouldAddClockSkewHeaders()) {
                  _addRequestDetails(requestDetails, STR_TIME_DELTA_TO_APPLY, _clockSkewManager.getClockSkewHeaderValue(), useHeaders);
                }
                if (_core.getWParam) {
                  var wParam = _core.getWParam();
                  if (wParam >= 0) {
                    requestDetails.url += "&w=" + wParam;
                  }
                }
                for (var i = 0; i < _queryStringParameters.length; i++) {
                  requestDetails.url += "&" + _queryStringParameters[i].name + "=" + _queryStringParameters[i].value;
                }
                return requestDetails;
              }
              function _setTimingValue(timings, name2, value) {
                timings[name2] = timings[name2] || {};
                timings[name2][_postManager.identifier] = value;
              }
              function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {
                if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob.length > 0) {
                  var useSendHook_1 = !!_self.sendHook;
                  var sendInterface_1 = _sendInterfaces[thePayload.sendType];
                  if (!_isBeaconPayload(thePayload.sendType) && thePayload.isBeacon && thePayload.sendReason === 2) {
                    sendInterface_1 = _sendInterfaces[2] || _sendInterfaces[3] || sendInterface_1;
                  }
                  var useHeaders_1 = _useHeaders;
                  if (thePayload.isBeacon || sendInterface_1._transport === 3) {
                    useHeaders_1 = false;
                  }
                  var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);
                  useHeaders_1 = useHeaders_1 || requestDetails_1.useHdrs;
                  var sendEventStart_1 = _1dsCoreJs.getTime();
                  _1dsCoreJs.doPerf(_core, function() {
                    return "HttpManager:_doPayloadSend";
                  }, function() {
                    for (var batchLp = 0; batchLp < thePayload.batches.length; batchLp++) {
                      var theBatch = thePayload.batches[batchLp];
                      var theEvents = theBatch.events();
                      for (var evtLp = 0; evtLp < theEvents.length; evtLp++) {
                        var telemetryItem = theEvents[evtLp];
                        if (_enableEventTimings) {
                          var timings = telemetryItem.timings = telemetryItem.timings || {};
                          _setTimingValue(timings, "sendEventStart", sendEventStart_1);
                          _setTimingValue(timings, "serializationStart", serializationStart);
                          _setTimingValue(timings, "serializationCompleted", serializationCompleted);
                        }
                        telemetryItem[strSendAttempt] > 0 ? telemetryItem[strSendAttempt]++ : telemetryItem[strSendAttempt] = 1;
                      }
                    }
                    _sendBatchesNotification(thePayload.batches, 1e3 + (sendReason || 0), thePayload.sendType, true);
                    var orgPayloadData = {
                      data: thePayload.payloadBlob,
                      urlString: requestDetails_1.url,
                      headers: requestDetails_1.hdrs,
                      _thePayload: thePayload,
                      _sendReason: sendReason,
                      timeout: _xhrTimeout,
                      disableXhrSync: _disableXhrSync,
                      disableFetchKeepAlive: _disableFetchKeepAlive
                    };
                    if (useHeaders_1) {
                      if (!_hasHeader(orgPayloadData.headers, STR_CACHE_CONTROL)) {
                        orgPayloadData.headers[STR_CACHE_CONTROL] = DEFAULT_CACHE_CONTROL;
                      }
                      if (!_hasHeader(orgPayloadData.headers, STR_CONTENT_TYPE_HEADER)) {
                        orgPayloadData.headers[STR_CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE;
                      }
                    }
                    var sender = null;
                    if (sendInterface_1) {
                      sender = function(payload) {
                        _clockSkewManager.firstRequestSent();
                        var onComplete = function(status, headers) {
                          _retryRequestIfNeeded(status, headers, thePayload, sendReason);
                        };
                        var isSync = thePayload.isTeardown || thePayload.isSync;
                        try {
                          sendInterface_1.sendPOST(payload, onComplete, isSync);
                          if (_self.sendListener) {
                            _self.sendListener(orgPayloadData, payload, isSync, thePayload.isBeacon);
                          }
                        } catch (ex) {
                          _1dsCoreJs._warnToConsole(_logger, "Unexpected exception sending payload. Ex:" + _1dsCoreJs.dumpObj(ex));
                          _doOnComplete(onComplete, 0, {});
                        }
                      };
                    }
                    _1dsCoreJs.doPerf(_core, function() {
                      return "HttpManager:_doPayloadSend.sender";
                    }, function() {
                      if (sender) {
                        if (thePayload.sendType === 0) {
                          _outstandingRequests++;
                        }
                        if (useSendHook_1 && !thePayload.isBeacon && sendInterface_1._transport !== 3) {
                          var hookData_1 = {
                            data: orgPayloadData.data,
                            urlString: orgPayloadData.urlString,
                            headers: _1dsCoreJs.extend({}, orgPayloadData.headers),
                            timeout: orgPayloadData.timeout,
                            disableXhrSync: orgPayloadData.disableXhrSync,
                            disableFetchKeepAlive: orgPayloadData.disableFetchKeepAlive
                          };
                          var senderCalled_1 = false;
                          _1dsCoreJs.doPerf(_core, function() {
                            return "HttpManager:_doPayloadSend.sendHook";
                          }, function() {
                            try {
                              _self.sendHook(hookData_1, function(payload) {
                                senderCalled_1 = true;
                                if (!_customHttpInterface && !payload._thePayload) {
                                  payload._thePayload = payload._thePayload || orgPayloadData._thePayload;
                                  payload._sendReason = payload._sendReason || orgPayloadData._sendReason;
                                }
                                sender(payload);
                              }, thePayload.isSync || thePayload.isTeardown);
                            } catch (ex) {
                              if (!senderCalled_1) {
                                sender(orgPayloadData);
                              }
                            }
                          });
                        } else {
                          sender(orgPayloadData);
                        }
                      }
                    });
                  }, function() {
                    return { thePayload, serializationStart, serializationCompleted, sendReason };
                  }, thePayload.isSync);
                }
                if (thePayload.sizeExceed && thePayload.sizeExceed.length > 0) {
                  _sendBatchesNotification(thePayload.sizeExceed, 8003, thePayload.sendType);
                }
                if (thePayload.failedEvts && thePayload.failedEvts.length > 0) {
                  _sendBatchesNotification(thePayload.failedEvts, 8002, thePayload.sendType);
                }
              }
              function _addEventCompletedTimings(theEvents, sendEventCompleted) {
                if (_enableEventTimings) {
                  _1dsCoreJs.arrForEach(theEvents, function(theEvent) {
                    var timings = theEvent.timings = theEvent.timings || {};
                    _setTimingValue(timings, "sendEventCompleted", sendEventCompleted);
                  });
                }
              }
              function _retryRequestIfNeeded(status, headers, thePayload, sendReason) {
                var reason = 9e3;
                var droppedBatches = null;
                var isRetrying = false;
                var backOffTrans = false;
                try {
                  var shouldRetry = true;
                  if (typeof status !== _1dsCoreJs.strUndefined) {
                    if (headers) {
                      _clockSkewManager.setClockSkew(headers[STR_TIME_DELTA_HEADER]);
                      var killDuration = headers[STR_KILL_DURATION_HEADER] || headers["kill-duration-seconds"];
                      _1dsCoreJs.arrForEach(_killSwitch.setKillSwitchTenants(headers[STR_KILL_TOKENS_HEADER], killDuration), function(killToken) {
                        _1dsCoreJs.arrForEach(thePayload.batches, function(theBatch) {
                          if (theBatch.iKey() === killToken) {
                            droppedBatches = droppedBatches || [];
                            var removedEvents = theBatch.split(0);
                            thePayload.numEvents -= removedEvents.count();
                            droppedBatches.push(removedEvents);
                          }
                        });
                      });
                    }
                    if (status == 200 || status == 204) {
                      reason = 200;
                      return;
                    }
                    if (!retryPolicyShouldRetryForStatus(status) || thePayload.numEvents <= 0) {
                      shouldRetry = false;
                    }
                    reason = 9e3 + status % 1e3;
                  }
                  if (shouldRetry) {
                    reason = 100;
                    var retryCount_1 = thePayload.retryCnt;
                    if (thePayload.sendType === 0) {
                      if (retryCount_1 < maxRequestRetriesBeforeBackoff) {
                        isRetrying = true;
                        _doAction(function() {
                          if (thePayload.sendType === 0) {
                            _outstandingRequests--;
                          }
                          _sendBatches(thePayload.batches, retryCount_1 + 1, thePayload.isTeardown, _isUnloading ? 2 : thePayload.sendType, 5);
                        }, _isUnloading, retryPolicyGetMillisToBackoffForRetry(retryCount_1));
                      } else {
                        backOffTrans = true;
                        if (_isUnloading) {
                          reason = 8001;
                        }
                      }
                    }
                  }
                } finally {
                  if (!isRetrying) {
                    _clockSkewManager.setClockSkew();
                    _handleRequestFinished(thePayload, reason, sendReason, backOffTrans);
                  }
                  _sendBatchesNotification(droppedBatches, 8004, thePayload.sendType);
                }
              }
              function _handleRequestFinished(thePayload, batchReason, sendReason, backOffTrans) {
                try {
                  if (backOffTrans) {
                    _postManager._backOffTransmission();
                  }
                  if (batchReason === 200) {
                    if (!backOffTrans && !thePayload.isSync) {
                      _postManager._clearBackOff();
                    }
                    _addCompleteTimings(thePayload.batches);
                  }
                  _sendBatchesNotification(thePayload.batches, batchReason, thePayload.sendType, true);
                } finally {
                  if (thePayload.sendType === 0) {
                    _outstandingRequests--;
                    if (sendReason !== 5) {
                      _self.sendQueuedRequests(thePayload.sendType, sendReason);
                    }
                  }
                }
              }
              function _addCompleteTimings(theBatches) {
                if (_enableEventTimings) {
                  var sendEventCompleted_1 = _1dsCoreJs.getTime();
                  _1dsCoreJs.arrForEach(theBatches, function(theBatch) {
                    if (theBatch && theBatch.count() > 0) {
                      _addEventCompletedTimings(theBatch.events(), sendEventCompleted_1);
                    }
                  });
                }
              }
              function _doAction(cb, isSync, interval) {
                if (isSync) {
                  cb();
                } else {
                  timeoutOverride.set(cb, interval);
                }
              }
              function _convertAllHeadersToMap(headersString) {
                var headers = {};
                if (_1dsCoreJs.isString(headersString)) {
                  var headersArray = _1dsCoreJs.strTrim(headersString).split(/[\r\n]+/);
                  _1dsCoreJs.arrForEach(headersArray, function(headerEntry) {
                    if (headerEntry) {
                      var idx = headerEntry.indexOf(": ");
                      if (idx !== -1) {
                        var header = _1dsCoreJs.strTrim(headerEntry.substring(0, idx)).toLowerCase();
                        var value = _1dsCoreJs.strTrim(headerEntry.substring(idx + 1));
                        headers[header] = value;
                      } else {
                        headers[_1dsCoreJs.strTrim(headerEntry)] = 1;
                      }
                    }
                  });
                }
                return headers;
              }
              function _getMsfpc2(thePayload) {
                for (var lp = 0; lp < thePayload.batches.length; lp++) {
                  var msfpc = thePayload.batches[lp].Msfpc();
                  if (msfpc) {
                    return encodeURIComponent(msfpc);
                  }
                }
                return STR_EMPTY;
              }
              function _handleCollectorResponse(responseText) {
                var responseHandlers = _self._responseHandlers;
                try {
                  for (var i = 0; i < responseHandlers.length; i++) {
                    try {
                      responseHandlers[i](responseText);
                    } catch (e) {
                      _1dsCoreJs._throwInternal(_logger, 1, 519, "Response handler failed: " + e);
                    }
                  }
                  if (responseText) {
                    var response = JSON.parse(responseText);
                    if (_1dsCoreJs.isValueAssigned(response.webResult) && _1dsCoreJs.isValueAssigned(response.webResult[STR_MSFPC])) {
                      _cookieMgr.set("MSFPC", response.webResult[STR_MSFPC], 365 * 86400);
                    }
                  }
                } catch (ex) {
                }
              }
              function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {
                if (theBatches && theBatches.length > 0 && actions) {
                  var theAction_1 = actions[_getNotificationAction(batchReason)];
                  if (theAction_1) {
                    var isSyncRequest_1 = sendType !== 0;
                    _1dsCoreJs.doPerf(_core, function() {
                      return "HttpManager:_sendBatchesNotification";
                    }, function() {
                      _doAction(function() {
                        try {
                          theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);
                        } catch (e) {
                          _1dsCoreJs._throwInternal(_logger, 1, 74, "send request notification failed: " + e);
                        }
                      }, sendSync || isSyncRequest_1, 0);
                    }, function() {
                      return { batches: _createDebugBatches(theBatches), reason: batchReason, isSync: isSyncRequest_1, sendSync, sendType };
                    }, !isSyncRequest_1);
                  }
                }
              }
              function _getNotificationAction(reason) {
                var action = _eventActionMap[reason];
                if (!_1dsCoreJs.isValueAssigned(action)) {
                  action = STR_OTHER;
                  if (reason >= 9e3 && reason <= 9999) {
                    action = STR_RESPONSE_FAIL;
                  } else if (reason >= 8e3 && reason <= 8999) {
                    action = STR_DROPPED;
                  } else if (reason >= 1e3 && reason <= 1999) {
                    action = STR_SENDING;
                  }
                }
                return action;
              }
            });
          }
          HttpManager2.__ieDyn = 1;
          return HttpManager2;
        }()
      );
      function defaultSetTimeout(callback, ms) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        return setTimeout(callback, ms, args);
      }
      function defaultClearTimeout(timeoutId) {
        clearTimeout(timeoutId);
      }
      function createTimeoutWrapper(argSetTimeout, argClearTimeout) {
        return {
          set: argSetTimeout || defaultSetTimeout,
          clear: argClearTimeout || defaultClearTimeout
        };
      }
      var FlushCheckTimer = 0.25;
      var MaxNumberEventPerBatch = 500;
      var EventsDroppedAtOneTime = 20;
      var MaxSendAttempts = 6;
      var MaxSyncUnloadSendAttempts = 2;
      var MaxBackoffCount = 4;
      var MaxConnections = 2;
      var MaxRequestRetriesBeforeBackoff = 1;
      var strEventsDiscarded = "eventsDiscarded";
      var strOverrideInstrumentationKey = "overrideInstrumentationKey";
      var strMaxEventRetryAttempts = "maxEventRetryAttempts";
      var strMaxUnloadEventRetryAttempts = "maxUnloadEventRetryAttempts";
      var strAddUnloadCb = "addUnloadCb";
      var PostChannel = (
        /** @class */
        function(_super) {
          applicationinsightsShims.__extendsFn(PostChannel2, _super);
          function PostChannel2() {
            var _this = _super.call(this) || this;
            _this.identifier = "PostChannel";
            _this.priority = 1011;
            _this.version = "3.2.13";
            var _config;
            var _isTeardownCalled = false;
            var _flushCallbackQueue = [];
            var _flushCallbackTimerId = null;
            var _paused = false;
            var _immediateQueueSize = 0;
            var _immediateQueueSizeLimit = 500;
            var _queueSize = 0;
            var _queueSizeLimit = 1e4;
            var _profiles = {};
            var _currentProfile = RT_PROFILE;
            var _scheduledTimerId = null;
            var _immediateTimerId = null;
            var _currentBackoffCount = 0;
            var _timerCount = 0;
            var _xhrOverride;
            var _httpManager;
            var _batchQueues = {};
            var _autoFlushEventsLimit;
            var _autoFlushBatchLimit;
            var _delayedBatchSendLatency = -1;
            var _delayedBatchReason;
            var _optimizeObject = true;
            var _isPageUnloadTriggered = false;
            var _maxEventSendAttempts = MaxSendAttempts;
            var _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;
            var _evtNamespace;
            var _timeoutWrapper;
            dynamicProto__default(PostChannel2, _this, function(_self, _base) {
              _initDefaults();
              _self["_getDbgPlgTargets"] = function() {
                return [_httpManager];
              };
              _self.initialize = function(coreConfig, core, extensions2) {
                _1dsCoreJs.doPerf(core, function() {
                  return "PostChannel:initialize";
                }, function() {
                  var extendedCore = core;
                  _base.initialize(coreConfig, core, extensions2);
                  try {
                    var hasAddUnloadCb = !!core[strAddUnloadCb];
                    _evtNamespace = _1dsCoreJs.mergeEvtNamespace(_1dsCoreJs.createUniqueNamespace(_self.identifier), core.evtNamespace && core.evtNamespace());
                    var ctx = _self._getTelCtx();
                    coreConfig.extensionConfig[_self.identifier] = coreConfig.extensionConfig[_self.identifier] || {};
                    _config = ctx.getExtCfg(_self.identifier);
                    _timeoutWrapper = createTimeoutWrapper(_config.setTimeoutOverride, _config.clearTimeoutOverride);
                    _optimizeObject = !_config.disableOptimizeObj && _1dsCoreJs.isChromium();
                    _hookWParam(extendedCore);
                    if (_config.eventsLimitInMem > 0) {
                      _queueSizeLimit = _config.eventsLimitInMem;
                    }
                    if (_config.immediateEventLimit > 0) {
                      _immediateQueueSizeLimit = _config.immediateEventLimit;
                    }
                    if (_config.autoFlushEventsLimit > 0) {
                      _autoFlushEventsLimit = _config.autoFlushEventsLimit;
                    }
                    if (_1dsCoreJs.isNumber(_config[strMaxEventRetryAttempts])) {
                      _maxEventSendAttempts = _config[strMaxEventRetryAttempts];
                    }
                    if (_1dsCoreJs.isNumber(_config[strMaxUnloadEventRetryAttempts])) {
                      _maxUnloadEventSendAttempts = _config[strMaxUnloadEventRetryAttempts];
                    }
                    _setAutoLimits();
                    if (_config.httpXHROverride && _config.httpXHROverride.sendPOST) {
                      _xhrOverride = _config.httpXHROverride;
                    }
                    if (_1dsCoreJs.isValueAssigned(coreConfig.anonCookieName)) {
                      _httpManager.addQueryStringParameter("anoncknm", coreConfig.anonCookieName);
                    }
                    _httpManager.sendHook = _config.payloadPreprocessor;
                    _httpManager.sendListener = _config.payloadListener;
                    var endpointUrl = _config.overrideEndpointUrl ? _config.overrideEndpointUrl : coreConfig.endpointUrl;
                    _self._notificationManager = core.getNotifyMgr();
                    _httpManager.initialize(endpointUrl, _self.core, _self, _xhrOverride, _config);
                    var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];
                    _1dsCoreJs.addPageUnloadEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);
                    _1dsCoreJs.addPageHideEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);
                    _1dsCoreJs.addPageShowEventListener(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace);
                  } catch (e) {
                    _self.setInitialized(false);
                    throw e;
                  }
                }, function() {
                  return { coreConfig, core, extensions: extensions2 };
                });
              };
              _self.processTelemetry = function(ev, itemCtx) {
                _1dsCoreJs.setProcessTelemetryTimings(ev, _self.identifier);
                itemCtx = _self._getTelCtx(itemCtx);
                var channelConfig = itemCtx.getExtCfg(_self.identifier);
                var disableTelemetry = !!_config.disableTelemetry;
                if (channelConfig) {
                  disableTelemetry = disableTelemetry || !!channelConfig.disableTelemetry;
                }
                var event = ev;
                if (!disableTelemetry && !_isTeardownCalled) {
                  if (_config[strOverrideInstrumentationKey]) {
                    event.iKey = _config[strOverrideInstrumentationKey];
                  }
                  if (channelConfig && channelConfig[strOverrideInstrumentationKey]) {
                    event.iKey = channelConfig[strOverrideInstrumentationKey];
                  }
                  _addEventToQueues(event, true);
                  if (_isPageUnloadTriggered) {
                    _releaseAllQueues(2, 2);
                  } else {
                    _scheduleTimer();
                  }
                }
                _self.processNext(event, itemCtx);
              };
              _self._doTeardown = function(unloadCtx, unloadState) {
                _releaseAllQueues(2, 2);
                _isTeardownCalled = true;
                _httpManager.teardown();
                _1dsCoreJs.removePageUnloadEventListener(null, _evtNamespace);
                _1dsCoreJs.removePageHideEventListener(null, _evtNamespace);
                _1dsCoreJs.removePageShowEventListener(null, _evtNamespace);
                _initDefaults();
              };
              function _hookWParam(extendedCore) {
                var existingGetWParamMethod = extendedCore.getWParam;
                extendedCore.getWParam = function() {
                  var wparam = 0;
                  if (_config.ignoreMc1Ms0CookieProcessing) {
                    wparam = wparam | 2;
                  }
                  return wparam | existingGetWParamMethod();
                };
              }
              function _handleUnloadEvents(evt) {
                var theEvt = evt || _1dsCoreJs.getWindow().event;
                if (theEvt.type !== "beforeunload") {
                  _isPageUnloadTriggered = true;
                  _httpManager.setUnloading(_isPageUnloadTriggered);
                }
                _releaseAllQueues(2, 2);
              }
              function _handleShowEvents(evt) {
                _isPageUnloadTriggered = false;
                _httpManager.setUnloading(_isPageUnloadTriggered);
              }
              function _addEventToQueues(event, append) {
                if (!event.sendAttempt) {
                  event.sendAttempt = 0;
                }
                if (!event.latency) {
                  event.latency = 1;
                }
                if (event.ext && event.ext[STR_TRACE]) {
                  delete event.ext[STR_TRACE];
                }
                if (event.ext && event.ext[STR_USER] && event.ext[STR_USER]["id"]) {
                  delete event.ext[STR_USER]["id"];
                }
                if (_optimizeObject) {
                  event.ext = _1dsCoreJs.optimizeObject(event.ext);
                  if (event.baseData) {
                    event.baseData = _1dsCoreJs.optimizeObject(event.baseData);
                  }
                  if (event.data) {
                    event.data = _1dsCoreJs.optimizeObject(event.data);
                  }
                }
                if (event.sync) {
                  if (_currentBackoffCount || _paused) {
                    event.latency = 3;
                    event.sync = false;
                  } else {
                    if (_httpManager) {
                      if (_optimizeObject) {
                        event = _1dsCoreJs.optimizeObject(event);
                      }
                      _httpManager.sendSynchronousBatch(EventBatch.create(event.iKey, [event]), event.sync === true ? 1 : event.sync, 3);
                      return;
                    }
                  }
                }
                var evtLatency = event.latency;
                var queueSize = _queueSize;
                var queueLimit = _queueSizeLimit;
                if (evtLatency === 4) {
                  queueSize = _immediateQueueSize;
                  queueLimit = _immediateQueueSizeLimit;
                }
                var eventDropped = false;
                if (queueSize < queueLimit) {
                  eventDropped = !_addEventToProperQueue(event, append);
                } else {
                  var dropLatency = 1;
                  var dropNumber = EventsDroppedAtOneTime;
                  if (evtLatency === 4) {
                    dropLatency = 4;
                    dropNumber = 1;
                  }
                  eventDropped = true;
                  if (_dropEventWithLatencyOrLess(event.iKey, event.latency, dropLatency, dropNumber)) {
                    eventDropped = !_addEventToProperQueue(event, append);
                  }
                }
                if (eventDropped) {
                  _notifyEvents(strEventsDiscarded, [event], _1dsCoreJs.EventsDiscardedReason.QueueFull);
                }
              }
              _self.setEventQueueLimits = function(eventLimit, autoFlushLimit) {
                _queueSizeLimit = eventLimit > 0 ? eventLimit : 1e4;
                _autoFlushEventsLimit = autoFlushLimit > 0 ? autoFlushLimit : 0;
                _setAutoLimits();
                var doFlush = _queueSize > eventLimit;
                if (!doFlush && _autoFlushBatchLimit > 0) {
                  for (var latency = 1; !doFlush && latency <= 3; latency++) {
                    var batchQueue = _batchQueues[latency];
                    if (batchQueue && batchQueue.batches) {
                      _1dsCoreJs.arrForEach(batchQueue.batches, function(theBatch) {
                        if (theBatch && theBatch.count() >= _autoFlushBatchLimit) {
                          doFlush = true;
                        }
                      });
                    }
                  }
                }
                _performAutoFlush(true, doFlush);
              };
              _self.pause = function() {
                _clearScheduledTimer();
                _paused = true;
                _httpManager.pause();
              };
              _self.resume = function() {
                _paused = false;
                _httpManager.resume();
                _scheduleTimer();
              };
              _self.addResponseHandler = function(responseHandler) {
                _httpManager._responseHandlers.push(responseHandler);
              };
              _self._loadTransmitProfiles = function(profiles) {
                _resetTransmitProfiles();
                _1dsCoreJs.objForEachKey(profiles, function(profileName, profileValue) {
                  var profLen = profileValue.length;
                  if (profLen >= 2) {
                    var directValue = profLen > 2 ? profileValue[2] : 0;
                    profileValue.splice(0, profLen - 2);
                    if (profileValue[1] < 0) {
                      profileValue[0] = -1;
                    }
                    if (profileValue[1] > 0 && profileValue[0] > 0) {
                      var timerMultiplier = profileValue[0] / profileValue[1];
                      profileValue[0] = Math.ceil(timerMultiplier) * profileValue[1];
                    }
                    if (directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1]) {
                      directValue = profileValue[1];
                    }
                    profileValue.push(directValue);
                    _profiles[profileName] = profileValue;
                  }
                });
              };
              _self.flush = function(async, callback, sendReason) {
                if (async === void 0) {
                  async = true;
                }
                if (!_paused) {
                  sendReason = sendReason || 1;
                  if (async) {
                    if (_flushCallbackTimerId == null) {
                      _clearScheduledTimer();
                      _queueBatches(1, 0, sendReason);
                      _flushCallbackTimerId = _createTimer(function() {
                        _flushCallbackTimerId = null;
                        _flushImpl(callback, sendReason);
                      }, 0);
                    } else {
                      _flushCallbackQueue.push(callback);
                    }
                  } else {
                    var cleared = _clearScheduledTimer();
                    _sendEventsForLatencyAndAbove(1, 1, sendReason);
                    if (callback !== null && callback !== void 0) {
                      callback();
                    }
                    if (cleared) {
                      _scheduleTimer();
                    }
                  }
                }
              };
              _self.setMsaAuthTicket = function(ticket) {
                _httpManager.addHeader(STR_MSA_DEVICE_TICKET, ticket);
              };
              _self.hasEvents = _hasEvents;
              _self._setTransmitProfile = function(profileName) {
                if (_currentProfile !== profileName && _profiles[profileName] !== void 0) {
                  _clearScheduledTimer();
                  _currentProfile = profileName;
                  _scheduleTimer();
                }
              };
              function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {
                var queued = _queueBatches(latency, sendType, sendReason);
                _httpManager.sendQueuedRequests(sendType, sendReason);
                return queued;
              }
              function _hasEvents() {
                return _queueSize > 0;
              }
              function _scheduleTimer() {
                if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0, _delayedBatchReason)) {
                  _httpManager.sendQueuedRequests(0, _delayedBatchReason);
                }
                if (_immediateQueueSize > 0 && !_immediateTimerId && !_paused) {
                  var immediateTimeOut = _profiles[_currentProfile][2];
                  if (immediateTimeOut >= 0) {
                    _immediateTimerId = _createTimer(function() {
                      _immediateTimerId = null;
                      _sendEventsForLatencyAndAbove(4, 0, 1);
                      _scheduleTimer();
                    }, immediateTimeOut);
                  }
                }
                var timeOut = _profiles[_currentProfile][1];
                if (!_scheduledTimerId && !_flushCallbackTimerId && timeOut >= 0 && !_paused) {
                  if (_hasEvents()) {
                    _scheduledTimerId = _createTimer(function() {
                      _scheduledTimerId = null;
                      _sendEventsForLatencyAndAbove(_timerCount === 0 ? 3 : 1, 0, 1);
                      _timerCount++;
                      _timerCount %= 2;
                      _scheduleTimer();
                    }, timeOut);
                  } else {
                    _timerCount = 0;
                  }
                }
              }
              _self._backOffTransmission = function() {
                if (_currentBackoffCount < MaxBackoffCount) {
                  _currentBackoffCount++;
                  _clearScheduledTimer();
                  _scheduleTimer();
                }
              };
              _self._clearBackOff = function() {
                if (_currentBackoffCount) {
                  _currentBackoffCount = 0;
                  _clearScheduledTimer();
                  _scheduleTimer();
                }
              };
              function _initDefaults() {
                _config = null;
                _isTeardownCalled = false;
                _flushCallbackQueue = [];
                _flushCallbackTimerId = null;
                _paused = false;
                _immediateQueueSize = 0;
                _immediateQueueSizeLimit = 500;
                _queueSize = 0;
                _queueSizeLimit = 1e4;
                _profiles = {};
                _currentProfile = RT_PROFILE;
                _scheduledTimerId = null;
                _immediateTimerId = null;
                _currentBackoffCount = 0;
                _timerCount = 0;
                _xhrOverride = null;
                _batchQueues = {};
                _autoFlushEventsLimit = void 0;
                _autoFlushBatchLimit = 0;
                _delayedBatchSendLatency = -1;
                _delayedBatchReason = null;
                _optimizeObject = true;
                _isPageUnloadTriggered = false;
                _maxEventSendAttempts = MaxSendAttempts;
                _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;
                _evtNamespace = null;
                _timeoutWrapper = createTimeoutWrapper();
                _httpManager = new HttpManager(MaxNumberEventPerBatch, MaxConnections, MaxRequestRetriesBeforeBackoff, {
                  requeue: _requeueEvents,
                  send: _sendingEvent,
                  sent: _eventsSentEvent,
                  drop: _eventsDropped,
                  rspFail: _eventsResponseFail,
                  oth: _otherEvent
                }, _timeoutWrapper);
                _initializeProfiles();
                _clearQueues();
                _setAutoLimits();
              }
              function _createTimer(theTimerFunc, timeOut) {
                if (timeOut === 0 && _currentBackoffCount) {
                  timeOut = 1;
                }
                var timerMultiplier = 1e3;
                if (_currentBackoffCount) {
                  timerMultiplier = retryPolicyGetMillisToBackoffForRetry(_currentBackoffCount - 1);
                }
                return _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);
              }
              function _clearScheduledTimer() {
                if (_scheduledTimerId !== null) {
                  _timeoutWrapper.clear(_scheduledTimerId);
                  _scheduledTimerId = null;
                  _timerCount = 0;
                  return true;
                }
                return false;
              }
              function _releaseAllQueues(sendType, sendReason) {
                _clearScheduledTimer();
                if (_flushCallbackTimerId) {
                  _timeoutWrapper.clear(_flushCallbackTimerId);
                  _flushCallbackTimerId = null;
                }
                if (!_paused) {
                  _sendEventsForLatencyAndAbove(1, sendType, sendReason);
                }
              }
              function _clearQueues() {
                _batchQueues[4] = {
                  batches: [],
                  iKeyMap: {}
                };
                _batchQueues[3] = {
                  batches: [],
                  iKeyMap: {}
                };
                _batchQueues[2] = {
                  batches: [],
                  iKeyMap: {}
                };
                _batchQueues[1] = {
                  batches: [],
                  iKeyMap: {}
                };
              }
              function _getEventBatch(iKey, latency, create) {
                var batchQueue = _batchQueues[latency];
                if (!batchQueue) {
                  latency = 1;
                  batchQueue = _batchQueues[latency];
                }
                var eventBatch = batchQueue.iKeyMap[iKey];
                if (!eventBatch && create) {
                  eventBatch = EventBatch.create(iKey);
                  batchQueue.batches.push(eventBatch);
                  batchQueue.iKeyMap[iKey] = eventBatch;
                }
                return eventBatch;
              }
              function _performAutoFlush(isAsync, doFlush) {
                if (_httpManager.canSendRequest() && !_currentBackoffCount) {
                  if (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit) {
                    doFlush = true;
                  }
                  if (doFlush && _flushCallbackTimerId == null) {
                    _self.flush(isAsync, null, 20);
                  }
                }
              }
              function _addEventToProperQueue(event, append) {
                if (_optimizeObject) {
                  event = _1dsCoreJs.optimizeObject(event);
                }
                var latency = event.latency;
                var eventBatch = _getEventBatch(event.iKey, latency, true);
                if (eventBatch.addEvent(event)) {
                  if (latency !== 4) {
                    _queueSize++;
                    if (append && event.sendAttempt === 0) {
                      _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch.count() >= _autoFlushBatchLimit);
                    }
                  } else {
                    _immediateQueueSize++;
                  }
                  return true;
                }
                return false;
              }
              function _dropEventWithLatencyOrLess(iKey, latency, currentLatency, dropNumber) {
                while (currentLatency <= latency) {
                  var eventBatch = _getEventBatch(iKey, latency, true);
                  if (eventBatch && eventBatch.count() > 0) {
                    var droppedEvents = eventBatch.split(0, dropNumber);
                    var droppedCount = droppedEvents.count();
                    if (droppedCount > 0) {
                      if (currentLatency === 4) {
                        _immediateQueueSize -= droppedCount;
                      } else {
                        _queueSize -= droppedCount;
                      }
                      _notifyBatchEvents(strEventsDiscarded, [droppedEvents], _1dsCoreJs.EventsDiscardedReason.QueueFull);
                      return true;
                    }
                  }
                  currentLatency++;
                }
                _resetQueueCounts();
                return false;
              }
              function _resetQueueCounts() {
                var immediateQueue = 0;
                var normalQueue = 0;
                var _loop_1 = function(latency2) {
                  var batchQueue = _batchQueues[latency2];
                  if (batchQueue && batchQueue.batches) {
                    _1dsCoreJs.arrForEach(batchQueue.batches, function(theBatch) {
                      if (latency2 === 4) {
                        immediateQueue += theBatch.count();
                      } else {
                        normalQueue += theBatch.count();
                      }
                    });
                  }
                };
                for (var latency = 1; latency <= 4; latency++) {
                  _loop_1(latency);
                }
                _queueSize = normalQueue;
                _immediateQueueSize = immediateQueue;
              }
              function _queueBatches(latency, sendType, sendReason) {
                var eventsQueued = false;
                var isAsync = sendType === 0;
                if (!isAsync || _httpManager.canSendRequest()) {
                  _1dsCoreJs.doPerf(_self.core, function() {
                    return "PostChannel._queueBatches";
                  }, function() {
                    var droppedEvents = [];
                    var latencyToProcess = 4;
                    while (latencyToProcess >= latency) {
                      var batchQueue = _batchQueues[latencyToProcess];
                      if (batchQueue && batchQueue.batches && batchQueue.batches.length > 0) {
                        _1dsCoreJs.arrForEach(batchQueue.batches, function(theBatch) {
                          if (!_httpManager.addBatch(theBatch)) {
                            droppedEvents = droppedEvents.concat(theBatch.events());
                          } else {
                            eventsQueued = eventsQueued || theBatch && theBatch.count() > 0;
                          }
                          if (latencyToProcess === 4) {
                            _immediateQueueSize -= theBatch.count();
                          } else {
                            _queueSize -= theBatch.count();
                          }
                        });
                        batchQueue.batches = [];
                        batchQueue.iKeyMap = {};
                      }
                      latencyToProcess--;
                    }
                    if (droppedEvents.length > 0) {
                      _notifyEvents(strEventsDiscarded, droppedEvents, _1dsCoreJs.EventsDiscardedReason.KillSwitch);
                    }
                    if (eventsQueued && _delayedBatchSendLatency >= latency) {
                      _delayedBatchSendLatency = -1;
                      _delayedBatchReason = 0;
                    }
                  }, function() {
                    return { latency, sendType, sendReason };
                  }, !isAsync);
                } else {
                  _delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? Math.min(_delayedBatchSendLatency, latency) : latency;
                  _delayedBatchReason = Math.max(_delayedBatchReason, sendReason);
                }
                return eventsQueued;
              }
              function _flushImpl(callback, sendReason) {
                _sendEventsForLatencyAndAbove(1, 0, sendReason);
                _resetQueueCounts();
                _waitForIdleManager(function() {
                  if (callback) {
                    callback();
                  }
                  if (_flushCallbackQueue.length > 0) {
                    _flushCallbackTimerId = _createTimer(function() {
                      _flushCallbackTimerId = null;
                      _flushImpl(_flushCallbackQueue.shift(), sendReason);
                    }, 0);
                  } else {
                    _flushCallbackTimerId = null;
                    _scheduleTimer();
                  }
                });
              }
              function _waitForIdleManager(callback) {
                if (_httpManager.isCompletelyIdle()) {
                  callback();
                } else {
                  _flushCallbackTimerId = _createTimer(function() {
                    _flushCallbackTimerId = null;
                    _waitForIdleManager(callback);
                  }, FlushCheckTimer);
                }
              }
              function _resetTransmitProfiles() {
                _clearScheduledTimer();
                _initializeProfiles();
                _currentProfile = RT_PROFILE;
                _scheduleTimer();
              }
              function _initializeProfiles() {
                _profiles = {};
                _profiles[RT_PROFILE] = [2, 1, 0];
                _profiles[NRT_PROFILE] = [6, 3, 0];
                _profiles[BE_PROFILE] = [18, 9, 0];
              }
              function _requeueEvents(batches, reason) {
                var droppedEvents = [];
                var maxSendAttempts = _maxEventSendAttempts;
                if (_isPageUnloadTriggered) {
                  maxSendAttempts = _maxUnloadEventSendAttempts;
                }
                _1dsCoreJs.arrForEach(batches, function(theBatch) {
                  if (theBatch && theBatch.count() > 0) {
                    _1dsCoreJs.arrForEach(theBatch.events(), function(theEvent) {
                      if (theEvent) {
                        if (theEvent.sync) {
                          theEvent.latency = 4;
                          theEvent.sync = false;
                        }
                        if (theEvent.sendAttempt < maxSendAttempts) {
                          _1dsCoreJs.setProcessTelemetryTimings(theEvent, _self.identifier);
                          _addEventToQueues(theEvent, false);
                        } else {
                          droppedEvents.push(theEvent);
                        }
                      }
                    });
                  }
                });
                if (droppedEvents.length > 0) {
                  _notifyEvents(strEventsDiscarded, droppedEvents, _1dsCoreJs.EventsDiscardedReason.NonRetryableStatus);
                }
                if (_isPageUnloadTriggered) {
                  _releaseAllQueues(2, 2);
                }
              }
              function _callNotification(evtName, theArgs) {
                var manager = _self._notificationManager || {};
                var notifyFunc = manager[evtName];
                if (notifyFunc) {
                  try {
                    notifyFunc.apply(manager, theArgs);
                  } catch (e) {
                    _1dsCoreJs._throwInternal(_self.diagLog(), 1, 74, evtName + " notification failed: " + e);
                  }
                }
              }
              function _notifyEvents(evtName, theEvents) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  extraArgs[_i - 2] = arguments[_i];
                }
                if (theEvents && theEvents.length > 0) {
                  _callNotification(evtName, [theEvents].concat(extraArgs));
                }
              }
              function _notifyBatchEvents(evtName, batches) {
                var extraArgs = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  extraArgs[_i - 2] = arguments[_i];
                }
                if (batches && batches.length > 0) {
                  _1dsCoreJs.arrForEach(batches, function(theBatch) {
                    if (theBatch && theBatch.count() > 0) {
                      _callNotification(evtName, [theBatch.events()].concat(extraArgs));
                    }
                  });
                }
              }
              function _sendingEvent(batches, reason, isSyncRequest) {
                if (batches && batches.length > 0) {
                  _callNotification("eventsSendRequest", [reason >= 1e3 && reason <= 1999 ? reason - 1e3 : 0, isSyncRequest !== true]);
                }
              }
              function _eventsSentEvent(batches, reason) {
                _notifyBatchEvents("eventsSent", batches, reason);
                _scheduleTimer();
              }
              function _eventsDropped(batches, reason) {
                _notifyBatchEvents(strEventsDiscarded, batches, reason >= 8e3 && reason <= 8999 ? reason - 8e3 : _1dsCoreJs.EventsDiscardedReason.Unknown);
              }
              function _eventsResponseFail(batches) {
                _notifyBatchEvents(strEventsDiscarded, batches, _1dsCoreJs.EventsDiscardedReason.NonRetryableStatus);
                _scheduleTimer();
              }
              function _otherEvent(batches, reason) {
                _notifyBatchEvents(strEventsDiscarded, batches, _1dsCoreJs.EventsDiscardedReason.Unknown);
                _scheduleTimer();
              }
              function _setAutoLimits() {
                if (!_config || !_config.disableAutoBatchFlushLimit) {
                  _autoFlushBatchLimit = Math.max(MaxNumberEventPerBatch * (MaxConnections + 1), _queueSizeLimit / 6);
                } else {
                  _autoFlushBatchLimit = 0;
                }
              }
              _1dsCoreJs.objDefineAccessors(_self, "_setTimeoutOverride", function() {
                return _timeoutWrapper.set;
              }, function(value) {
                _timeoutWrapper = createTimeoutWrapper(value, _timeoutWrapper.clear);
              });
              _1dsCoreJs.objDefineAccessors(_self, "_clearTimeoutOverride", function() {
                return _timeoutWrapper.clear;
              }, function(value) {
                _timeoutWrapper = createTimeoutWrapper(_timeoutWrapper.set, value);
              });
            });
            return _this;
          }
          PostChannel2.__ieDyn = 1;
          return PostChannel2;
        }(_1dsCoreJs.BaseTelemetryPlugin)
      );
      exports3.BE_PROFILE = BE_PROFILE;
      exports3.NRT_PROFILE = NRT_PROFILE;
      exports3.PostChannel = PostChannel;
      exports3.RT_PROFILE = RT_PROFILE;
      (function(obj, prop, descriptor) {
        var func = Object["defineProperty"];
        if (func) {
          try {
            return func(obj, prop, descriptor);
          } catch (e) {
          }
        }
        if (descriptor && typeof descriptor.value !== void 0) {
          obj[prop] = descriptor.value;
        }
        return obj;
      })(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/common/1dsClientFactory.js
var require_dsClientFactory = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/common/1dsClientFactory.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.oneDataSystemClientFactory = void 0;
    var getAICore = async (key, vscodeAPI, xhrOverride) => {
      const oneDs = await Promise.resolve().then(() => __importStar(require_ms_core()));
      const postPlugin = await Promise.resolve().then(() => __importStar(require_ms_post()));
      const appInsightsCore = new oneDs.AppInsightsCore();
      const collectorChannelPlugin = new postPlugin.PostChannel();
      const coreConfig = {
        instrumentationKey: key,
        endpointUrl: "https://mobile.events.data.microsoft.com/OneCollector/1.0",
        loggingLevelTelemetry: 0,
        loggingLevelConsole: 0,
        disableCookiesUsage: true,
        disableDbgExt: true,
        disableInstrumentationKeyValidation: true,
        channels: [[
          collectorChannelPlugin
        ]]
      };
      if (xhrOverride) {
        coreConfig.extensionConfig = {};
        const channelConfig = {
          alwaysUseXhrOverride: true,
          httpXHROverride: xhrOverride
        };
        coreConfig.extensionConfig[collectorChannelPlugin.identifier] = channelConfig;
      }
      const config = vscodeAPI.workspace.getConfiguration("telemetry");
      const internalTesting = config.get("internalTesting");
      appInsightsCore.initialize(coreConfig, []);
      appInsightsCore.addTelemetryInitializer((envelope) => {
        if (!internalTesting) {
          return;
        }
        envelope["ext"] = envelope["ext"] ?? {};
        envelope["ext"]["utc"] = envelope["ext"]["utc"] ?? {};
        envelope["ext"]["utc"]["flags"] = 8462029;
      });
      return appInsightsCore;
    };
    var oneDataSystemClientFactory = async (key, vscodeAPI, xhrOverride) => {
      const appInsightsCore = await getAICore(key, vscodeAPI, xhrOverride);
      const telemetryClient = {
        logEvent: (eventName, data) => {
          try {
            appInsightsCore?.track({
              name: eventName,
              baseData: { name: eventName, properties: data?.properties, measurements: data?.measurements }
            });
          } catch (e) {
            throw new Error("Failed to log event to app insights!\n" + e.message);
          }
        },
        flush: async () => {
          try {
            appInsightsCore?.unload();
          } catch (e) {
            throw new Error("Failed to flush app insights!\n" + e.message);
          }
        }
      };
      return telemetryClient;
    };
    exports2.oneDataSystemClientFactory = oneDataSystemClientFactory;
  }
});

// node_modules/applicationinsights/out/Library/FileSystemHelper.js
var require_FileSystemHelper = __commonJS({
  "node_modules/applicationinsights/out/Library/FileSystemHelper.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getShallowFileSize = exports2.getShallowDirectorySizeSync = exports2.getShallowDirectorySize = exports2.confirmDirExists = exports2.unlinkAsync = exports2.readdirAsync = exports2.readFileAsync = exports2.writeFileAsync = exports2.appendFileAsync = exports2.accessAsync = exports2.mkdirAsync = exports2.lstatAsync = exports2.statAsync = void 0;
    var fs = require("fs");
    var path2 = require("path");
    var util_1 = require("util");
    exports2.statAsync = util_1.promisify(fs.stat);
    exports2.lstatAsync = util_1.promisify(fs.lstat);
    exports2.mkdirAsync = util_1.promisify(fs.mkdir);
    exports2.accessAsync = util_1.promisify(fs.access);
    exports2.appendFileAsync = util_1.promisify(fs.appendFile);
    exports2.writeFileAsync = util_1.promisify(fs.writeFile);
    exports2.readFileAsync = util_1.promisify(fs.readFile);
    exports2.readdirAsync = util_1.promisify(fs.readdir);
    exports2.unlinkAsync = util_1.promisify(fs.unlink);
    var confirmDirExists = function(directory) {
      return __awaiter(void 0, void 0, void 0, function() {
        var stats, err_1, mkdirErr_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, 2, , 7]);
              return [4, exports2.lstatAsync(directory)];
            case 1:
              stats = _a.sent();
              if (!stats.isDirectory()) {
                throw new Error("Path existed but was not a directory");
              }
              return [3, 7];
            case 2:
              err_1 = _a.sent();
              if (!(err_1 && err_1.code === "ENOENT"))
                return [3, 6];
              _a.label = 3;
            case 3:
              _a.trys.push([3, 5, , 6]);
              return [4, exports2.mkdirAsync(directory)];
            case 4:
              _a.sent();
              return [3, 6];
            case 5:
              mkdirErr_1 = _a.sent();
              if (mkdirErr_1 && mkdirErr_1.code !== "EEXIST") {
                throw mkdirErr_1;
              }
              return [3, 6];
            case 6:
              return [3, 7];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports2.confirmDirExists = confirmDirExists;
    var getShallowDirectorySize = function(directory) {
      return __awaiter(void 0, void 0, void 0, function() {
        var files, totalSize, _i, files_1, file, fileStats;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, exports2.readdirAsync(directory)];
            case 1:
              files = _a.sent();
              totalSize = 0;
              _i = 0, files_1 = files;
              _a.label = 2;
            case 2:
              if (!(_i < files_1.length))
                return [3, 5];
              file = files_1[_i];
              return [4, exports2.statAsync(path2.join(directory, file))];
            case 3:
              fileStats = _a.sent();
              if (fileStats.isFile()) {
                totalSize += fileStats.size;
              }
              _a.label = 4;
            case 4:
              _i++;
              return [3, 2];
            case 5:
              return [2, totalSize];
          }
        });
      });
    };
    exports2.getShallowDirectorySize = getShallowDirectorySize;
    var getShallowDirectorySizeSync = function(directory) {
      var files = fs.readdirSync(directory);
      var totalSize = 0;
      for (var i = 0; i < files.length; i++) {
        totalSize += fs.statSync(path2.join(directory, files[i])).size;
      }
      return totalSize;
    };
    exports2.getShallowDirectorySizeSync = getShallowDirectorySizeSync;
    var getShallowFileSize = function(filePath) {
      return __awaiter(void 0, void 0, void 0, function() {
        var fileStats;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, exports2.statAsync(filePath)];
            case 1:
              fileStats = _a.sent();
              if (fileStats.isFile()) {
                return [2, fileStats.size];
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports2.getShallowFileSize = getShallowFileSize;
  }
});

// node_modules/applicationinsights/out/Library/InternalAzureLogger.js
var require_InternalAzureLogger = __commonJS({
  "node_modules/applicationinsights/out/Library/InternalAzureLogger.js"(exports2, module2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    var fs = require("fs");
    var os = require("os");
    var path2 = require("path");
    var FileSystemHelper = require_FileSystemHelper();
    var InternalAzureLogger = (
      /** @class */
      function() {
        function InternalAzureLogger2() {
          var _this = this;
          this.TAG = "Logger";
          this._cleanupTimeOut = 60 * 30 * 1e3;
          this._logToFile = false;
          this._logToConsole = true;
          var logDestination = process.env.APPLICATIONINSIGHTS_LOG_DESTINATION;
          if (logDestination == "file+console") {
            this._logToFile = true;
          }
          if (logDestination == "file") {
            this._logToFile = true;
            this._logToConsole = false;
          }
          this.maxSizeBytes = 5e4;
          this.maxHistory = 1;
          this._logFileName = "applicationinsights.log";
          var logFilePath = process.env.APPLICATIONINSIGHTS_LOGDIR;
          if (!logFilePath) {
            this._tempDir = path2.join(os.tmpdir(), "appInsights-node");
          } else {
            if (path2.isAbsolute(logFilePath)) {
              this._tempDir = logFilePath;
            } else {
              this._tempDir = path2.join(process.cwd(), logFilePath);
            }
          }
          this._fileFullPath = path2.join(this._tempDir, this._logFileName);
          this._backUpNameFormat = "." + this._logFileName;
          if (this._logToFile) {
            if (!InternalAzureLogger2._fileCleanupTimer) {
              InternalAzureLogger2._fileCleanupTimer = setInterval(function() {
                _this._fileCleanupTask();
              }, this._cleanupTimeOut);
              InternalAzureLogger2._fileCleanupTimer.unref();
            }
          }
        }
        InternalAzureLogger2.prototype.info = function(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          var args = message ? __spreadArrays([message], optionalParams) : optionalParams;
          if (this._logToFile) {
            this._storeToDisk(args);
          }
          if (this._logToConsole) {
            console.info.apply(console, args);
          }
        };
        InternalAzureLogger2.prototype.warning = function(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          var args = message ? __spreadArrays([message], optionalParams) : optionalParams;
          if (this._logToFile) {
            this._storeToDisk(args);
          }
          if (this._logToConsole) {
            console.warn.apply(console, args);
          }
        };
        InternalAzureLogger2.getInstance = function() {
          if (!InternalAzureLogger2._instance) {
            InternalAzureLogger2._instance = new InternalAzureLogger2();
          }
          return InternalAzureLogger2._instance;
        };
        InternalAzureLogger2.prototype._storeToDisk = function(args) {
          return __awaiter(this, void 0, void 0, function() {
            var data, err_1, appendError_1, err_2, size, err_3;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  data = args + "\r\n";
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, , 4]);
                  return [4, FileSystemHelper.confirmDirExists(this._tempDir)];
                case 2:
                  _a.sent();
                  return [3, 4];
                case 3:
                  err_1 = _a.sent();
                  console.log(this.TAG, "Failed to create directory for log file: " + (err_1 && err_1.message));
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  _a.trys.push([4, 6, , 11]);
                  return [4, FileSystemHelper.accessAsync(this._fileFullPath, fs.constants.F_OK)];
                case 5:
                  _a.sent();
                  return [3, 11];
                case 6:
                  appendError_1 = _a.sent();
                  _a.label = 7;
                case 7:
                  _a.trys.push([7, 9, , 10]);
                  return [4, FileSystemHelper.appendFileAsync(this._fileFullPath, data)];
                case 8:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
                case 9:
                  err_2 = _a.sent();
                  console.log(this.TAG, "Failed to put log into file: " + (appendError_1 && appendError_1.message));
                  return [
                    2
                    /*return*/
                  ];
                case 10:
                  return [3, 11];
                case 11:
                  _a.trys.push([11, 17, , 18]);
                  return [4, FileSystemHelper.getShallowFileSize(this._fileFullPath)];
                case 12:
                  size = _a.sent();
                  if (!(size > this.maxSizeBytes))
                    return [3, 14];
                  return [4, this._createBackupFile(data)];
                case 13:
                  _a.sent();
                  return [3, 16];
                case 14:
                  return [4, FileSystemHelper.appendFileAsync(this._fileFullPath, data)];
                case 15:
                  _a.sent();
                  _a.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  err_3 = _a.sent();
                  console.log(this.TAG, "Failed to create backup file: " + (err_3 && err_3.message));
                  return [3, 18];
                case 18:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        InternalAzureLogger2.prototype._createBackupFile = function(data) {
          return __awaiter(this, void 0, void 0, function() {
            var buffer, backupPath, err_4;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 3, 4, 5]);
                  return [4, FileSystemHelper.readFileAsync(this._fileFullPath)];
                case 1:
                  buffer = _a.sent();
                  backupPath = path2.join(this._tempDir, (/* @__PURE__ */ new Date()).getTime() + "." + this._logFileName);
                  return [4, FileSystemHelper.writeFileAsync(backupPath, buffer)];
                case 2:
                  _a.sent();
                  return [3, 5];
                case 3:
                  err_4 = _a.sent();
                  console.log("Failed to generate backup log file", err_4);
                  return [3, 5];
                case 4:
                  FileSystemHelper.writeFileAsync(this._fileFullPath, data);
                  return [
                    7
                    /*endfinally*/
                  ];
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        InternalAzureLogger2.prototype._fileCleanupTask = function() {
          return __awaiter(this, void 0, void 0, function() {
            var files, totalFiles, i, pathToDelete, err_5;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 6, , 7]);
                  return [4, FileSystemHelper.readdirAsync(this._tempDir)];
                case 1:
                  files = _a.sent();
                  files = files.filter(function(f) {
                    return path2.basename(f).indexOf(_this._backUpNameFormat) > -1;
                  });
                  files.sort(function(a, b) {
                    var aCreationDate = new Date(parseInt(a.split(_this._backUpNameFormat)[0]));
                    var bCreationDate = new Date(parseInt(b.split(_this._backUpNameFormat)[0]));
                    if (aCreationDate < bCreationDate) {
                      return -1;
                    }
                    if (aCreationDate >= bCreationDate) {
                      return 1;
                    }
                  });
                  totalFiles = files.length;
                  i = 0;
                  _a.label = 2;
                case 2:
                  if (!(i < totalFiles - this.maxHistory))
                    return [3, 5];
                  pathToDelete = path2.join(this._tempDir, files[i]);
                  return [4, FileSystemHelper.unlinkAsync(pathToDelete)];
                case 3:
                  _a.sent();
                  _a.label = 4;
                case 4:
                  i++;
                  return [3, 2];
                case 5:
                  return [3, 7];
                case 6:
                  err_5 = _a.sent();
                  console.log(this.TAG, "Failed to cleanup log files: " + (err_5 && err_5.message));
                  return [3, 7];
                case 7:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        InternalAzureLogger2._fileCleanupTimer = null;
        return InternalAzureLogger2;
      }()
    );
    module2.exports = InternalAzureLogger;
  }
});

// node_modules/applicationinsights/out/Library/Logging.js
var require_Logging = __commonJS({
  "node_modules/applicationinsights/out/Library/Logging.js"(exports2, module2) {
    "use strict";
    var InternalAzureLogger = require_InternalAzureLogger();
    var Logging = (
      /** @class */
      function() {
        function Logging2() {
        }
        Logging2.info = function(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          if (this.enableDebug) {
            InternalAzureLogger.getInstance().info(this.TAG + message, optionalParams);
          }
        };
        Logging2.warn = function(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          if (!this.disableWarnings) {
            InternalAzureLogger.getInstance().warning(this.TAG + message, optionalParams);
          }
        };
        Logging2.enableDebug = false;
        Logging2.disableWarnings = false;
        Logging2.TAG = "ApplicationInsights:";
        return Logging2;
      }()
    );
    module2.exports = Logging;
  }
});

// node_modules/applicationinsights/out/Library/JsonConfig.js
var require_JsonConfig = __commonJS({
  "node_modules/applicationinsights/out/Library/JsonConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.JsonConfig = void 0;
    var fs = require("fs");
    var path2 = require("path");
    var Logging = require_Logging();
    var ENV_CONFIGURATION_FILE = "APPLICATIONINSIGHTS_CONFIGURATION_FILE";
    var ENV_connectionString = "APPLICATIONINSIGHTS_CONNECTION_STRING";
    var ENV_azurePrefix = "APPSETTING_";
    var ENV_instrumentationKey = "APPINSIGHTS_INSTRUMENTATIONKEY";
    var ENV_legacyInstrumentationKey = "APPINSIGHTS_INSTRUMENTATION_KEY";
    var ENV_nativeMetricsDisablers = "APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC";
    var ENV_nativeMetricsDisableAll = "APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS";
    var ENV_http_proxy = "http_proxy";
    var ENV_https_proxy = "https_proxy";
    var ENV_noDiagnosticChannel = "APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL";
    var ENV_noStatsbeat = "APPLICATION_INSIGHTS_NO_STATSBEAT";
    var ENV_noHttpAgentKeepAlive = "APPLICATION_INSIGHTS_NO_HTTP_AGENT_KEEP_ALIVE";
    var ENV_noPatchModules = "APPLICATION_INSIGHTS_NO_PATCH_MODULES";
    var ENV_webInstrumentationEnable = "APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_ENABLED";
    var ENV_webInstrumentation_connectionString = "APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_CONNECTION_STRING";
    var ENV_webInstrumentation_source = "APPLICATIONINSIGHTS_WEB_INSTRUMENTATION_SOURCE";
    var ENV_webSnippetEnable = "APPLICATIONINSIGHTS_WEB_SNIPPET_ENABLED";
    var ENV_webSnippet_connectionString = "APPLICATIONINSIGHTS_WEB_SNIPPET_CONNECTION_STRING";
    var JsonConfig = (
      /** @class */
      function() {
        function JsonConfig2() {
          this.connectionString = process.env[ENV_connectionString];
          this.instrumentationKey = process.env[ENV_instrumentationKey] || process.env[ENV_azurePrefix + ENV_instrumentationKey] || process.env[ENV_legacyInstrumentationKey] || process.env[ENV_azurePrefix + ENV_legacyInstrumentationKey];
          if (!this.connectionString && this.instrumentationKey) {
            Logging.warn("APPINSIGHTS_INSTRUMENTATIONKEY is in path of deprecation, please use APPLICATIONINSIGHTS_CONNECTION_STRING env variable to setup the SDK.");
          }
          this.disableAllExtendedMetrics = !!process.env[ENV_nativeMetricsDisableAll];
          this.extendedMetricDisablers = process.env[ENV_nativeMetricsDisablers];
          this.proxyHttpUrl = process.env[ENV_http_proxy];
          this.proxyHttpsUrl = process.env[ENV_https_proxy];
          this.noDiagnosticChannel = !!process.env[ENV_noDiagnosticChannel];
          this.disableStatsbeat = !!process.env[ENV_noStatsbeat];
          this.noHttpAgentKeepAlive = !!process.env[ENV_noHttpAgentKeepAlive];
          this.noPatchModules = process.env[ENV_noPatchModules] || "";
          this.enableWebInstrumentation = !!process.env[ENV_webInstrumentationEnable] || !!process.env[ENV_webSnippetEnable];
          this.webInstrumentationSrc = process.env[ENV_webInstrumentation_source] || "";
          this.webInstrumentationConnectionString = process.env[ENV_webInstrumentation_connectionString] || process.env[ENV_webSnippet_connectionString] || "";
          this.enableAutoWebSnippetInjection = this.enableWebInstrumentation;
          this.webSnippetConnectionString = this.webInstrumentationConnectionString;
          this._loadJsonFile();
        }
        JsonConfig2.getInstance = function() {
          if (!JsonConfig2._instance) {
            JsonConfig2._instance = new JsonConfig2();
          }
          return JsonConfig2._instance;
        };
        JsonConfig2.prototype._loadJsonFile = function() {
          var configFileName = "applicationinsights.json";
          var rootPath = path2.join(__dirname, "../../");
          var tempDir = path2.join(rootPath, configFileName);
          var configFile = process.env[ENV_CONFIGURATION_FILE];
          if (configFile) {
            if (path2.isAbsolute(configFile)) {
              tempDir = configFile;
            } else {
              tempDir = path2.join(rootPath, configFile);
            }
          }
          try {
            var jsonConfig = JSON.parse(fs.readFileSync(tempDir, "utf8"));
            if (jsonConfig.disableStatsbeat != void 0) {
              this.disableStatsbeat = jsonConfig.disableStatsbeat;
            }
            if (jsonConfig.disableAllExtendedMetrics != void 0) {
              this.disableAllExtendedMetrics = jsonConfig.disableStatsbeat;
            }
            if (jsonConfig.noDiagnosticChannel != void 0) {
              this.noDiagnosticChannel = jsonConfig.noDiagnosticChannel;
            }
            if (jsonConfig.noHttpAgentKeepAlive != void 0) {
              this.noHttpAgentKeepAlive = jsonConfig.noHttpAgentKeepAlive;
            }
            if (jsonConfig.connectionString != void 0) {
              this.connectionString = jsonConfig.connectionString;
            }
            if (jsonConfig.extendedMetricDisablers != void 0) {
              this.extendedMetricDisablers = jsonConfig.extendedMetricDisablers;
            }
            if (jsonConfig.noDiagnosticChannel != void 0) {
              this.noDiagnosticChannel = jsonConfig.noDiagnosticChannel;
            }
            if (jsonConfig.proxyHttpUrl != void 0) {
              this.proxyHttpUrl = jsonConfig.proxyHttpUrl;
            }
            if (jsonConfig.proxyHttpsUrl != void 0) {
              this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl;
            }
            if (jsonConfig.proxyHttpsUrl != void 0) {
              this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl;
            }
            if (jsonConfig.noPatchModules != void 0) {
              this.noPatchModules = jsonConfig.noPatchModules;
            }
            if (jsonConfig.enableAutoWebSnippetInjection != void 0) {
              this.enableWebInstrumentation = jsonConfig.enableAutoWebSnippetInjection;
              this.enableAutoWebSnippetInjection = this.enableWebInstrumentation;
            }
            if (jsonConfig.enableWebInstrumentation != void 0) {
              this.enableWebInstrumentation = jsonConfig.enableWebInstrumentation;
              this.enableAutoWebSnippetInjection = this.enableWebInstrumentation;
            }
            if (jsonConfig.webSnippetConnectionString != void 0) {
              this.webInstrumentationConnectionString = jsonConfig.webSnippetConnectionString;
              this.webSnippetConnectionString = this.webInstrumentationConnectionString;
            }
            if (jsonConfig.webInstrumentationConnectionString != void 0) {
              this.webInstrumentationConnectionString = jsonConfig.webInstrumentationConnectionString;
              this.webSnippetConnectionString = this.webInstrumentationConnectionString;
            }
            if (jsonConfig.webInstrumentationConfig != void 0) {
              this.webInstrumentationConfig = jsonConfig.webInstrumentationConfig;
            }
            if (jsonConfig.webInstrumentationSrc != void 0) {
              this.webInstrumentationSrc = jsonConfig.webInstrumentationSrc;
            }
            this.endpointUrl = jsonConfig.endpointUrl;
            this.maxBatchSize = jsonConfig.maxBatchSize;
            this.maxBatchIntervalMs = jsonConfig.maxBatchIntervalMs;
            this.disableAppInsights = jsonConfig.disableAppInsights;
            this.samplingPercentage = jsonConfig.samplingPercentage;
            this.correlationIdRetryIntervalMs = jsonConfig.correlationIdRetryIntervalMs;
            this.correlationHeaderExcludedDomains = jsonConfig.correlationHeaderExcludedDomains;
            this.ignoreLegacyHeaders = jsonConfig.ignoreLegacyHeaders;
            this.distributedTracingMode = jsonConfig.distributedTracingMode;
            this.enableAutoCollectExternalLoggers = jsonConfig.enableAutoCollectExternalLoggers;
            this.enableAutoCollectConsole = jsonConfig.enableAutoCollectConsole;
            this.enableAutoCollectExceptions = jsonConfig.enableAutoCollectExceptions;
            this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance;
            this.enableAutoCollectExtendedMetrics = jsonConfig.enableAutoCollectExtendedMetrics;
            this.enableAutoCollectPreAggregatedMetrics = jsonConfig.enableAutoCollectPreAggregatedMetrics;
            this.enableAutoCollectHeartbeat = jsonConfig.enableAutoCollectHeartbeat;
            this.enableAutoCollectRequests = jsonConfig.enableAutoCollectRequests;
            this.enableAutoCollectDependencies = jsonConfig.enableAutoCollectDependencies;
            this.enableAutoDependencyCorrelation = jsonConfig.enableAutoDependencyCorrelation;
            this.enableAutoCollectIncomingRequestAzureFunctions = jsonConfig.enableAutoCollectIncomingRequestAzureFunctions;
            this.enableUseAsyncHooks = jsonConfig.enableUseAsyncHooks;
            this.enableUseDiskRetryCaching = jsonConfig.enableUseDiskRetryCaching;
            this.enableResendInterval = jsonConfig.enableResendInterval;
            this.enableMaxBytesOnDisk = jsonConfig.enableMaxBytesOnDisk;
            this.enableInternalDebugLogging = jsonConfig.enableInternalDebugLogging;
            this.enableInternalWarningLogging = jsonConfig.enableInternalWarningLogging;
            this.enableSendLiveMetrics = jsonConfig.enableSendLiveMetrics;
            this.quickPulseHost = jsonConfig.quickPulseHost;
          } catch (err) {
            Logging.info("Missing or invalid JSON config file: ", err);
          }
        };
        return JsonConfig2;
      }()
    );
    exports2.JsonConfig = JsonConfig;
  }
});

// node_modules/diagnostic-channel/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/diagnostic-channel/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "\\d+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[COMPARATORTRIM]);
      range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
      var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(safeRe[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/diagnostic-channel/dist/src/patchRequire.js
var require_patchRequire = __commonJS({
  "node_modules/diagnostic-channel/dist/src/patchRequire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makePatchingRequire = void 0;
    var path2 = require("path");
    var semver = require_semver();
    var channel_1 = require_channel();
    var moduleModule = require("module");
    var nativeModules = Object.keys(process.binding("natives"));
    var originalRequire = moduleModule.prototype.require;
    function makePatchingRequire(knownPatches) {
      var patchedModules = {};
      return function patchedRequire(moduleId) {
        var originalModule = originalRequire.apply(this, arguments);
        if (knownPatches[moduleId]) {
          var modulePath = moduleModule._resolveFilename(moduleId, this);
          if (patchedModules.hasOwnProperty(modulePath)) {
            return patchedModules[modulePath];
          }
          var moduleVersion = void 0;
          if (nativeModules.indexOf(moduleId) < 0) {
            try {
              moduleVersion = originalRequire.call(this, path2.join(moduleId, "package.json")).version;
            } catch (e) {
              return originalModule;
            }
          } else {
            moduleVersion = process.version.substring(1);
          }
          var prereleaseTagIndex = moduleVersion.indexOf("-");
          if (prereleaseTagIndex >= 0) {
            moduleVersion = moduleVersion.substring(0, prereleaseTagIndex);
          }
          var modifiedModule = originalModule;
          for (var _i = 0, _a = knownPatches[moduleId]; _i < _a.length; _i++) {
            var modulePatcher = _a[_i];
            if (semver.satisfies(moduleVersion, modulePatcher.versionSpecifier)) {
              modifiedModule = modulePatcher.patch(modifiedModule, modulePath);
              if (channel_1.channel) {
                var name_1 = modulePatcher.publisherName || moduleId;
                channel_1.channel.addPatchedModule(name_1, moduleVersion);
              }
            }
          }
          return patchedModules[modulePath] = modifiedModule;
        }
        return originalModule;
      };
    }
    exports2.makePatchingRequire = makePatchingRequire;
  }
});

// node_modules/diagnostic-channel/package.json
var require_package = __commonJS({
  "node_modules/diagnostic-channel/package.json"(exports2, module2) {
    module2.exports = {
      name: "diagnostic-channel",
      version: "1.1.0",
      main: "./dist/src/channel.js",
      types: "./dist/src/channel.d.ts",
      scripts: {
        build: "tsc",
        lint: "tslint -c tslint.json -p tsconfig.json",
        clean: "rimraf ./dist",
        test: "mocha ./dist/tests/**/*.js",
        debug: "mocha --inspect-brk ./dist/tests/**/*.js"
      },
      homepage: "https://github.com/Microsoft/node-diagnostic-channel",
      bugs: {
        url: "https://github.com/Microsoft/node-diagnostic-channel/issues"
      },
      repository: {
        type: "git",
        url: "https://github.com/Microsoft/node-diagnostic-channel.git"
      },
      description: "Provides a context-saving pub/sub channel to connect diagnostic event publishers and subscribers",
      dependencies: {
        semver: "^5.3.0"
      },
      devDependencies: {
        "@types/mocha": "^2.2.40",
        "@types/node": "~8.0.0",
        mocha: "^3.2.0",
        rimraf: "^2.6.1",
        sinon: "1.17.6",
        tslint: "^5.0.0",
        typescript: "4.1.2"
      },
      files: [
        "dist/src/**/*.d.ts",
        "dist/src/**/*.js",
        "LICENSE",
        "README.md",
        "package.json"
      ],
      license: "MIT"
    };
  }
});

// node_modules/diagnostic-channel/dist/src/channel.js
var require_channel = __commonJS({
  "node_modules/diagnostic-channel/dist/src/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.channel = exports2.ContextPreservingEventEmitter = exports2.trueFilter = exports2.makePatchingRequire = void 0;
    var patchRequire_1 = require_patchRequire();
    var patchRequire_2 = require_patchRequire();
    Object.defineProperty(exports2, "makePatchingRequire", { enumerable: true, get: function() {
      return patchRequire_2.makePatchingRequire;
    } });
    var trueFilter = function(publishing) {
      return true;
    };
    exports2.trueFilter = trueFilter;
    var ContextPreservingEventEmitter = (
      /** @class */
      function() {
        function ContextPreservingEventEmitter2() {
          this.version = require_package().version;
          this.subscribers = {};
          this.contextPreservationFunction = function(cb) {
            return cb;
          };
          this.knownPatches = {};
          this.modulesPatched = [];
          this.currentlyPublishing = false;
        }
        ContextPreservingEventEmitter2.prototype.shouldPublish = function(name2) {
          var listeners = this.subscribers[name2];
          if (listeners) {
            return listeners.some(function(_a) {
              var filter = _a.filter;
              return !filter || filter(false);
            });
          }
          return false;
        };
        ContextPreservingEventEmitter2.prototype.publish = function(name2, event) {
          if (this.currentlyPublishing) {
            return;
          }
          var listeners = this.subscribers[name2];
          if (listeners) {
            var standardEvent_1 = {
              timestamp: Date.now(),
              data: event
            };
            this.currentlyPublishing = true;
            listeners.forEach(function(_a) {
              var listener = _a.listener, filter = _a.filter;
              try {
                if (filter && filter(true)) {
                  listener(standardEvent_1);
                }
              } catch (e) {
              }
            });
            this.currentlyPublishing = false;
          }
        };
        ContextPreservingEventEmitter2.prototype.subscribe = function(name2, listener, filter, patchCallback) {
          if (filter === void 0) {
            filter = exports2.trueFilter;
          }
          if (!this.subscribers[name2]) {
            this.subscribers[name2] = [];
          }
          this.subscribers[name2].push({ listener, filter, patchCallback });
          var patched = this.checkIfModuleIsAlreadyPatched(name2);
          if (patched && patchCallback) {
            patchCallback(patched.name, patched.version);
          }
        };
        ContextPreservingEventEmitter2.prototype.unsubscribe = function(name2, listener, filter) {
          if (filter === void 0) {
            filter = exports2.trueFilter;
          }
          var listeners = this.subscribers[name2];
          if (listeners) {
            for (var index = 0; index < listeners.length; ++index) {
              if (listeners[index].listener === listener && listeners[index].filter === filter) {
                listeners.splice(index, 1);
                return true;
              }
            }
          }
          return false;
        };
        ContextPreservingEventEmitter2.prototype.reset = function() {
          var _this = this;
          this.subscribers = {};
          this.contextPreservationFunction = function(cb) {
            return cb;
          };
          Object.getOwnPropertyNames(this.knownPatches).forEach(function(prop) {
            return delete _this.knownPatches[prop];
          });
        };
        ContextPreservingEventEmitter2.prototype.bindToContext = function(cb) {
          return this.contextPreservationFunction(cb);
        };
        ContextPreservingEventEmitter2.prototype.addContextPreservation = function(preserver) {
          var previousPreservationStack = this.contextPreservationFunction;
          this.contextPreservationFunction = function(cb) {
            return preserver(previousPreservationStack(cb));
          };
        };
        ContextPreservingEventEmitter2.prototype.registerMonkeyPatch = function(packageName, patcher) {
          if (!this.knownPatches[packageName]) {
            this.knownPatches[packageName] = [];
          }
          this.knownPatches[packageName].push(patcher);
        };
        ContextPreservingEventEmitter2.prototype.getPatchesObject = function() {
          return this.knownPatches;
        };
        ContextPreservingEventEmitter2.prototype.addPatchedModule = function(name2, version) {
          for (var _i = 0, _a = this.modulesPatched; _i < _a.length; _i++) {
            var module_1 = _a[_i];
            if (module_1.name === name2) {
              return;
            }
          }
          this.modulesPatched.push({ name: name2, version });
          var listeners = this.subscribers[name2];
          if (listeners) {
            listeners.forEach(function(listener) {
              if (listener.patchCallback) {
                listener.patchCallback(name2, version);
              }
            });
          }
        };
        ContextPreservingEventEmitter2.prototype.checkIfModuleIsAlreadyPatched = function(name2) {
          for (var _i = 0, _a = this.modulesPatched; _i < _a.length; _i++) {
            var module_2 = _a[_i];
            if (module_2.name === name2) {
              return module_2;
            }
          }
          return null;
        };
        return ContextPreservingEventEmitter2;
      }()
    );
    exports2.ContextPreservingEventEmitter = ContextPreservingEventEmitter;
    if (!global.diagnosticsSource) {
      global.diagnosticsSource = new ContextPreservingEventEmitter();
      moduleModule = require("module");
      moduleModule.prototype.require = patchRequire_1.makePatchingRequire(global.diagnosticsSource.getPatchesObject());
    }
    var moduleModule;
    exports2.channel = global.diagnosticsSource;
  }
});

// node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS({
  "node_modules/@opentelemetry/api/build/src/platform/node/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_globalThis(), exports2);
  }
});

// node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS({
  "node_modules/@opentelemetry/api/build/src/platform/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node(), exports2);
  }
});

// node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS({
  "node_modules/@opentelemetry/api/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.4.1";
  }
});

// node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver2 = __commonJS({
  "node_modules/@opentelemetry/api/build/src/internal/semver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCompatible = exports2._makeCompatibilityCheck = void 0;
    var version_1 = require_version();
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      const acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      const rejectedVersions = /* @__PURE__ */ new Set();
      const myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return () => false;
      }
      const ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        };
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        const globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        const globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      };
    }
    exports2._makeCompatibilityCheck = _makeCompatibilityCheck;
    exports2.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
  }
});

// node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/internal/global-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unregisterGlobal = exports2.getGlobal = exports2.registerGlobal = void 0;
    var platform_1 = require_platform();
    var version_1 = require_version();
    var semver_1 = require_semver2();
    var major = version_1.VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
    var _global = platform_1._globalThis;
    function registerGlobal(type, instance, diag, allowOverride = false) {
      var _a;
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: version_1.VERSION
      };
      if (!allowOverride && api[type]) {
        const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== version_1.VERSION) {
        const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
      return true;
    }
    exports2.registerGlobal = registerGlobal;
    function getGlobal(type) {
      var _a, _b;
      const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
        return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    exports2.getGlobal = getGlobal;
    function unregisterGlobal(type, diag) {
      diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }
    exports2.unregisterGlobal = unregisterGlobal;
  }
});

// node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagComponentLogger = void 0;
    var global_utils_1 = require_global_utils();
    var DiagComponentLogger = class {
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args) {
        return logProxy("debug", this._namespace, args);
      }
      error(...args) {
        return logProxy("error", this._namespace, args);
      }
      info(...args) {
        return logProxy("info", this._namespace, args);
      }
      warn(...args) {
        return logProxy("warn", this._namespace, args);
      }
      verbose(...args) {
        return logProxy("verbose", this._namespace, args);
      }
    };
    exports2.DiagComponentLogger = DiagComponentLogger;
    function logProxy(funcName, namespace, args) {
      const logger = (0, global_utils_1.getGlobal)("diag");
      if (!logger) {
        return;
      }
      args.unshift(namespace);
      return logger[funcName](...args);
    }
  }
});

// node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagLogLevel = void 0;
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel = exports2.DiagLogLevel || (exports2.DiagLogLevel = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createLogLevelDiagLogger = void 0;
    var types_1 = require_types();
    function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < types_1.DiagLogLevel.NONE) {
        maxLevel = types_1.DiagLogLevel.NONE;
      } else if (maxLevel > types_1.DiagLogLevel.ALL) {
        maxLevel = types_1.DiagLogLevel.ALL;
      }
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
        const theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger);
        }
        return function() {
        };
      }
      return {
        error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
        warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
        info: _filterFunc("info", types_1.DiagLogLevel.INFO),
        debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
      };
    }
    exports2.createLogLevelDiagLogger = createLogLevelDiagLogger;
  }
});

// node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/diag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagAPI = void 0;
    var ComponentLogger_1 = require_ComponentLogger();
    var logLevelLogger_1 = require_logLevelLogger();
    var types_1 = require_types();
    var global_utils_1 = require_global_utils();
    var API_NAME = "diag";
    var DiagAPI = class _DiagAPI {
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
        function _logProxy(funcName) {
          return function(...args) {
            const logger = (0, global_utils_1.getGlobal)("diag");
            if (!logger)
              return;
            return logger[funcName](...args);
          };
        }
        const self2 = this;
        const setLogger = (logger, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
          var _a, _b, _c;
          if (logger === self2) {
            const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          const oldLogger = (0, global_utils_1.getGlobal)("diag");
          const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            const stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn(`Current logger will be overwritten from ${stack}`);
            newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
          }
          return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
        };
        self2.createComponentLogger = (options) => {
          return new ComponentLogger_1.DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
        if (!this._instance) {
          this._instance = new _DiagAPI();
        }
        return this._instance;
      }
    };
    exports2.DiagAPI = DiagAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaggageImpl = void 0;
    var BaggageImpl = class _BaggageImpl {
      constructor(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      getEntry(key) {
        const entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      }
      getAllEntries() {
        return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
      }
      setEntry(key, entry) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      }
      removeEntry(key) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      }
      removeEntries(...keys) {
        const newBaggage = new _BaggageImpl(this._entries);
        for (const key of keys) {
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      }
      clear() {
        return new _BaggageImpl();
      }
    };
    exports2.BaggageImpl = BaggageImpl;
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.baggageEntryMetadataSymbol = void 0;
    exports2.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.baggageEntryMetadataFromString = exports2.createBaggage = void 0;
    var diag_1 = require_diag();
    var baggage_impl_1 = require_baggage_impl();
    var symbol_1 = require_symbol();
    var diag = diag_1.DiagAPI.instance();
    function createBaggage(entries = {}) {
      return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
    }
    exports2.createBaggage = createBaggage;
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
        str = "";
      }
      return {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString() {
          return str;
        }
      };
    }
    exports2.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  }
});

// node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS({
  "node_modules/@opentelemetry/api/build/src/context/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ROOT_CONTEXT = exports2.createContextKey = void 0;
    function createContextKey(description) {
      return Symbol.for(description);
    }
    exports2.createContextKey = createContextKey;
    var BaseContext = class _BaseContext {
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
        const self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = (key) => self2._currentContext.get(key);
        self2.setValue = (key, value) => {
          const context = new _BaseContext(self2._currentContext);
          context._currentContext.set(key, value);
          return context;
        };
        self2.deleteValue = (key) => {
          const context = new _BaseContext(self2._currentContext);
          context._currentContext.delete(key);
          return context;
        };
      }
    };
    exports2.ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagConsoleLogger = void 0;
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    var DiagConsoleLogger = class {
      constructor() {
        function _consoleFunc(funcName) {
          return function(...args) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (let i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
    };
    exports2.DiagConsoleLogger = DiagConsoleLogger;
  }
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createNoopMeter = exports2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports2.NOOP_OBSERVABLE_GAUGE_METRIC = exports2.NOOP_OBSERVABLE_COUNTER_METRIC = exports2.NOOP_UP_DOWN_COUNTER_METRIC = exports2.NOOP_HISTOGRAM_METRIC = exports2.NOOP_COUNTER_METRIC = exports2.NOOP_METER = exports2.NoopObservableUpDownCounterMetric = exports2.NoopObservableGaugeMetric = exports2.NoopObservableCounterMetric = exports2.NoopObservableMetric = exports2.NoopHistogramMetric = exports2.NoopUpDownCounterMetric = exports2.NoopCounterMetric = exports2.NoopMetric = exports2.NoopMeter = void 0;
    var NoopMeter = class {
      constructor() {
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
        return exports2.NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
        return exports2.NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
        return exports2.NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
        return exports2.NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
        return exports2.NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
        return exports2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) {
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) {
      }
    };
    exports2.NoopMeter = NoopMeter;
    var NoopMetric = class {
    };
    exports2.NoopMetric = NoopMetric;
    var NoopCounterMetric = class extends NoopMetric {
      add(_value, _attributes) {
      }
    };
    exports2.NoopCounterMetric = NoopCounterMetric;
    var NoopUpDownCounterMetric = class extends NoopMetric {
      add(_value, _attributes) {
      }
    };
    exports2.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
    var NoopHistogramMetric = class extends NoopMetric {
      record(_value, _attributes) {
      }
    };
    exports2.NoopHistogramMetric = NoopHistogramMetric;
    var NoopObservableMetric = class {
      addCallback(_callback) {
      }
      removeCallback(_callback) {
      }
    };
    exports2.NoopObservableMetric = NoopObservableMetric;
    var NoopObservableCounterMetric = class extends NoopObservableMetric {
    };
    exports2.NoopObservableCounterMetric = NoopObservableCounterMetric;
    var NoopObservableGaugeMetric = class extends NoopObservableMetric {
    };
    exports2.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
    var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
    };
    exports2.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
    exports2.NOOP_METER = new NoopMeter();
    exports2.NOOP_COUNTER_METRIC = new NoopCounterMetric();
    exports2.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    exports2.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    exports2.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    exports2.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    exports2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    function createNoopMeter() {
      return exports2.NOOP_METER;
    }
    exports2.createNoopMeter = createNoopMeter;
  }
});

// node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics/Metric.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueType = void 0;
    var ValueType;
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType = exports2.ValueType || (exports2.ValueType = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS({
  "node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultTextMapSetter = exports2.defaultTextMapGetter = void 0;
    exports2.defaultTextMapGetter = {
      get(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    exports2.defaultTextMapSetter = {
      set(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS({
  "node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoopContextManager = void 0;
    var context_1 = require_context();
    var NoopContextManager = class {
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      bind(_context, target) {
        return target;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
    exports2.NoopContextManager = NoopContextManager;
  }
});

// node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContextAPI = void 0;
    var NoopContextManager_1 = require_NoopContextManager();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
    var ContextAPI = class _ContextAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Context API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _ContextAPI();
        }
        return this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
        return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context, fn, thisArg, ...args) {
        return this._getContextManager().with(context, fn, thisArg, ...args);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context, target) {
        return this._getContextManager().bind(context, target);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
        this._getContextManager().disable();
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports2.ContextAPI = ContextAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/trace_flags.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceFlags = void 0;
    var TraceFlags;
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags = exports2.TraceFlags || (exports2.TraceFlags = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.INVALID_SPAN_CONTEXT = exports2.INVALID_TRACEID = exports2.INVALID_SPANID = void 0;
    var trace_flags_1 = require_trace_flags();
    exports2.INVALID_SPANID = "0000000000000000";
    exports2.INVALID_TRACEID = "00000000000000000000000000000000";
    exports2.INVALID_SPAN_CONTEXT = {
      traceId: exports2.INVALID_TRACEID,
      spanId: exports2.INVALID_SPANID,
      traceFlags: trace_flags_1.TraceFlags.NONE
    };
  }
});

// node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NonRecordingSpan = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan = class {
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
        return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
        return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
        return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
        return this;
      }
      // By default does nothing
      setStatus(_status) {
        return this;
      }
      // By default does nothing
      updateName(_name) {
        return this;
      }
      // By default does nothing
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return false;
      }
      // By default does nothing
      recordException(_exception, _time) {
      }
    };
    exports2.NonRecordingSpan = NonRecordingSpan;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/context-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSpanContext = exports2.setSpanContext = exports2.deleteSpan = exports2.setSpan = exports2.getActiveSpan = exports2.getSpan = void 0;
    var context_1 = require_context();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var context_2 = require_context2();
    var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
    function getSpan(context) {
      return context.getValue(SPAN_KEY) || void 0;
    }
    exports2.getSpan = getSpan;
    function getActiveSpan() {
      return getSpan(context_2.ContextAPI.getInstance().active());
    }
    exports2.getActiveSpan = getActiveSpan;
    function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
    }
    exports2.setSpan = setSpan;
    function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
    }
    exports2.deleteSpan = deleteSpan;
    function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
    }
    exports2.setSpanContext = setSpanContext;
    function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }
    exports2.getSpanContext = getSpanContext;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.wrapSpanContext = exports2.isSpanContextValid = exports2.isValidSpanId = exports2.isValidTraceId = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
    }
    exports2.isValidTraceId = isValidTraceId;
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
    }
    exports2.isValidSpanId = isValidSpanId;
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    exports2.isSpanContextValid = isSpanContextValid;
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
    }
    exports2.wrapSpanContext = wrapSpanContext;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoopTracer = void 0;
    var context_1 = require_context2();
    var context_utils_1 = require_context_utils();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var spancontext_utils_1 = require_spancontext_utils();
    var contextApi = context_1.ContextAPI.getInstance();
    var NoopTracer = class {
      // startSpan starts a noop span.
      startSpan(name2, options, context = contextApi.active()) {
        const root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
        const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
        if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
          return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
      }
      startActiveSpan(name2, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        const span = this.startSpan(name2, opts, parentContext);
        const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      }
    };
    exports2.NoopTracer = NoopTracer;
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyTracer = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NOOP_TRACER = new NoopTracer_1.NoopTracer();
    var ProxyTracer = class {
      constructor(_provider, name2, version, options) {
        this._provider = _provider;
        this.name = name2;
        this.version = version;
        this.options = options;
      }
      startSpan(name2, options, context) {
        return this._getTracer().startSpan(name2, options, context);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        const tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
        if (this._delegate) {
          return this._delegate;
        }
        const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      }
    };
    exports2.ProxyTracer = ProxyTracer;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoopTracerProvider = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NoopTracerProvider = class {
      getTracer(_name, _version, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
    exports2.NoopTracerProvider = NoopTracerProvider;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyTracerProvider = void 0;
    var ProxyTracer_1 = require_ProxyTracer();
    var NoopTracerProvider_1 = require_NoopTracerProvider();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
    var ProxyTracerProvider = class {
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name2, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name2, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name2, version, options);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name2, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name2, version, options);
      }
    };
    exports2.ProxyTracerProvider = ProxyTracerProvider;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports2.SamplingDecision || (exports2.SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/span_kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpanKind = void 0;
    var SpanKind;
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind = exports2.SpanKind || (exports2.SpanKind = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/status.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SpanStatusCode = void 0;
    var SpanStatusCode;
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode = exports2.SpanStatusCode || (exports2.SpanStatusCode = {}));
  }
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
    var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
    var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    exports2.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    exports2.validateValue = validateValue;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceStateImpl = void 0;
    var tracestate_validators_1 = require_tracestate_validators();
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = class _TraceStateImpl {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceStateImpl = TraceStateImpl;
  }
});

// node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace/internal/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTraceState = void 0;
    var tracestate_impl_1 = require_tracestate_impl();
    function createTraceState(rawTraceState) {
      return new tracestate_impl_1.TraceStateImpl(rawTraceState);
    }
    exports2.createTraceState = createTraceState;
  }
});

// node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/context-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.context = void 0;
    var context_1 = require_context2();
    exports2.context = context_1.ContextAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/diag-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.diag = void 0;
    var diag_1 = require_diag();
    exports2.diag = diag_1.DiagAPI.instance();
  }
});

// node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOOP_METER_PROVIDER = exports2.NoopMeterProvider = void 0;
    var NoopMeter_1 = require_NoopMeter();
    var NoopMeterProvider = class {
      getMeter(_name, _version, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
    exports2.NoopMeterProvider = NoopMeterProvider;
    exports2.NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/metrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetricsAPI = void 0;
    var NoopMeterProvider_1 = require_NoopMeterProvider();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "metrics";
    var MetricsAPI = class _MetricsAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _MetricsAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name2, version, options) {
        return this.getMeterProvider().getMeter(name2, version, options);
      }
      /** Remove the global meter provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports2.MetricsAPI = MetricsAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/metrics-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.metrics = void 0;
    var metrics_1 = require_metrics();
    exports2.metrics = metrics_1.MetricsAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS({
  "node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoopTextMapPropagator = void 0;
    var NoopTextMapPropagator = class {
      /** Noop inject function does nothing */
      inject(_context, _carrier) {
      }
      /** Noop extract function does nothing and returns the input context */
      extract(context, _carrier) {
        return context;
      }
      fields() {
        return [];
      }
    };
    exports2.NoopTextMapPropagator = NoopTextMapPropagator;
  }
});

// node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS({
  "node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deleteBaggage = exports2.setBaggage = exports2.getActiveBaggage = exports2.getBaggage = void 0;
    var context_1 = require_context2();
    var context_2 = require_context();
    var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
    function getBaggage(context) {
      return context.getValue(BAGGAGE_KEY) || void 0;
    }
    exports2.getBaggage = getBaggage;
    function getActiveBaggage() {
      return getBaggage(context_1.ContextAPI.getInstance().active());
    }
    exports2.getActiveBaggage = getActiveBaggage;
    function setBaggage(context, baggage) {
      return context.setValue(BAGGAGE_KEY, baggage);
    }
    exports2.setBaggage = setBaggage;
    function deleteBaggage(context) {
      return context.deleteValue(BAGGAGE_KEY);
    }
    exports2.deleteBaggage = deleteBaggage;
  }
});

// node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/propagation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PropagationAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
    var TextMapPropagator_1 = require_TextMapPropagator();
    var context_helpers_1 = require_context_helpers();
    var utils_1 = require_utils();
    var diag_1 = require_diag();
    var API_NAME = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator();
    var PropagationAPI = class _PropagationAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this.createBaggage = utils_1.createBaggage;
        this.getBaggage = context_helpers_1.getBaggage;
        this.getActiveBaggage = context_helpers_1.getActiveBaggage;
        this.setBaggage = context_helpers_1.setBaggage;
        this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _PropagationAPI();
        }
        return this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
        return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
    exports2.PropagationAPI = PropagationAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/propagation-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.propagation = void 0;
    var propagation_1 = require_propagation();
    exports2.propagation = propagation_1.PropagationAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS({
  "node_modules/@opentelemetry/api/build/src/api/trace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceAPI = void 0;
    var global_utils_1 = require_global_utils();
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    var spancontext_utils_1 = require_spancontext_utils();
    var context_utils_1 = require_context_utils();
    var diag_1 = require_diag();
    var API_NAME = "trace";
    var TraceAPI = class _TraceAPI {
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
        this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
        this.deleteSpan = context_utils_1.deleteSpan;
        this.getSpan = context_utils_1.getSpan;
        this.getActiveSpan = context_utils_1.getActiveSpan;
        this.getSpanContext = context_utils_1.getSpanContext;
        this.setSpan = context_utils_1.setSpan;
        this.setSpanContext = context_utils_1.setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _TraceAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
        const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name2, version) {
        return this.getTracerProvider().getTracer(name2, version);
      }
      /** Remove the global tracer provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
    exports2.TraceAPI = TraceAPI;
  }
});

// node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS({
  "node_modules/@opentelemetry/api/build/src/trace-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.trace = void 0;
    var trace_1 = require_trace();
    exports2.trace = trace_1.TraceAPI.getInstance();
  }
});

// node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS({
  "node_modules/@opentelemetry/api/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.trace = exports2.propagation = exports2.metrics = exports2.diag = exports2.context = exports2.INVALID_SPAN_CONTEXT = exports2.INVALID_TRACEID = exports2.INVALID_SPANID = exports2.isValidSpanId = exports2.isValidTraceId = exports2.isSpanContextValid = exports2.createTraceState = exports2.TraceFlags = exports2.SpanStatusCode = exports2.SpanKind = exports2.SamplingDecision = exports2.ProxyTracerProvider = exports2.ProxyTracer = exports2.defaultTextMapSetter = exports2.defaultTextMapGetter = exports2.ValueType = exports2.createNoopMeter = exports2.DiagLogLevel = exports2.DiagConsoleLogger = exports2.ROOT_CONTEXT = exports2.createContextKey = exports2.baggageEntryMetadataFromString = void 0;
    var utils_1 = require_utils();
    Object.defineProperty(exports2, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
      return utils_1.baggageEntryMetadataFromString;
    } });
    var context_1 = require_context();
    Object.defineProperty(exports2, "createContextKey", { enumerable: true, get: function() {
      return context_1.createContextKey;
    } });
    Object.defineProperty(exports2, "ROOT_CONTEXT", { enumerable: true, get: function() {
      return context_1.ROOT_CONTEXT;
    } });
    var consoleLogger_1 = require_consoleLogger();
    Object.defineProperty(exports2, "DiagConsoleLogger", { enumerable: true, get: function() {
      return consoleLogger_1.DiagConsoleLogger;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports2, "DiagLogLevel", { enumerable: true, get: function() {
      return types_1.DiagLogLevel;
    } });
    var NoopMeter_1 = require_NoopMeter();
    Object.defineProperty(exports2, "createNoopMeter", { enumerable: true, get: function() {
      return NoopMeter_1.createNoopMeter;
    } });
    var Metric_1 = require_Metric();
    Object.defineProperty(exports2, "ValueType", { enumerable: true, get: function() {
      return Metric_1.ValueType;
    } });
    var TextMapPropagator_1 = require_TextMapPropagator();
    Object.defineProperty(exports2, "defaultTextMapGetter", { enumerable: true, get: function() {
      return TextMapPropagator_1.defaultTextMapGetter;
    } });
    Object.defineProperty(exports2, "defaultTextMapSetter", { enumerable: true, get: function() {
      return TextMapPropagator_1.defaultTextMapSetter;
    } });
    var ProxyTracer_1 = require_ProxyTracer();
    Object.defineProperty(exports2, "ProxyTracer", { enumerable: true, get: function() {
      return ProxyTracer_1.ProxyTracer;
    } });
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    Object.defineProperty(exports2, "ProxyTracerProvider", { enumerable: true, get: function() {
      return ProxyTracerProvider_1.ProxyTracerProvider;
    } });
    var SamplingResult_1 = require_SamplingResult();
    Object.defineProperty(exports2, "SamplingDecision", { enumerable: true, get: function() {
      return SamplingResult_1.SamplingDecision;
    } });
    var span_kind_1 = require_span_kind();
    Object.defineProperty(exports2, "SpanKind", { enumerable: true, get: function() {
      return span_kind_1.SpanKind;
    } });
    var status_1 = require_status();
    Object.defineProperty(exports2, "SpanStatusCode", { enumerable: true, get: function() {
      return status_1.SpanStatusCode;
    } });
    var trace_flags_1 = require_trace_flags();
    Object.defineProperty(exports2, "TraceFlags", { enumerable: true, get: function() {
      return trace_flags_1.TraceFlags;
    } });
    var utils_2 = require_utils2();
    Object.defineProperty(exports2, "createTraceState", { enumerable: true, get: function() {
      return utils_2.createTraceState;
    } });
    var spancontext_utils_1 = require_spancontext_utils();
    Object.defineProperty(exports2, "isSpanContextValid", { enumerable: true, get: function() {
      return spancontext_utils_1.isSpanContextValid;
    } });
    Object.defineProperty(exports2, "isValidTraceId", { enumerable: true, get: function() {
      return spancontext_utils_1.isValidTraceId;
    } });
    Object.defineProperty(exports2, "isValidSpanId", { enumerable: true, get: function() {
      return spancontext_utils_1.isValidSpanId;
    } });
    var invalid_span_constants_1 = require_invalid_span_constants();
    Object.defineProperty(exports2, "INVALID_SPANID", { enumerable: true, get: function() {
      return invalid_span_constants_1.INVALID_SPANID;
    } });
    Object.defineProperty(exports2, "INVALID_TRACEID", { enumerable: true, get: function() {
      return invalid_span_constants_1.INVALID_TRACEID;
    } });
    Object.defineProperty(exports2, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
      return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
    } });
    var context_api_1 = require_context_api();
    Object.defineProperty(exports2, "context", { enumerable: true, get: function() {
      return context_api_1.context;
    } });
    var diag_api_1 = require_diag_api();
    Object.defineProperty(exports2, "diag", { enumerable: true, get: function() {
      return diag_api_1.diag;
    } });
    var metrics_api_1 = require_metrics_api();
    Object.defineProperty(exports2, "metrics", { enumerable: true, get: function() {
      return metrics_api_1.metrics;
    } });
    var propagation_api_1 = require_propagation_api();
    Object.defineProperty(exports2, "propagation", { enumerable: true, get: function() {
      return propagation_api_1.propagation;
    } });
    var trace_api_1 = require_trace_api();
    Object.defineProperty(exports2, "trace", { enumerable: true, get: function() {
      return trace_api_1.trace;
    } });
    exports2.default = {
      context: context_api_1.context,
      diag: diag_api_1.diag,
      metrics: metrics_api_1.metrics,
      propagation: propagation_api_1.propagation,
      trace: trace_api_1.trace
    };
  }
});

// node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracingSuppressed = exports2.unsuppressTracing = exports2.suppressTracing = void 0;
    var api_1 = require_src();
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context) {
      return context.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports2.suppressTracing = suppressTracing;
    function unsuppressTracing(context) {
      return context.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports2.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context) {
      return context.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports2.isTracingSuppressed = isTracingSuppressed;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports2.BAGGAGE_HEADER = exports2.BAGGAGE_ITEMS_SEPARATOR = exports2.BAGGAGE_PROPERTIES_SEPARATOR = exports2.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports2.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports2.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports2.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports2.BAGGAGE_HEADER = "baggage";
    exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils3 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseKeyPairsIntoRecord = exports2.parsePairKeyValue = exports2.getKeyPairs = exports2.serializeKeyPairs = void 0;
    var api_1 = require_src();
    var constants_1 = require_constants2();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports2.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports2.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports2.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports2.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CBaggagePropagator = void 0;
    var api_1 = require_src();
    var suppress_tracing_1 = require_suppress_tracing();
    var constants_1 = require_constants2();
    var utils_1 = require_utils3();
    var W3CBaggagePropagator = class {
      inject(context, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context;
        const baggage = {};
        if (baggageString.length === 0) {
          return context;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context;
        }
        return api_1.propagation.setBaggage(context, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports2.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports2.AnchoredClock = AnchoredClock;
  }
});

// node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAttributeValue = exports2.isAttributeKey = exports2.sanitizeAttributes = void 0;
    var api_1 = require_src();
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports2.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports2.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports2.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loggingErrorHandler = void 0;
    var api_1 = require_src();
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports2.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalErrorHandler = exports2.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports2.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a) {
      }
    }
    exports2.globalErrorHandler = globalErrorHandler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports2.TracesSamplerValues || (exports2.TracesSamplerValues = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/platform/browser/globalThis.js
var require_globalThis2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/browser/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  }
});

// node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnvWithoutDefaults = exports2.parseEnvironment = exports2.DEFAULT_ENVIRONMENT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = require_src();
    var sampling_1 = require_sampling();
    var globalThis_1 = require_globalThis2();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports2.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative"
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] === "undefined") {
        return;
      }
      const value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name2, environment, values, min = -Infinity, max = Infinity) {
      if (typeof values[name2] !== "undefined") {
        const value = Number(values[name2]);
        if (!isNaN(value)) {
          if (value < min) {
            environment[name2] = min;
          } else if (value > max) {
            environment[name2] = max;
          } else {
            environment[name2] = value;
          }
        }
      }
    }
    function parseStringList(name2, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name2];
      if (typeof givenValue === "string") {
        output[name2] = givenValue.split(separator).map((v) => v.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      const value = values[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values) {
      const environment = {};
      for (const env2 in exports2.DEFAULT_ENVIRONMENT) {
        const key = env2;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment, values);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              const value = values[key];
              if (typeof value !== "undefined" && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }
    exports2.parseEnvironment = parseEnvironment;
    function getEnvWithoutDefaults() {
      return typeof process !== "undefined" && process && process.env ? parseEnvironment(process.env) : parseEnvironment(globalThis_1._globalThis);
    }
    exports2.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnv = void 0;
    var os = require("os");
    var environment_1 = require_environment();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({
        HOSTNAME: os.hostname()
      }, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports2.getEnv = getEnv;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis3 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBase64 = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    var buf8 = Buffer.alloc(8);
    var buf16 = Buffer.alloc(16);
    function hexToBase64(hexStr) {
      let buf;
      if (hexStr.length === 16) {
        buf = buf8;
      } else if (hexStr.length === 32) {
        buf = buf16;
      } else {
        buf = Buffer.alloc(hexStr.length / 2);
      }
      let offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        const hi = intValue(hexStr.charCodeAt(i));
        const lo = intValue(hexStr.charCodeAt(i + 1));
        buf.writeUInt8(hi << 4 | lo, offset++);
      }
      return buf.toString("base64");
    }
    exports2.hexToBase64 = hexToBase64;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        }
        for (let i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.otperformance = void 0;
    var perf_hooks_1 = require("perf_hooks");
    exports2.otperformance = perf_hooks_1.performance;
  }
});

// node_modules/@opentelemetry/core/build/src/version.js
var require_version2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.15.2";
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageTypeValues = exports2.RpcGrpcStatusCodeValues = exports2.MessagingOperationValues = exports2.MessagingDestinationKindValues = exports2.HttpFlavorValues = exports2.NetHostConnectionSubtypeValues = exports2.NetHostConnectionTypeValues = exports2.NetTransportValues = exports2.FaasInvokedProviderValues = exports2.FaasDocumentOperationValues = exports2.FaasTriggerValues = exports2.DbCassandraConsistencyLevelValues = exports2.DbSystemValues = exports2.SemanticAttributes = void 0;
    exports2.SemanticAttributes = {
      /**
       * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
       *
       * Note: This may be different from `faas.id` if an alias is involved.
       */
      AWS_LAMBDA_INVOKED_ARN: "aws.lambda.invoked_arn",
      /**
       * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
       */
      DB_SYSTEM: "db.system",
      /**
       * The connection string used to connect to the database. It is recommended to remove embedded credentials.
       */
      DB_CONNECTION_STRING: "db.connection_string",
      /**
       * Username for accessing the database.
       */
      DB_USER: "db.user",
      /**
       * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
       */
      DB_JDBC_DRIVER_CLASSNAME: "db.jdbc.driver_classname",
      /**
       * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
       *
       * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
       */
      DB_NAME: "db.name",
      /**
       * The database statement being executed.
       *
       * Note: The value may be sanitized to exclude sensitive information.
       */
      DB_STATEMENT: "db.statement",
      /**
       * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
       *
       * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
       */
      DB_OPERATION: "db.operation",
      /**
       * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
       *
       * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
       */
      DB_MSSQL_INSTANCE_NAME: "db.mssql.instance_name",
      /**
       * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
       */
      DB_CASSANDRA_KEYSPACE: "db.cassandra.keyspace",
      /**
       * The fetch size used for paging, i.e. how many rows will be returned at once.
       */
      DB_CASSANDRA_PAGE_SIZE: "db.cassandra.page_size",
      /**
       * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
       */
      DB_CASSANDRA_CONSISTENCY_LEVEL: "db.cassandra.consistency_level",
      /**
       * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
       *
       * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
       */
      DB_CASSANDRA_TABLE: "db.cassandra.table",
      /**
       * Whether or not the query is idempotent.
       */
      DB_CASSANDRA_IDEMPOTENCE: "db.cassandra.idempotence",
      /**
       * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
       */
      DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: "db.cassandra.speculative_execution_count",
      /**
       * The ID of the coordinating node for a query.
       */
      DB_CASSANDRA_COORDINATOR_ID: "db.cassandra.coordinator.id",
      /**
       * The data center of the coordinating node for a query.
       */
      DB_CASSANDRA_COORDINATOR_DC: "db.cassandra.coordinator.dc",
      /**
       * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
       */
      DB_HBASE_NAMESPACE: "db.hbase.namespace",
      /**
       * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
       */
      DB_REDIS_DATABASE_INDEX: "db.redis.database_index",
      /**
       * The collection being accessed within the database stated in `db.name`.
       */
      DB_MONGODB_COLLECTION: "db.mongodb.collection",
      /**
       * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
       *
       * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
       */
      DB_SQL_TABLE: "db.sql.table",
      /**
       * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
       */
      EXCEPTION_TYPE: "exception.type",
      /**
       * The exception message.
       */
      EXCEPTION_MESSAGE: "exception.message",
      /**
       * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
       */
      EXCEPTION_STACKTRACE: "exception.stacktrace",
      /**
        * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
        *
        * Note: An exception is considered to have escaped (or left) the scope of a span,
      if that span is ended while the exception is still logically &#34;in flight&#34;.
      This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
      is passed to a Context manager&#39;s `__exit__` method in Python) but will
      usually be caught at the point of recording the exception in most languages.
      
      It is usually not possible to determine at the point where an exception is thrown
      whether it will escape the scope of a span.
      However, it is trivial to know that an exception
      will escape, if one checks for an active exception just before ending the span,
      as done in the [example above](#exception-end-example).
      
      It follows that an exception may still escape the scope of the span
      even if the `exception.escaped` attribute was not set or set to false,
      since the event might have been recorded at a time where it was not
      clear whether the exception will escape.
        */
      EXCEPTION_ESCAPED: "exception.escaped",
      /**
       * Type of the trigger on which the function is executed.
       */
      FAAS_TRIGGER: "faas.trigger",
      /**
       * The execution ID of the current function execution.
       */
      FAAS_EXECUTION: "faas.execution",
      /**
       * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
       */
      FAAS_DOCUMENT_COLLECTION: "faas.document.collection",
      /**
       * Describes the type of the operation that was performed on the data.
       */
      FAAS_DOCUMENT_OPERATION: "faas.document.operation",
      /**
       * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
       */
      FAAS_DOCUMENT_TIME: "faas.document.time",
      /**
       * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
       */
      FAAS_DOCUMENT_NAME: "faas.document.name",
      /**
       * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
       */
      FAAS_TIME: "faas.time",
      /**
       * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
       */
      FAAS_CRON: "faas.cron",
      /**
       * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
       */
      FAAS_COLDSTART: "faas.coldstart",
      /**
       * The name of the invoked function.
       *
       * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
       */
      FAAS_INVOKED_NAME: "faas.invoked_name",
      /**
       * The cloud provider of the invoked function.
       *
       * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
       */
      FAAS_INVOKED_PROVIDER: "faas.invoked_provider",
      /**
       * The cloud region of the invoked function.
       *
       * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
       */
      FAAS_INVOKED_REGION: "faas.invoked_region",
      /**
       * Transport protocol used. See note below.
       */
      NET_TRANSPORT: "net.transport",
      /**
       * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
       */
      NET_PEER_IP: "net.peer.ip",
      /**
       * Remote port number.
       */
      NET_PEER_PORT: "net.peer.port",
      /**
       * Remote hostname or similar, see note below.
       */
      NET_PEER_NAME: "net.peer.name",
      /**
       * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
       */
      NET_HOST_IP: "net.host.ip",
      /**
       * Like `net.peer.port` but for the host port.
       */
      NET_HOST_PORT: "net.host.port",
      /**
       * Local hostname or similar, see note below.
       */
      NET_HOST_NAME: "net.host.name",
      /**
       * The internet connection type currently being used by the host.
       */
      NET_HOST_CONNECTION_TYPE: "net.host.connection.type",
      /**
       * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
       */
      NET_HOST_CONNECTION_SUBTYPE: "net.host.connection.subtype",
      /**
       * The name of the mobile carrier.
       */
      NET_HOST_CARRIER_NAME: "net.host.carrier.name",
      /**
       * The mobile carrier country code.
       */
      NET_HOST_CARRIER_MCC: "net.host.carrier.mcc",
      /**
       * The mobile carrier network code.
       */
      NET_HOST_CARRIER_MNC: "net.host.carrier.mnc",
      /**
       * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
       */
      NET_HOST_CARRIER_ICC: "net.host.carrier.icc",
      /**
       * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
       */
      PEER_SERVICE: "peer.service",
      /**
       * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
       */
      ENDUSER_ID: "enduser.id",
      /**
       * Actual/assumed role the client is making the request under extracted from token or application security context.
       */
      ENDUSER_ROLE: "enduser.role",
      /**
       * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
       */
      ENDUSER_SCOPE: "enduser.scope",
      /**
       * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
       */
      THREAD_ID: "thread.id",
      /**
       * Current thread name.
       */
      THREAD_NAME: "thread.name",
      /**
       * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
       */
      CODE_FUNCTION: "code.function",
      /**
       * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
       */
      CODE_NAMESPACE: "code.namespace",
      /**
       * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
       */
      CODE_FILEPATH: "code.filepath",
      /**
       * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
       */
      CODE_LINENO: "code.lineno",
      /**
       * HTTP request method.
       */
      HTTP_METHOD: "http.method",
      /**
       * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
       *
       * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
       */
      HTTP_URL: "http.url",
      /**
       * The full request target as passed in a HTTP request line or equivalent.
       */
      HTTP_TARGET: "http.target",
      /**
       * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
       *
       * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
       */
      HTTP_HOST: "http.host",
      /**
       * The URI scheme identifying the used protocol.
       */
      HTTP_SCHEME: "http.scheme",
      /**
       * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
       */
      HTTP_STATUS_CODE: "http.status_code",
      /**
       * Kind of HTTP protocol used.
       *
       * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
       */
      HTTP_FLAVOR: "http.flavor",
      /**
       * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
       */
      HTTP_USER_AGENT: "http.user_agent",
      /**
       * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_REQUEST_CONTENT_LENGTH: "http.request_content_length",
      /**
       * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
       */
      HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: "http.request_content_length_uncompressed",
      /**
       * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
       */
      HTTP_RESPONSE_CONTENT_LENGTH: "http.response_content_length",
      /**
       * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
       */
      HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: "http.response_content_length_uncompressed",
      /**
       * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
       *
       * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
       */
      HTTP_SERVER_NAME: "http.server_name",
      /**
       * The matched route (path template).
       */
      HTTP_ROUTE: "http.route",
      /**
        * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
        *
        * Note: This is not necessarily the same as `net.peer.ip`, which would
      identify the network-level peer, which may be a proxy.
      
      This attribute should be set when a source of information different
      from the one used for `net.peer.ip`, is available even if that other
      source just confirms the same value as `net.peer.ip`.
      Rationale: For `net.peer.ip`, one typically does not know if it
      comes from a proxy, reverse proxy, or the actual client. Setting
      `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
      one is at least somewhat confident that the address is not that of
      the closest proxy.
        */
      HTTP_CLIENT_IP: "http.client_ip",
      /**
       * The keys in the `RequestItems` object field.
       */
      AWS_DYNAMODB_TABLE_NAMES: "aws.dynamodb.table_names",
      /**
       * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
       */
      AWS_DYNAMODB_CONSUMED_CAPACITY: "aws.dynamodb.consumed_capacity",
      /**
       * The JSON-serialized value of the `ItemCollectionMetrics` response field.
       */
      AWS_DYNAMODB_ITEM_COLLECTION_METRICS: "aws.dynamodb.item_collection_metrics",
      /**
       * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
       */
      AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: "aws.dynamodb.provisioned_read_capacity",
      /**
       * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
       */
      AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: "aws.dynamodb.provisioned_write_capacity",
      /**
       * The value of the `ConsistentRead` request parameter.
       */
      AWS_DYNAMODB_CONSISTENT_READ: "aws.dynamodb.consistent_read",
      /**
       * The value of the `ProjectionExpression` request parameter.
       */
      AWS_DYNAMODB_PROJECTION: "aws.dynamodb.projection",
      /**
       * The value of the `Limit` request parameter.
       */
      AWS_DYNAMODB_LIMIT: "aws.dynamodb.limit",
      /**
       * The value of the `AttributesToGet` request parameter.
       */
      AWS_DYNAMODB_ATTRIBUTES_TO_GET: "aws.dynamodb.attributes_to_get",
      /**
       * The value of the `IndexName` request parameter.
       */
      AWS_DYNAMODB_INDEX_NAME: "aws.dynamodb.index_name",
      /**
       * The value of the `Select` request parameter.
       */
      AWS_DYNAMODB_SELECT: "aws.dynamodb.select",
      /**
       * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
       */
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: "aws.dynamodb.global_secondary_indexes",
      /**
       * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
       */
      AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: "aws.dynamodb.local_secondary_indexes",
      /**
       * The value of the `ExclusiveStartTableName` request parameter.
       */
      AWS_DYNAMODB_EXCLUSIVE_START_TABLE: "aws.dynamodb.exclusive_start_table",
      /**
       * The the number of items in the `TableNames` response parameter.
       */
      AWS_DYNAMODB_TABLE_COUNT: "aws.dynamodb.table_count",
      /**
       * The value of the `ScanIndexForward` request parameter.
       */
      AWS_DYNAMODB_SCAN_FORWARD: "aws.dynamodb.scan_forward",
      /**
       * The value of the `Segment` request parameter.
       */
      AWS_DYNAMODB_SEGMENT: "aws.dynamodb.segment",
      /**
       * The value of the `TotalSegments` request parameter.
       */
      AWS_DYNAMODB_TOTAL_SEGMENTS: "aws.dynamodb.total_segments",
      /**
       * The value of the `Count` response parameter.
       */
      AWS_DYNAMODB_COUNT: "aws.dynamodb.count",
      /**
       * The value of the `ScannedCount` response parameter.
       */
      AWS_DYNAMODB_SCANNED_COUNT: "aws.dynamodb.scanned_count",
      /**
       * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
       */
      AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: "aws.dynamodb.attribute_definitions",
      /**
       * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
       */
      AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: "aws.dynamodb.global_secondary_index_updates",
      /**
       * A string identifying the messaging system.
       */
      MESSAGING_SYSTEM: "messaging.system",
      /**
       * The message destination name. This might be equal to the span name but is required nevertheless.
       */
      MESSAGING_DESTINATION: "messaging.destination",
      /**
       * The kind of message destination.
       */
      MESSAGING_DESTINATION_KIND: "messaging.destination_kind",
      /**
       * A boolean that is true if the message destination is temporary.
       */
      MESSAGING_TEMP_DESTINATION: "messaging.temp_destination",
      /**
       * The name of the transport protocol.
       */
      MESSAGING_PROTOCOL: "messaging.protocol",
      /**
       * The version of the transport protocol.
       */
      MESSAGING_PROTOCOL_VERSION: "messaging.protocol_version",
      /**
       * Connection string.
       */
      MESSAGING_URL: "messaging.url",
      /**
       * A value used by the messaging system as an identifier for the message, represented as a string.
       */
      MESSAGING_MESSAGE_ID: "messaging.message_id",
      /**
       * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
       */
      MESSAGING_CONVERSATION_ID: "messaging.conversation_id",
      /**
       * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
       */
      MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: "messaging.message_payload_size_bytes",
      /**
       * The compressed size of the message payload in bytes.
       */
      MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: "messaging.message_payload_compressed_size_bytes",
      /**
       * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
       */
      MESSAGING_OPERATION: "messaging.operation",
      /**
       * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
       */
      MESSAGING_CONSUMER_ID: "messaging.consumer_id",
      /**
       * RabbitMQ message routing key.
       */
      MESSAGING_RABBITMQ_ROUTING_KEY: "messaging.rabbitmq.routing_key",
      /**
       * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
       *
       * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
       */
      MESSAGING_KAFKA_MESSAGE_KEY: "messaging.kafka.message_key",
      /**
       * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
       */
      MESSAGING_KAFKA_CONSUMER_GROUP: "messaging.kafka.consumer_group",
      /**
       * Client Id for the Consumer or Producer that is handling the message.
       */
      MESSAGING_KAFKA_CLIENT_ID: "messaging.kafka.client_id",
      /**
       * Partition the message is sent to.
       */
      MESSAGING_KAFKA_PARTITION: "messaging.kafka.partition",
      /**
       * A boolean that is true if the message is a tombstone.
       */
      MESSAGING_KAFKA_TOMBSTONE: "messaging.kafka.tombstone",
      /**
       * A string identifying the remoting system.
       */
      RPC_SYSTEM: "rpc.system",
      /**
       * The full (logical) name of the service being called, including its package name, if applicable.
       *
       * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
       */
      RPC_SERVICE: "rpc.service",
      /**
       * The name of the (logical) method being called, must be equal to the $method part in the span name.
       *
       * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
       */
      RPC_METHOD: "rpc.method",
      /**
       * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
       */
      RPC_GRPC_STATUS_CODE: "rpc.grpc.status_code",
      /**
       * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
       */
      RPC_JSONRPC_VERSION: "rpc.jsonrpc.version",
      /**
       * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
       */
      RPC_JSONRPC_REQUEST_ID: "rpc.jsonrpc.request_id",
      /**
       * `error.code` property of response if it is an error response.
       */
      RPC_JSONRPC_ERROR_CODE: "rpc.jsonrpc.error_code",
      /**
       * `error.message` property of response if it is an error response.
       */
      RPC_JSONRPC_ERROR_MESSAGE: "rpc.jsonrpc.error_message",
      /**
       * Whether this is a received or sent message.
       */
      MESSAGE_TYPE: "message.type",
      /**
       * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
       *
       * Note: This way we guarantee that the values will be consistent between different implementations.
       */
      MESSAGE_ID: "message.id",
      /**
       * Compressed size of the message in bytes.
       */
      MESSAGE_COMPRESSED_SIZE: "message.compressed_size",
      /**
       * Uncompressed size of the message in bytes.
       */
      MESSAGE_UNCOMPRESSED_SIZE: "message.uncompressed_size"
    };
    exports2.DbSystemValues = {
      /** Some other SQL database. Fallback only. See notes. */
      OTHER_SQL: "other_sql",
      /** Microsoft SQL Server. */
      MSSQL: "mssql",
      /** MySQL. */
      MYSQL: "mysql",
      /** Oracle Database. */
      ORACLE: "oracle",
      /** IBM Db2. */
      DB2: "db2",
      /** PostgreSQL. */
      POSTGRESQL: "postgresql",
      /** Amazon Redshift. */
      REDSHIFT: "redshift",
      /** Apache Hive. */
      HIVE: "hive",
      /** Cloudscape. */
      CLOUDSCAPE: "cloudscape",
      /** HyperSQL DataBase. */
      HSQLDB: "hsqldb",
      /** Progress Database. */
      PROGRESS: "progress",
      /** SAP MaxDB. */
      MAXDB: "maxdb",
      /** SAP HANA. */
      HANADB: "hanadb",
      /** Ingres. */
      INGRES: "ingres",
      /** FirstSQL. */
      FIRSTSQL: "firstsql",
      /** EnterpriseDB. */
      EDB: "edb",
      /** InterSystems Caché. */
      CACHE: "cache",
      /** Adabas (Adaptable Database System). */
      ADABAS: "adabas",
      /** Firebird. */
      FIREBIRD: "firebird",
      /** Apache Derby. */
      DERBY: "derby",
      /** FileMaker. */
      FILEMAKER: "filemaker",
      /** Informix. */
      INFORMIX: "informix",
      /** InstantDB. */
      INSTANTDB: "instantdb",
      /** InterBase. */
      INTERBASE: "interbase",
      /** MariaDB. */
      MARIADB: "mariadb",
      /** Netezza. */
      NETEZZA: "netezza",
      /** Pervasive PSQL. */
      PERVASIVE: "pervasive",
      /** PointBase. */
      POINTBASE: "pointbase",
      /** SQLite. */
      SQLITE: "sqlite",
      /** Sybase. */
      SYBASE: "sybase",
      /** Teradata. */
      TERADATA: "teradata",
      /** Vertica. */
      VERTICA: "vertica",
      /** H2. */
      H2: "h2",
      /** ColdFusion IMQ. */
      COLDFUSION: "coldfusion",
      /** Apache Cassandra. */
      CASSANDRA: "cassandra",
      /** Apache HBase. */
      HBASE: "hbase",
      /** MongoDB. */
      MONGODB: "mongodb",
      /** Redis. */
      REDIS: "redis",
      /** Couchbase. */
      COUCHBASE: "couchbase",
      /** CouchDB. */
      COUCHDB: "couchdb",
      /** Microsoft Azure Cosmos DB. */
      COSMOSDB: "cosmosdb",
      /** Amazon DynamoDB. */
      DYNAMODB: "dynamodb",
      /** Neo4j. */
      NEO4J: "neo4j",
      /** Apache Geode. */
      GEODE: "geode",
      /** Elasticsearch. */
      ELASTICSEARCH: "elasticsearch",
      /** Memcached. */
      MEMCACHED: "memcached",
      /** CockroachDB. */
      COCKROACHDB: "cockroachdb"
    };
    exports2.DbCassandraConsistencyLevelValues = {
      /** all. */
      ALL: "all",
      /** each_quorum. */
      EACH_QUORUM: "each_quorum",
      /** quorum. */
      QUORUM: "quorum",
      /** local_quorum. */
      LOCAL_QUORUM: "local_quorum",
      /** one. */
      ONE: "one",
      /** two. */
      TWO: "two",
      /** three. */
      THREE: "three",
      /** local_one. */
      LOCAL_ONE: "local_one",
      /** any. */
      ANY: "any",
      /** serial. */
      SERIAL: "serial",
      /** local_serial. */
      LOCAL_SERIAL: "local_serial"
    };
    exports2.FaasTriggerValues = {
      /** A response to some data source operation such as a database or filesystem read/write. */
      DATASOURCE: "datasource",
      /** To provide an answer to an inbound HTTP request. */
      HTTP: "http",
      /** A function is set to be executed when messages are sent to a messaging system. */
      PUBSUB: "pubsub",
      /** A function is scheduled to be executed regularly. */
      TIMER: "timer",
      /** If none of the others apply. */
      OTHER: "other"
    };
    exports2.FaasDocumentOperationValues = {
      /** When a new object is created. */
      INSERT: "insert",
      /** When an object is modified. */
      EDIT: "edit",
      /** When an object is deleted. */
      DELETE: "delete"
    };
    exports2.FaasInvokedProviderValues = {
      /** Alibaba Cloud. */
      ALIBABA_CLOUD: "alibaba_cloud",
      /** Amazon Web Services. */
      AWS: "aws",
      /** Microsoft Azure. */
      AZURE: "azure",
      /** Google Cloud Platform. */
      GCP: "gcp"
    };
    exports2.NetTransportValues = {
      /** ip_tcp. */
      IP_TCP: "ip_tcp",
      /** ip_udp. */
      IP_UDP: "ip_udp",
      /** Another IP-based protocol. */
      IP: "ip",
      /** Unix Domain socket. See below. */
      UNIX: "unix",
      /** Named or anonymous pipe. See note below. */
      PIPE: "pipe",
      /** In-process communication. */
      INPROC: "inproc",
      /** Something else (non IP-based). */
      OTHER: "other"
    };
    exports2.NetHostConnectionTypeValues = {
      /** wifi. */
      WIFI: "wifi",
      /** wired. */
      WIRED: "wired",
      /** cell. */
      CELL: "cell",
      /** unavailable. */
      UNAVAILABLE: "unavailable",
      /** unknown. */
      UNKNOWN: "unknown"
    };
    exports2.NetHostConnectionSubtypeValues = {
      /** GPRS. */
      GPRS: "gprs",
      /** EDGE. */
      EDGE: "edge",
      /** UMTS. */
      UMTS: "umts",
      /** CDMA. */
      CDMA: "cdma",
      /** EVDO Rel. 0. */
      EVDO_0: "evdo_0",
      /** EVDO Rev. A. */
      EVDO_A: "evdo_a",
      /** CDMA2000 1XRTT. */
      CDMA2000_1XRTT: "cdma2000_1xrtt",
      /** HSDPA. */
      HSDPA: "hsdpa",
      /** HSUPA. */
      HSUPA: "hsupa",
      /** HSPA. */
      HSPA: "hspa",
      /** IDEN. */
      IDEN: "iden",
      /** EVDO Rev. B. */
      EVDO_B: "evdo_b",
      /** LTE. */
      LTE: "lte",
      /** EHRPD. */
      EHRPD: "ehrpd",
      /** HSPAP. */
      HSPAP: "hspap",
      /** GSM. */
      GSM: "gsm",
      /** TD-SCDMA. */
      TD_SCDMA: "td_scdma",
      /** IWLAN. */
      IWLAN: "iwlan",
      /** 5G NR (New Radio). */
      NR: "nr",
      /** 5G NRNSA (New Radio Non-Standalone). */
      NRNSA: "nrnsa",
      /** LTE CA. */
      LTE_CA: "lte_ca"
    };
    exports2.HttpFlavorValues = {
      /** HTTP 1.0. */
      HTTP_1_0: "1.0",
      /** HTTP 1.1. */
      HTTP_1_1: "1.1",
      /** HTTP 2. */
      HTTP_2_0: "2.0",
      /** SPDY protocol. */
      SPDY: "SPDY",
      /** QUIC protocol. */
      QUIC: "QUIC"
    };
    exports2.MessagingDestinationKindValues = {
      /** A message sent to a queue. */
      QUEUE: "queue",
      /** A message sent to a topic. */
      TOPIC: "topic"
    };
    exports2.MessagingOperationValues = {
      /** receive. */
      RECEIVE: "receive",
      /** process. */
      PROCESS: "process"
    };
    exports2.RpcGrpcStatusCodeValues = {
      /** OK. */
      OK: 0,
      /** CANCELLED. */
      CANCELLED: 1,
      /** UNKNOWN. */
      UNKNOWN: 2,
      /** INVALID_ARGUMENT. */
      INVALID_ARGUMENT: 3,
      /** DEADLINE_EXCEEDED. */
      DEADLINE_EXCEEDED: 4,
      /** NOT_FOUND. */
      NOT_FOUND: 5,
      /** ALREADY_EXISTS. */
      ALREADY_EXISTS: 6,
      /** PERMISSION_DENIED. */
      PERMISSION_DENIED: 7,
      /** RESOURCE_EXHAUSTED. */
      RESOURCE_EXHAUSTED: 8,
      /** FAILED_PRECONDITION. */
      FAILED_PRECONDITION: 9,
      /** ABORTED. */
      ABORTED: 10,
      /** OUT_OF_RANGE. */
      OUT_OF_RANGE: 11,
      /** UNIMPLEMENTED. */
      UNIMPLEMENTED: 12,
      /** INTERNAL. */
      INTERNAL: 13,
      /** UNAVAILABLE. */
      UNAVAILABLE: 14,
      /** DATA_LOSS. */
      DATA_LOSS: 15,
      /** UNAUTHENTICATED. */
      UNAUTHENTICATED: 16
    };
    exports2.MessageTypeValues = {
      /** sent. */
      SENT: "SENT",
      /** received. */
      RECEIVED: "RECEIVED"
    };
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes(), exports2);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetrySdkLanguageValues = exports2.OsTypeValues = exports2.HostArchValues = exports2.AwsEcsLaunchtypeValues = exports2.CloudPlatformValues = exports2.CloudProviderValues = exports2.SemanticResourceAttributes = void 0;
    exports2.SemanticResourceAttributes = {
      /**
       * Name of the cloud provider.
       */
      CLOUD_PROVIDER: "cloud.provider",
      /**
       * The cloud account ID the resource is assigned to.
       */
      CLOUD_ACCOUNT_ID: "cloud.account.id",
      /**
       * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
       */
      CLOUD_REGION: "cloud.region",
      /**
       * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
       *
       * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
       */
      CLOUD_AVAILABILITY_ZONE: "cloud.availability_zone",
      /**
       * The cloud platform in use.
       *
       * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
       */
      CLOUD_PLATFORM: "cloud.platform",
      /**
       * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
       */
      AWS_ECS_CONTAINER_ARN: "aws.ecs.container.arn",
      /**
       * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
       */
      AWS_ECS_CLUSTER_ARN: "aws.ecs.cluster.arn",
      /**
       * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
       */
      AWS_ECS_LAUNCHTYPE: "aws.ecs.launchtype",
      /**
       * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
       */
      AWS_ECS_TASK_ARN: "aws.ecs.task.arn",
      /**
       * The task definition family this task definition is a member of.
       */
      AWS_ECS_TASK_FAMILY: "aws.ecs.task.family",
      /**
       * The revision for this task definition.
       */
      AWS_ECS_TASK_REVISION: "aws.ecs.task.revision",
      /**
       * The ARN of an EKS cluster.
       */
      AWS_EKS_CLUSTER_ARN: "aws.eks.cluster.arn",
      /**
       * The name(s) of the AWS log group(s) an application is writing to.
       *
       * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
       */
      AWS_LOG_GROUP_NAMES: "aws.log.group.names",
      /**
       * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
       *
       * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
       */
      AWS_LOG_GROUP_ARNS: "aws.log.group.arns",
      /**
       * The name(s) of the AWS log stream(s) an application is writing to.
       */
      AWS_LOG_STREAM_NAMES: "aws.log.stream.names",
      /**
       * The ARN(s) of the AWS log stream(s).
       *
       * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
       */
      AWS_LOG_STREAM_ARNS: "aws.log.stream.arns",
      /**
       * Container name.
       */
      CONTAINER_NAME: "container.name",
      /**
       * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
       */
      CONTAINER_ID: "container.id",
      /**
       * The container runtime managing this container.
       */
      CONTAINER_RUNTIME: "container.runtime",
      /**
       * Name of the image the container was built on.
       */
      CONTAINER_IMAGE_NAME: "container.image.name",
      /**
       * Container image tag.
       */
      CONTAINER_IMAGE_TAG: "container.image.tag",
      /**
       * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
       */
      DEPLOYMENT_ENVIRONMENT: "deployment.environment",
      /**
       * A unique identifier representing the device.
       *
       * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
       */
      DEVICE_ID: "device.id",
      /**
       * The model identifier for the device.
       *
       * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
       */
      DEVICE_MODEL_IDENTIFIER: "device.model.identifier",
      /**
       * The marketing name for the device model.
       *
       * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
       */
      DEVICE_MODEL_NAME: "device.model.name",
      /**
       * The name of the single function that this runtime instance executes.
       *
       * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
       */
      FAAS_NAME: "faas.name",
      /**
        * The unique ID of the single function that this runtime instance executes.
        *
        * Note: Depending on the cloud provider, use:
      
      * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
      Take care not to use the &#34;invoked ARN&#34; directly but replace any
      [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
      different aliases.
      * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
      * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
      
      On some providers, it may not be possible to determine the full ID at startup,
      which is why this field cannot be made required. For example, on AWS the account ID
      part of the ARN is not available without calling another AWS API
      which may be deemed too slow for a short-running lambda function.
      As an alternative, consider setting `faas.id` as a span attribute instead.
        */
      FAAS_ID: "faas.id",
      /**
        * The immutable version of the function being executed.
        *
        * Note: Depending on the cloud provider and platform, use:
      
      * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
        (an integer represented as a decimal string).
      * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
        (i.e., the function name plus the revision suffix).
      * **Google Cloud Functions:** The value of the
        [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
      * **Azure Functions:** Not applicable. Do not set this attribute.
        */
      FAAS_VERSION: "faas.version",
      /**
       * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
       *
       * Note: * **AWS Lambda:** Use the (full) log stream name.
       */
      FAAS_INSTANCE: "faas.instance",
      /**
       * The amount of memory available to the serverless function in MiB.
       *
       * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
       */
      FAAS_MAX_MEMORY: "faas.max_memory",
      /**
       * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
       */
      HOST_ID: "host.id",
      /**
       * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
       */
      HOST_NAME: "host.name",
      /**
       * Type of host. For Cloud, this must be the machine type.
       */
      HOST_TYPE: "host.type",
      /**
       * The CPU architecture the host system is running on.
       */
      HOST_ARCH: "host.arch",
      /**
       * Name of the VM image or OS install the host was instantiated from.
       */
      HOST_IMAGE_NAME: "host.image.name",
      /**
       * VM image ID. For Cloud, this value is from the provider.
       */
      HOST_IMAGE_ID: "host.image.id",
      /**
       * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
       */
      HOST_IMAGE_VERSION: "host.image.version",
      /**
       * The name of the cluster.
       */
      K8S_CLUSTER_NAME: "k8s.cluster.name",
      /**
       * The name of the Node.
       */
      K8S_NODE_NAME: "k8s.node.name",
      /**
       * The UID of the Node.
       */
      K8S_NODE_UID: "k8s.node.uid",
      /**
       * The name of the namespace that the pod is running in.
       */
      K8S_NAMESPACE_NAME: "k8s.namespace.name",
      /**
       * The UID of the Pod.
       */
      K8S_POD_UID: "k8s.pod.uid",
      /**
       * The name of the Pod.
       */
      K8S_POD_NAME: "k8s.pod.name",
      /**
       * The name of the Container in a Pod template.
       */
      K8S_CONTAINER_NAME: "k8s.container.name",
      /**
       * The UID of the ReplicaSet.
       */
      K8S_REPLICASET_UID: "k8s.replicaset.uid",
      /**
       * The name of the ReplicaSet.
       */
      K8S_REPLICASET_NAME: "k8s.replicaset.name",
      /**
       * The UID of the Deployment.
       */
      K8S_DEPLOYMENT_UID: "k8s.deployment.uid",
      /**
       * The name of the Deployment.
       */
      K8S_DEPLOYMENT_NAME: "k8s.deployment.name",
      /**
       * The UID of the StatefulSet.
       */
      K8S_STATEFULSET_UID: "k8s.statefulset.uid",
      /**
       * The name of the StatefulSet.
       */
      K8S_STATEFULSET_NAME: "k8s.statefulset.name",
      /**
       * The UID of the DaemonSet.
       */
      K8S_DAEMONSET_UID: "k8s.daemonset.uid",
      /**
       * The name of the DaemonSet.
       */
      K8S_DAEMONSET_NAME: "k8s.daemonset.name",
      /**
       * The UID of the Job.
       */
      K8S_JOB_UID: "k8s.job.uid",
      /**
       * The name of the Job.
       */
      K8S_JOB_NAME: "k8s.job.name",
      /**
       * The UID of the CronJob.
       */
      K8S_CRONJOB_UID: "k8s.cronjob.uid",
      /**
       * The name of the CronJob.
       */
      K8S_CRONJOB_NAME: "k8s.cronjob.name",
      /**
       * The operating system type.
       */
      OS_TYPE: "os.type",
      /**
       * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
       */
      OS_DESCRIPTION: "os.description",
      /**
       * Human readable operating system name.
       */
      OS_NAME: "os.name",
      /**
       * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
       */
      OS_VERSION: "os.version",
      /**
       * Process identifier (PID).
       */
      PROCESS_PID: "process.pid",
      /**
       * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
       */
      PROCESS_EXECUTABLE_NAME: "process.executable.name",
      /**
       * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
       */
      PROCESS_EXECUTABLE_PATH: "process.executable.path",
      /**
       * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
       */
      PROCESS_COMMAND: "process.command",
      /**
       * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
       */
      PROCESS_COMMAND_LINE: "process.command_line",
      /**
       * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
       */
      PROCESS_COMMAND_ARGS: "process.command_args",
      /**
       * The username of the user that owns the process.
       */
      PROCESS_OWNER: "process.owner",
      /**
       * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
       */
      PROCESS_RUNTIME_NAME: "process.runtime.name",
      /**
       * The version of the runtime of this process, as returned by the runtime without modification.
       */
      PROCESS_RUNTIME_VERSION: "process.runtime.version",
      /**
       * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
       */
      PROCESS_RUNTIME_DESCRIPTION: "process.runtime.description",
      /**
       * Logical name of the service.
       *
       * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
       */
      SERVICE_NAME: "service.name",
      /**
       * A namespace for `service.name`.
       *
       * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
       */
      SERVICE_NAMESPACE: "service.namespace",
      /**
       * The string ID of the service instance.
       *
       * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
       */
      SERVICE_INSTANCE_ID: "service.instance.id",
      /**
       * The version string of the service API or implementation.
       */
      SERVICE_VERSION: "service.version",
      /**
       * The name of the telemetry SDK as defined above.
       */
      TELEMETRY_SDK_NAME: "telemetry.sdk.name",
      /**
       * The language of the telemetry SDK.
       */
      TELEMETRY_SDK_LANGUAGE: "telemetry.sdk.language",
      /**
       * The version string of the telemetry SDK.
       */
      TELEMETRY_SDK_VERSION: "telemetry.sdk.version",
      /**
       * The version string of the auto instrumentation agent, if used.
       */
      TELEMETRY_AUTO_VERSION: "telemetry.auto.version",
      /**
       * The name of the web engine.
       */
      WEBENGINE_NAME: "webengine.name",
      /**
       * The version of the web engine.
       */
      WEBENGINE_VERSION: "webengine.version",
      /**
       * Additional description of the web engine (e.g. detailed version and edition information).
       */
      WEBENGINE_DESCRIPTION: "webengine.description"
    };
    exports2.CloudProviderValues = {
      /** Alibaba Cloud. */
      ALIBABA_CLOUD: "alibaba_cloud",
      /** Amazon Web Services. */
      AWS: "aws",
      /** Microsoft Azure. */
      AZURE: "azure",
      /** Google Cloud Platform. */
      GCP: "gcp"
    };
    exports2.CloudPlatformValues = {
      /** Alibaba Cloud Elastic Compute Service. */
      ALIBABA_CLOUD_ECS: "alibaba_cloud_ecs",
      /** Alibaba Cloud Function Compute. */
      ALIBABA_CLOUD_FC: "alibaba_cloud_fc",
      /** AWS Elastic Compute Cloud. */
      AWS_EC2: "aws_ec2",
      /** AWS Elastic Container Service. */
      AWS_ECS: "aws_ecs",
      /** AWS Elastic Kubernetes Service. */
      AWS_EKS: "aws_eks",
      /** AWS Lambda. */
      AWS_LAMBDA: "aws_lambda",
      /** AWS Elastic Beanstalk. */
      AWS_ELASTIC_BEANSTALK: "aws_elastic_beanstalk",
      /** Azure Virtual Machines. */
      AZURE_VM: "azure_vm",
      /** Azure Container Instances. */
      AZURE_CONTAINER_INSTANCES: "azure_container_instances",
      /** Azure Kubernetes Service. */
      AZURE_AKS: "azure_aks",
      /** Azure Functions. */
      AZURE_FUNCTIONS: "azure_functions",
      /** Azure App Service. */
      AZURE_APP_SERVICE: "azure_app_service",
      /** Google Cloud Compute Engine (GCE). */
      GCP_COMPUTE_ENGINE: "gcp_compute_engine",
      /** Google Cloud Run. */
      GCP_CLOUD_RUN: "gcp_cloud_run",
      /** Google Cloud Kubernetes Engine (GKE). */
      GCP_KUBERNETES_ENGINE: "gcp_kubernetes_engine",
      /** Google Cloud Functions (GCF). */
      GCP_CLOUD_FUNCTIONS: "gcp_cloud_functions",
      /** Google Cloud App Engine (GAE). */
      GCP_APP_ENGINE: "gcp_app_engine"
    };
    exports2.AwsEcsLaunchtypeValues = {
      /** ec2. */
      EC2: "ec2",
      /** fargate. */
      FARGATE: "fargate"
    };
    exports2.HostArchValues = {
      /** AMD64. */
      AMD64: "amd64",
      /** ARM32. */
      ARM32: "arm32",
      /** ARM64. */
      ARM64: "arm64",
      /** Itanium. */
      IA64: "ia64",
      /** 32-bit PowerPC. */
      PPC32: "ppc32",
      /** 64-bit PowerPC. */
      PPC64: "ppc64",
      /** 32-bit x86. */
      X86: "x86"
    };
    exports2.OsTypeValues = {
      /** Microsoft Windows. */
      WINDOWS: "windows",
      /** Linux. */
      LINUX: "linux",
      /** Apple Darwin. */
      DARWIN: "darwin",
      /** FreeBSD. */
      FREEBSD: "freebsd",
      /** NetBSD. */
      NETBSD: "netbsd",
      /** OpenBSD. */
      OPENBSD: "openbsd",
      /** DragonFly BSD. */
      DRAGONFLYBSD: "dragonflybsd",
      /** HP-UX (Hewlett Packard Unix). */
      HPUX: "hpux",
      /** AIX (Advanced Interactive eXecutive). */
      AIX: "aix",
      /** Oracle Solaris. */
      SOLARIS: "solaris",
      /** IBM z/OS. */
      Z_OS: "z_os"
    };
    exports2.TelemetrySdkLanguageValues = {
      /** cpp. */
      CPP: "cpp",
      /** dotnet. */
      DOTNET: "dotnet",
      /** erlang. */
      ERLANG: "erlang",
      /** go. */
      GO: "go",
      /** java. */
      JAVA: "java",
      /** nodejs. */
      NODEJS: "nodejs",
      /** php. */
      PHP: "php",
      /** python. */
      PYTHON: "python",
      /** ruby. */
      RUBY: "ruby",
      /** webjs. */
      WEBJS: "webjs"
    };
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes(), exports2);
  }
});

// node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_trace2(), exports2);
    __exportStar(require_resource(), exports2);
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDK_INFO = void 0;
    var version_1 = require_version2();
    var semantic_conventions_1 = require_src2();
    exports2.SDK_INFO = {
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TelemetrySdkLanguageValues.NODEJS,
      [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports2.unrefTimer = unrefTimer;
  }
});

// node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_environment2(), exports2);
    __exportStar(require_globalThis3(), exports2);
    __exportStar(require_hex_to_base64(), exports2);
    __exportStar(require_RandomIdGenerator(), exports2);
    __exportStar(require_performance(), exports2);
    __exportStar(require_sdk_info(), exports2);
    __exportStar(require_timer_util(), exports2);
  }
});

// node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/platform/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node2(), exports2);
  }
});

// node_modules/@opentelemetry/core/build/src/common/time.js
var require_time2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addHrTimes = exports2.isTimeInput = exports2.isTimeInputHrTime = exports2.hrTimeToMicroseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToNanoseconds = exports2.hrTimeToTimeStamp = exports2.hrTimeDuration = exports2.timeInputToHrTime = exports2.hrTime = exports2.getTimeOrigin = exports2.millisToHrTime = void 0;
    var platform_1 = require_platform2();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports2.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports2.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports2.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports2.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports2.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substr(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports2.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports2.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports2.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports2.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports2.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports2.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports2.addHrTimes = addHrTimes;
  }
});

// node_modules/@opentelemetry/core/build/src/common/types.js
var require_types2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/common/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports2.ExportResultCode || (exports2.ExportResultCode = {}));
  }
});

// node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompositePropagator = void 0;
    var api_1 = require_src();
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports2.CompositePropagator = CompositePropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
    var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
    var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    exports2.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    exports2.validateValue = validateValue;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceState = void 0;
    var validators_1 = require_validators();
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceState = TraceState;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CTraceContextPropagator = exports2.parseTraceParent = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = void 0;
    var api_1 = require_src();
    var suppress_tracing_1 = require_suppress_tracing();
    var TraceState_1 = require_TraceState();
    exports2.TRACE_PARENT_HEADER = "traceparent";
    exports2.TRACE_STATE_HEADER = "tracestate";
    var VERSION = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports2.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports2.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports2.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports2.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports2.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context, spanContext);
      }
      fields() {
        return [exports2.TRACE_PARENT_HEADER, exports2.TRACE_STATE_HEADER];
      }
    };
    exports2.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js
var require_IdGenerator = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/IdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.setRPCMetadata = exports2.RPCType = void 0;
    var api_1 = require_src();
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports2.RPCType || (exports2.RPCType = {}));
    function setRPCMetadata(context, meta) {
      return context.setValue(RPC_METADATA_KEY, meta);
    }
    exports2.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context) {
      return context.deleteValue(RPC_METADATA_KEY);
    }
    exports2.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context) {
      return context.getValue(RPC_METADATA_KEY);
    }
    exports2.getRPCMetadata = getRPCMetadata;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOffSampler = void 0;
    var api_1 = require_src();
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOnSampler = void 0;
    var api_1 = require_src();
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParentBasedSampler = void 0;
    var api_1 = require_src();
    var global_error_handler_1 = require_global_error_handler();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = require_src();
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          const pos = i * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports2.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      const result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lodash_merge_1 = require_lodash_merge();
    var MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    exports2.merge = merge;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (let i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              const obj1 = result[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        const info = arr[i];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callWithTimeout = exports2.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url2 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUrlIgnored = exports2.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports2.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports2.isUrlIgnored = isUrlIgnored;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWrapped = void 0;
    function isWrapped(func) {
      return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
    }
    exports2.isWrapped = isWrapped;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports2.Deferred = Deferred;
  }
});

// node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BindOnceFuture = void 0;
    var promise_1 = require_promise();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports2.BindOnceFuture = BindOnceFuture;
  }
});

// node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._export = void 0;
    var api_1 = require_src();
    var suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    exports2._export = _export;
  }
});

// node_modules/@opentelemetry/core/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@opentelemetry/core/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.internal = exports2.baggageUtils = void 0;
    __exportStar(require_W3CBaggagePropagator(), exports2);
    __exportStar(require_anchored_clock(), exports2);
    __exportStar(require_attributes(), exports2);
    __exportStar(require_global_error_handler(), exports2);
    __exportStar(require_logging_error_handler(), exports2);
    __exportStar(require_time2(), exports2);
    __exportStar(require_types2(), exports2);
    __exportStar(require_ExportResult(), exports2);
    __exportStar(require_version2(), exports2);
    exports2.baggageUtils = require_utils3();
    __exportStar(require_platform2(), exports2);
    __exportStar(require_composite(), exports2);
    __exportStar(require_W3CTraceContextPropagator(), exports2);
    __exportStar(require_IdGenerator(), exports2);
    __exportStar(require_rpc_metadata(), exports2);
    __exportStar(require_AlwaysOffSampler(), exports2);
    __exportStar(require_AlwaysOnSampler(), exports2);
    __exportStar(require_ParentBasedSampler(), exports2);
    __exportStar(require_TraceIdRatioBasedSampler(), exports2);
    __exportStar(require_suppress_tracing(), exports2);
    __exportStar(require_TraceState(), exports2);
    __exportStar(require_environment(), exports2);
    __exportStar(require_merge(), exports2);
    __exportStar(require_sampling(), exports2);
    __exportStar(require_timeout(), exports2);
    __exportStar(require_url2(), exports2);
    __exportStar(require_wrap(), exports2);
    __exportStar(require_callback(), exports2);
    __exportStar(require_version2(), exports2);
    var exporter_1 = require_exporter();
    exports2.internal = {
      _export: exporter_1._export
    };
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js
var require_enums = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/enums.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExceptionEventName = void 0;
    exports2.ExceptionEventName = "exception";
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js
var require_Span = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Span.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Span = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var semantic_conventions_1 = require_src2();
    var enums_1 = require_enums();
    var Span = class {
      /**
       * Constructs a new Span instance.
       *
       * @deprecated calling Span constructor directly is not supported. Please use tracer.startSpan.
       * */
      constructor(parentTracer, context, spanName, spanContext, kind, parentSpanId, links = [], startTime, _deprecatedClock) {
        this.attributes = {};
        this.links = [];
        this.events = [];
        this._droppedAttributesCount = 0;
        this._droppedEventsCount = 0;
        this._droppedLinksCount = 0;
        this.status = {
          code: api_1.SpanStatusCode.UNSET
        };
        this.endTime = [0, 0];
        this._ended = false;
        this._duration = [-1, -1];
        this.name = spanName;
        this._spanContext = spanContext;
        this.parentSpanId = parentSpanId;
        this.kind = kind;
        this.links = links;
        const now = Date.now();
        this._performanceStartTime = core_1.otperformance.now();
        this._performanceOffset = now - (this._performanceStartTime + (0, core_1.getTimeOrigin)());
        this._startTimeProvided = startTime != null;
        this.startTime = this._getTime(startTime !== null && startTime !== void 0 ? startTime : now);
        this.resource = parentTracer.resource;
        this.instrumentationLibrary = parentTracer.instrumentationLibrary;
        this._spanLimits = parentTracer.getSpanLimits();
        this._spanProcessor = parentTracer.getActiveSpanProcessor();
        this._spanProcessor.onStart(this, context);
        this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;
      }
      spanContext() {
        return this._spanContext;
      }
      setAttribute(key, value) {
        if (value == null || this._isSpanEnded())
          return this;
        if (key.length === 0) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          return this;
        }
        if (!(0, core_1.isAttributeValue)(value)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          return this;
        }
        if (Object.keys(this.attributes).length >= this._spanLimits.attributeCountLimit && !Object.prototype.hasOwnProperty.call(this.attributes, key)) {
          this._droppedAttributesCount++;
          return this;
        }
        this.attributes[key] = this._truncateToSize(value);
        return this;
      }
      setAttributes(attributes) {
        for (const [k, v] of Object.entries(attributes)) {
          this.setAttribute(k, v);
        }
        return this;
      }
      /**
       *
       * @param name Span Name
       * @param [attributesOrStartTime] Span attributes or start time
       *     if type is {@type TimeInput} and 3rd param is undefined
       * @param [timeStamp] Specified time stamp for the event
       */
      addEvent(name2, attributesOrStartTime, timeStamp) {
        if (this._isSpanEnded())
          return this;
        if (this._spanLimits.eventCountLimit === 0) {
          api_1.diag.warn("No events allowed.");
          this._droppedEventsCount++;
          return this;
        }
        if (this.events.length >= this._spanLimits.eventCountLimit) {
          api_1.diag.warn("Dropping extra events.");
          this.events.shift();
          this._droppedEventsCount++;
        }
        if ((0, core_1.isTimeInput)(attributesOrStartTime)) {
          if (!(0, core_1.isTimeInput)(timeStamp)) {
            timeStamp = attributesOrStartTime;
          }
          attributesOrStartTime = void 0;
        }
        const attributes = (0, core_1.sanitizeAttributes)(attributesOrStartTime);
        this.events.push({
          name: name2,
          attributes,
          time: this._getTime(timeStamp),
          droppedAttributesCount: 0
        });
        return this;
      }
      setStatus(status) {
        if (this._isSpanEnded())
          return this;
        this.status = status;
        return this;
      }
      updateName(name2) {
        if (this._isSpanEnded())
          return this;
        this.name = name2;
        return this;
      }
      end(endTime) {
        if (this._isSpanEnded()) {
          api_1.diag.error(`${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`);
          return;
        }
        this._ended = true;
        this.endTime = this._getTime(endTime);
        this._duration = (0, core_1.hrTimeDuration)(this.startTime, this.endTime);
        if (this._duration[0] < 0) {
          api_1.diag.warn("Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.", this.startTime, this.endTime);
          this.endTime = this.startTime.slice();
          this._duration = [0, 0];
        }
        this._spanProcessor.onEnd(this);
      }
      _getTime(inp) {
        if (typeof inp === "number" && inp < core_1.otperformance.now()) {
          return (0, core_1.hrTime)(inp + this._performanceOffset);
        }
        if (typeof inp === "number") {
          return (0, core_1.millisToHrTime)(inp);
        }
        if (inp instanceof Date) {
          return (0, core_1.millisToHrTime)(inp.getTime());
        }
        if ((0, core_1.isTimeInputHrTime)(inp)) {
          return inp;
        }
        if (this._startTimeProvided) {
          return (0, core_1.millisToHrTime)(Date.now());
        }
        const msDuration = core_1.otperformance.now() - this._performanceStartTime;
        return (0, core_1.addHrTimes)(this.startTime, (0, core_1.millisToHrTime)(msDuration));
      }
      isRecording() {
        return this._ended === false;
      }
      recordException(exception, time) {
        const attributes = {};
        if (typeof exception === "string") {
          attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE] = exception;
        } else if (exception) {
          if (exception.code) {
            attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_TYPE] = exception.code.toString();
          } else if (exception.name) {
            attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_TYPE] = exception.name;
          }
          if (exception.message) {
            attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;
          }
          if (exception.stack) {
            attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;
          }
        }
        if (attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_TYPE] || attributes[semantic_conventions_1.SemanticAttributes.EXCEPTION_MESSAGE]) {
          this.addEvent(enums_1.ExceptionEventName, attributes, time);
        } else {
          api_1.diag.warn(`Failed to record an exception ${exception}`);
        }
      }
      get duration() {
        return this._duration;
      }
      get ended() {
        return this._ended;
      }
      get droppedAttributesCount() {
        return this._droppedAttributesCount;
      }
      get droppedEventsCount() {
        return this._droppedEventsCount;
      }
      get droppedLinksCount() {
        return this._droppedLinksCount;
      }
      _isSpanEnded() {
        if (this._ended) {
          api_1.diag.warn(`Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);
        }
        return this._ended;
      }
      // Utility function to truncate given value within size
      // for value type of string, will truncate to given limit
      // for type of non-string, will return same value
      _truncateToLimitUtil(value, limit) {
        if (value.length <= limit) {
          return value;
        }
        return value.substr(0, limit);
      }
      /**
       * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then
       * return string with trucated to {@code attributeValueLengthLimit} characters
       *
       * If the given attribute value is array of strings then
       * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters
       *
       * Otherwise return same Attribute {@code value}
       *
       * @param value Attribute value
       * @returns truncated attribute value if required, otherwise same value
       */
      _truncateToSize(value) {
        const limit = this._attributeValueLengthLimit;
        if (limit <= 0) {
          api_1.diag.warn(`Attribute value limit must be positive, got ${limit}`);
          return value;
        }
        if (typeof value === "string") {
          return this._truncateToLimitUtil(value, limit);
        }
        if (Array.isArray(value)) {
          return value.map((val) => typeof val === "string" ? this._truncateToLimitUtil(val, limit) : val);
        }
        return value;
      }
    };
    exports2.Span = Span;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js
var require_Sampler = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Sampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports2.SamplingDecision || (exports2.SamplingDecision = {}));
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOffSampler = void 0;
    var Sampler_1 = require_Sampler();
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOnSampler = void 0;
    var Sampler_1 = require_Sampler();
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: Sampler_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js
var require_ParentBasedSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParentBasedSampler = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          (0, core_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = require_src();
    var Sampler_1 = require_Sampler();
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? Sampler_1.SamplingDecision.RECORD_AND_SAMPLED : Sampler_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          const pos = i * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/config.js
var require_config2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSamplerFromEnv = exports2.loadDefaultConfig = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler2();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler2();
    var ParentBasedSampler_1 = require_ParentBasedSampler2();
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler2();
    var env2 = (0, core_1.getEnv)();
    var FALLBACK_OTEL_TRACES_SAMPLER = core_1.TracesSamplerValues.AlwaysOn;
    var DEFAULT_RATIO = 1;
    function loadDefaultConfig() {
      return {
        sampler: buildSamplerFromEnv(env2),
        forceFlushTimeoutMillis: 3e4,
        generalLimits: {
          attributeValueLengthLimit: (0, core_1.getEnv)().OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: (0, core_1.getEnv)().OTEL_ATTRIBUTE_COUNT_LIMIT
        },
        spanLimits: {
          attributeValueLengthLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT,
          attributeCountLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT,
          linkCountLimit: (0, core_1.getEnv)().OTEL_SPAN_LINK_COUNT_LIMIT,
          eventCountLimit: (0, core_1.getEnv)().OTEL_SPAN_EVENT_COUNT_LIMIT,
          attributePerEventCountLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
          attributePerLinkCountLimit: (0, core_1.getEnv)().OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT
        }
      };
    }
    exports2.loadDefaultConfig = loadDefaultConfig;
    function buildSamplerFromEnv(environment = (0, core_1.getEnv)()) {
      switch (environment.OTEL_TRACES_SAMPLER) {
        case core_1.TracesSamplerValues.AlwaysOn:
          return new AlwaysOnSampler_1.AlwaysOnSampler();
        case core_1.TracesSamplerValues.AlwaysOff:
          return new AlwaysOffSampler_1.AlwaysOffSampler();
        case core_1.TracesSamplerValues.ParentBasedAlwaysOn:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new AlwaysOnSampler_1.AlwaysOnSampler()
          });
        case core_1.TracesSamplerValues.ParentBasedAlwaysOff:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new AlwaysOffSampler_1.AlwaysOffSampler()
          });
        case core_1.TracesSamplerValues.TraceIdRatio:
          return new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment));
        case core_1.TracesSamplerValues.ParentBasedTraceIdRatio:
          return new ParentBasedSampler_1.ParentBasedSampler({
            root: new TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler(getSamplerProbabilityFromEnv(environment))
          });
        default:
          api_1.diag.error(`OTEL_TRACES_SAMPLER value "${environment.OTEL_TRACES_SAMPLER} invalid, defaulting to ${FALLBACK_OTEL_TRACES_SAMPLER}".`);
          return new AlwaysOnSampler_1.AlwaysOnSampler();
      }
    }
    exports2.buildSamplerFromEnv = buildSamplerFromEnv;
    function getSamplerProbabilityFromEnv(environment) {
      if (environment.OTEL_TRACES_SAMPLER_ARG === void 0 || environment.OTEL_TRACES_SAMPLER_ARG === "") {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG is blank, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      const probability = Number(environment.OTEL_TRACES_SAMPLER_ARG);
      if (isNaN(probability)) {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is invalid, defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      if (probability < 0 || probability > 1) {
        api_1.diag.error(`OTEL_TRACES_SAMPLER_ARG=${environment.OTEL_TRACES_SAMPLER_ARG} was given, but it is out of range ([0..1]), defaulting to ${DEFAULT_RATIO}.`);
        return DEFAULT_RATIO;
      }
      return probability;
    }
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js
var require_utility = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/utility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reconfigureLimits = exports2.mergeConfig = void 0;
    var config_1 = require_config2();
    var core_1 = require_src3();
    function mergeConfig(userConfig) {
      const perInstanceDefaults = {
        sampler: (0, config_1.buildSamplerFromEnv)()
      };
      const DEFAULT_CONFIG = (0, config_1.loadDefaultConfig)();
      const target = Object.assign({}, DEFAULT_CONFIG, perInstanceDefaults, userConfig);
      target.generalLimits = Object.assign({}, DEFAULT_CONFIG.generalLimits, userConfig.generalLimits || {});
      target.spanLimits = Object.assign({}, DEFAULT_CONFIG.spanLimits, userConfig.spanLimits || {});
      return target;
    }
    exports2.mergeConfig = mergeConfig;
    function reconfigureLimits(userConfig) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      const spanLimits = Object.assign({}, userConfig.spanLimits);
      const parsedEnvConfig = (0, core_1.getEnvWithoutDefaults)();
      spanLimits.attributeCountLimit = (_f = (_e = (_d = (_b = (_a = userConfig.spanLimits) === null || _a === void 0 ? void 0 : _a.attributeCountLimit) !== null && _b !== void 0 ? _b : (_c = userConfig.generalLimits) === null || _c === void 0 ? void 0 : _c.attributeCountLimit) !== null && _d !== void 0 ? _d : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT) !== null && _e !== void 0 ? _e : parsedEnvConfig.OTEL_ATTRIBUTE_COUNT_LIMIT) !== null && _f !== void 0 ? _f : core_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
      spanLimits.attributeValueLengthLimit = (_m = (_l = (_k = (_h = (_g = userConfig.spanLimits) === null || _g === void 0 ? void 0 : _g.attributeValueLengthLimit) !== null && _h !== void 0 ? _h : (_j = userConfig.generalLimits) === null || _j === void 0 ? void 0 : _j.attributeValueLengthLimit) !== null && _k !== void 0 ? _k : parsedEnvConfig.OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _l !== void 0 ? _l : parsedEnvConfig.OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT) !== null && _m !== void 0 ? _m : core_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
      return Object.assign({}, userConfig, { spanLimits });
    }
    exports2.reconfigureLimits = reconfigureLimits;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js
var require_BatchSpanProcessorBase = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/BatchSpanProcessorBase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BatchSpanProcessorBase = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var BatchSpanProcessorBase = class {
      constructor(_exporter, config) {
        this._exporter = _exporter;
        this._finishedSpans = [];
        this._droppedSpansCount = 0;
        const env2 = (0, core_1.getEnv)();
        this._maxExportBatchSize = typeof (config === null || config === void 0 ? void 0 : config.maxExportBatchSize) === "number" ? config.maxExportBatchSize : env2.OTEL_BSP_MAX_EXPORT_BATCH_SIZE;
        this._maxQueueSize = typeof (config === null || config === void 0 ? void 0 : config.maxQueueSize) === "number" ? config.maxQueueSize : env2.OTEL_BSP_MAX_QUEUE_SIZE;
        this._scheduledDelayMillis = typeof (config === null || config === void 0 ? void 0 : config.scheduledDelayMillis) === "number" ? config.scheduledDelayMillis : env2.OTEL_BSP_SCHEDULE_DELAY;
        this._exportTimeoutMillis = typeof (config === null || config === void 0 ? void 0 : config.exportTimeoutMillis) === "number" ? config.exportTimeoutMillis : env2.OTEL_BSP_EXPORT_TIMEOUT;
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        if (this._maxExportBatchSize > this._maxQueueSize) {
          api_1.diag.warn("BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize");
          this._maxExportBatchSize = this._maxQueueSize;
        }
      }
      forceFlush() {
        if (this._shutdownOnce.isCalled) {
          return this._shutdownOnce.promise;
        }
        return this._flushAll();
      }
      // does nothing.
      onStart(_span, _parentContext) {
      }
      onEnd(span) {
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
          return;
        }
        this._addToBuffer(span);
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return Promise.resolve().then(() => {
          return this.onShutdown();
        }).then(() => {
          return this._flushAll();
        }).then(() => {
          return this._exporter.shutdown();
        });
      }
      /** Add a span in the buffer. */
      _addToBuffer(span) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          if (this._droppedSpansCount === 0) {
            api_1.diag.debug("maxQueueSize reached, dropping spans");
          }
          this._droppedSpansCount++;
          return;
        }
        if (this._droppedSpansCount > 0) {
          api_1.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`);
          this._droppedSpansCount = 0;
        }
        this._finishedSpans.push(span);
        this._maybeStartTimer();
      }
      /**
       * Send all spans to the exporter respecting the batch size limit
       * This function is used only on forceFlush or shutdown,
       * for all other cases _flush should be used
       * */
      _flushAll() {
        return new Promise((resolve, reject) => {
          const promises = [];
          const count = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
          for (let i = 0, j = count; i < j; i++) {
            promises.push(this._flushOneBatch());
          }
          Promise.all(promises).then(() => {
            resolve();
          }).catch(reject);
        });
      }
      _flushOneBatch() {
        this._clearTimer();
        if (this._finishedSpans.length === 0) {
          return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            reject(new Error("Timeout"));
          }, this._exportTimeoutMillis);
          api_1.context.with((0, core_1.suppressTracing)(api_1.context.active()), () => {
            const spans = this._finishedSpans.splice(0, this._maxExportBatchSize);
            const doExport = () => this._exporter.export(spans, (result) => {
              var _a;
              clearTimeout(timer);
              if (result.code === core_1.ExportResultCode.SUCCESS) {
                resolve();
              } else {
                reject((_a = result.error) !== null && _a !== void 0 ? _a : new Error("BatchSpanProcessor: span export failed"));
              }
            });
            const pendingResources = spans.map((span) => span.resource).filter((resource) => resource.asyncAttributesPending);
            if (pendingResources.length === 0) {
              doExport();
            } else {
              Promise.all(pendingResources.map((resource) => {
                var _a;
                return (_a = resource.waitForAsyncAttributes) === null || _a === void 0 ? void 0 : _a.call(resource);
              })).then(doExport, (err) => {
                (0, core_1.globalErrorHandler)(err);
                reject(err);
              });
            }
          });
        });
      }
      _maybeStartTimer() {
        if (this._timer !== void 0)
          return;
        this._timer = setTimeout(() => {
          this._flushOneBatch().then(() => {
            if (this._finishedSpans.length > 0) {
              this._clearTimer();
              this._maybeStartTimer();
            }
          }).catch((e) => {
            (0, core_1.globalErrorHandler)(e);
          });
        }, this._scheduledDelayMillis);
        (0, core_1.unrefTimer)(this._timer);
      }
      _clearTimer() {
        if (this._timer !== void 0) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
      }
    };
    exports2.BatchSpanProcessorBase = BatchSpanProcessorBase;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js
var require_BatchSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/export/BatchSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BatchSpanProcessor = void 0;
    var BatchSpanProcessorBase_1 = require_BatchSpanProcessorBase();
    var BatchSpanProcessor = class extends BatchSpanProcessorBase_1.BatchSpanProcessorBase {
      onShutdown() {
      }
    };
    exports2.BatchSpanProcessor = BatchSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        }
        for (let i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js
var require_node3 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/node/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_BatchSpanProcessor(), exports2);
    __exportStar(require_RandomIdGenerator2(), exports2);
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js
var require_platform3 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/platform/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node3(), exports2);
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js
var require_Tracer = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/Tracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Tracer = void 0;
    var api = require_src();
    var core_1 = require_src3();
    var Span_1 = require_Span();
    var utility_1 = require_utility();
    var platform_1 = require_platform3();
    var Tracer = class {
      /**
       * Constructs a new Tracer instance.
       */
      constructor(instrumentationLibrary, config, _tracerProvider) {
        this._tracerProvider = _tracerProvider;
        const localConfig = (0, utility_1.mergeConfig)(config);
        this._sampler = localConfig.sampler;
        this._generalLimits = localConfig.generalLimits;
        this._spanLimits = localConfig.spanLimits;
        this._idGenerator = config.idGenerator || new platform_1.RandomIdGenerator();
        this.resource = _tracerProvider.resource;
        this.instrumentationLibrary = instrumentationLibrary;
      }
      /**
       * Starts a new Span or returns the default NoopSpan based on the sampling
       * decision.
       */
      startSpan(name2, options = {}, context = api.context.active()) {
        var _a, _b, _c;
        if (options.root) {
          context = api.trace.deleteSpan(context);
        }
        const parentSpan = api.trace.getSpan(context);
        if ((0, core_1.isTracingSuppressed)(context)) {
          api.diag.debug("Instrumentation suppressed, returning Noop Span");
          const nonRecordingSpan = api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);
          return nonRecordingSpan;
        }
        const parentSpanContext = parentSpan === null || parentSpan === void 0 ? void 0 : parentSpan.spanContext();
        const spanId = this._idGenerator.generateSpanId();
        let traceId;
        let traceState;
        let parentSpanId;
        if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {
          traceId = this._idGenerator.generateTraceId();
        } else {
          traceId = parentSpanContext.traceId;
          traceState = parentSpanContext.traceState;
          parentSpanId = parentSpanContext.spanId;
        }
        const spanKind = (_a = options.kind) !== null && _a !== void 0 ? _a : api.SpanKind.INTERNAL;
        const links = ((_b = options.links) !== null && _b !== void 0 ? _b : []).map((link) => {
          return {
            context: link.context,
            attributes: (0, core_1.sanitizeAttributes)(link.attributes)
          };
        });
        const attributes = (0, core_1.sanitizeAttributes)(options.attributes);
        const samplingResult = this._sampler.shouldSample(context, traceId, name2, spanKind, attributes, links);
        traceState = (_c = samplingResult.traceState) !== null && _c !== void 0 ? _c : traceState;
        const traceFlags = samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE;
        const spanContext = { traceId, spanId, traceFlags, traceState };
        if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {
          api.diag.debug("Recording is off, propagating context in a non-recording span");
          const nonRecordingSpan = api.trace.wrapSpanContext(spanContext);
          return nonRecordingSpan;
        }
        const span = new Span_1.Span(this, context, name2, spanContext, spanKind, parentSpanId, links, options.startTime);
        const initAttributes = (0, core_1.sanitizeAttributes)(Object.assign(attributes, samplingResult.attributes));
        span.setAttributes(initAttributes);
        return span;
      }
      startActiveSpan(name2, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : api.context.active();
        const span = this.startSpan(name2, opts, parentContext);
        const contextWithSpanSet = api.trace.setSpan(parentContext, span);
        return api.context.with(contextWithSpanSet, fn, void 0, span);
      }
      /** Returns the active {@link GeneralLimits}. */
      getGeneralLimits() {
        return this._generalLimits;
      }
      /** Returns the active {@link SpanLimits}. */
      getSpanLimits() {
        return this._spanLimits;
      }
      getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
      }
    };
    exports2.Tracer = Tracer;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js
var require_default_service_name = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/default-service-name.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultServiceName = void 0;
    function defaultServiceName() {
      return `unknown_service:${process.argv0}`;
    }
    exports2.defaultServiceName = defaultServiceName;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/utils.js
var require_utils4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.normalizeType = exports2.normalizeArch = void 0;
    var normalizeArch = (nodeArchString) => {
      switch (nodeArchString) {
        case "arm":
          return "arm32";
        case "ppc":
          return "ppc32";
        case "x64":
          return "amd64";
        default:
          return nodeArchString;
      }
    };
    exports2.normalizeArch = normalizeArch;
    var normalizeType = (nodePlatform) => {
      switch (nodePlatform) {
        case "sunos":
          return "solaris";
        case "win32":
          return "windows";
        default:
          return nodePlatform;
      }
    };
    exports2.normalizeType = normalizeType;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/execAsync.js
var require_execAsync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/execAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.execAsync = void 0;
    var child_process = require("child_process");
    var util = require("util");
    exports2.execAsync = util.promisify(child_process.exec);
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-darwin.js
var require_getMachineId_darwin = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-darwin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var execAsync_1 = require_execAsync();
    var api_1 = require_src();
    async function getMachineId() {
      try {
        const result = await (0, execAsync_1.execAsync)('ioreg -rd1 -c "IOPlatformExpertDevice"');
        const idLine = result.stdout.split("\n").find((line) => line.includes("IOPlatformUUID"));
        if (!idLine) {
          return "";
        }
        const parts = idLine.split('" = "');
        if (parts.length === 2) {
          return parts[1].slice(0, -1);
        }
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-linux.js
var require_getMachineId_linux = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-linux.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var fs_1 = require("fs");
    var api_1 = require_src();
    async function getMachineId() {
      const paths = ["/etc/machine-id", "/var/lib/dbus/machine-id"];
      for (const path2 of paths) {
        try {
          const result = await fs_1.promises.readFile(path2, { encoding: "utf8" });
          return result.trim();
        } catch (e) {
          api_1.diag.debug(`error reading machine id: ${e}`);
        }
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-bsd.js
var require_getMachineId_bsd = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-bsd.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var fs_1 = require("fs");
    var execAsync_1 = require_execAsync();
    var api_1 = require_src();
    async function getMachineId() {
      try {
        const result = await fs_1.promises.readFile("/etc/hostid", { encoding: "utf8" });
        return result.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      try {
        const result = await (0, execAsync_1.execAsync)("kenv -q smbios.system.uuid");
        return result.stdout.trim();
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-win.js
var require_getMachineId_win = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-win.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var process2 = require("process");
    var execAsync_1 = require_execAsync();
    var api_1 = require_src();
    async function getMachineId() {
      const args = "QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid";
      let command = "%windir%\\System32\\REG.exe";
      if (process2.arch === "ia32" && "PROCESSOR_ARCHITEW6432" in process2.env) {
        command = "%windir%\\sysnative\\cmd.exe /c " + command;
      }
      try {
        const result = await (0, execAsync_1.execAsync)(`${command} ${args}`);
        const parts = result.stdout.split("REG_SZ");
        if (parts.length === 2) {
          return parts[1].trim();
        }
      } catch (e) {
        api_1.diag.debug(`error reading machine id: ${e}`);
      }
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-unsupported.js
var require_getMachineId_unsupported = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId-unsupported.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var api_1 = require_src();
    async function getMachineId() {
      api_1.diag.debug("could not read machine-id: unsupported platform");
      return "";
    }
    exports2.getMachineId = getMachineId;
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId.js
var require_getMachineId = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/machine-id/getMachineId.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMachineId = void 0;
    var process2 = require("process");
    var getMachineId;
    exports2.getMachineId = getMachineId;
    switch (process2.platform) {
      case "darwin":
        exports2.getMachineId = getMachineId = require_getMachineId_darwin().getMachineId;
        break;
      case "linux":
        exports2.getMachineId = getMachineId = require_getMachineId_linux().getMachineId;
        break;
      case "freebsd":
        exports2.getMachineId = getMachineId = require_getMachineId_bsd().getMachineId;
        break;
      case "win32":
        exports2.getMachineId = getMachineId = require_getMachineId_win().getMachineId;
        break;
      default:
        exports2.getMachineId = getMachineId = require_getMachineId_unsupported().getMachineId;
    }
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/HostDetectorSync.js
var require_HostDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/HostDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hostDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var os_1 = require("os");
    var utils_1 = require_utils4();
    var getMachineId_1 = require_getMachineId();
    var HostDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.HOST_NAME]: (0, os_1.hostname)(),
          [semantic_conventions_1.SemanticResourceAttributes.HOST_ARCH]: (0, utils_1.normalizeArch)((0, os_1.arch)())
        };
        return new Resource_1.Resource(attributes, this._getAsyncAttributes());
      }
      _getAsyncAttributes() {
        return (0, getMachineId_1.getMachineId)().then((machineId) => {
          const attributes = {};
          if (machineId) {
            attributes[semantic_conventions_1.SemanticResourceAttributes.HOST_ID] = machineId;
          }
          return attributes;
        });
      }
    };
    exports2.hostDetectorSync = new HostDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/HostDetector.js
var require_HostDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/HostDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hostDetector = void 0;
    var HostDetectorSync_1 = require_HostDetectorSync();
    var HostDetector = class {
      detect(_config) {
        return Promise.resolve(HostDetectorSync_1.hostDetectorSync.detect(_config));
      }
    };
    exports2.hostDetector = new HostDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/OSDetectorSync.js
var require_OSDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/OSDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.osDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var os_1 = require("os");
    var utils_1 = require_utils4();
    var OSDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.OS_TYPE]: (0, utils_1.normalizeType)((0, os_1.platform)()),
          [semantic_conventions_1.SemanticResourceAttributes.OS_VERSION]: (0, os_1.release)()
        };
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.osDetectorSync = new OSDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/OSDetector.js
var require_OSDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/OSDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.osDetector = void 0;
    var OSDetectorSync_1 = require_OSDetectorSync();
    var OSDetector = class {
      detect(_config) {
        return Promise.resolve(OSDetectorSync_1.osDetectorSync.detect(_config));
      }
    };
    exports2.osDetector = new OSDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetectorSync.js
var require_ProcessDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processDetectorSync = void 0;
    var api_1 = require_src();
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var os = require("os");
    var ProcessDetectorSync = class {
      detect(_config) {
        const attributes = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_PID]: process.pid,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME]: process.title,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH]: process.execPath,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND_ARGS]: [
            process.argv[0],
            ...process.execArgv,
            ...process.argv.slice(1)
          ],
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: process.versions.node,
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "nodejs",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Node.js"
        };
        if (process.argv.length > 1) {
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_COMMAND] = process.argv[1];
        }
        try {
          const userInfo = os.userInfo();
          attributes[semantic_conventions_1.SemanticResourceAttributes.PROCESS_OWNER] = userInfo.username;
        } catch (e) {
          api_1.diag.debug(`error obtaining process owner: ${e}`);
        }
        return new Resource_1.Resource(attributes);
      }
    };
    exports2.processDetectorSync = new ProcessDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetector.js
var require_ProcessDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/ProcessDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.processDetector = void 0;
    var ProcessDetectorSync_1 = require_ProcessDetectorSync();
    var ProcessDetector = class {
      detect(config) {
        return Promise.resolve(ProcessDetectorSync_1.processDetectorSync.detect(config));
      }
    };
    exports2.processDetector = new ProcessDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/node/index.js
var require_node4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/node/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_default_service_name(), exports2);
    __exportStar(require_HostDetector(), exports2);
    __exportStar(require_OSDetector(), exports2);
    __exportStar(require_HostDetectorSync(), exports2);
    __exportStar(require_OSDetectorSync(), exports2);
    __exportStar(require_ProcessDetector(), exports2);
    __exportStar(require_ProcessDetectorSync(), exports2);
  }
});

// node_modules/@opentelemetry/resources/build/src/platform/index.js
var require_platform4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/platform/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_node4(), exports2);
  }
});

// node_modules/@opentelemetry/resources/build/src/Resource.js
var require_Resource = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/Resource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Resource = void 0;
    var api_1 = require_src();
    var semantic_conventions_1 = require_src2();
    var core_1 = require_src3();
    var platform_1 = require_platform4();
    var Resource = class _Resource {
      constructor(attributes, asyncAttributesPromise) {
        var _a;
        this._attributes = attributes;
        this.asyncAttributesPending = asyncAttributesPromise != null;
        this._syncAttributes = (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
        this._asyncAttributesPromise = asyncAttributesPromise === null || asyncAttributesPromise === void 0 ? void 0 : asyncAttributesPromise.then((asyncAttributes) => {
          this._attributes = Object.assign({}, this._attributes, asyncAttributes);
          this.asyncAttributesPending = false;
          return asyncAttributes;
        }, (err) => {
          api_1.diag.debug("a resource's async attributes promise rejected: %s", err);
          this.asyncAttributesPending = false;
          return {};
        });
      }
      /**
       * Returns an empty Resource
       */
      static empty() {
        return _Resource.EMPTY;
      }
      /**
       * Returns a Resource that identifies the SDK in use.
       */
      static default() {
        return new _Resource({
          [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: (0, platform_1.defaultServiceName)(),
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_NAME],
          [semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]: core_1.SDK_INFO[semantic_conventions_1.SemanticResourceAttributes.TELEMETRY_SDK_VERSION]
        });
      }
      get attributes() {
        var _a;
        if (this.asyncAttributesPending) {
          api_1.diag.error("Accessing resource attributes before async attributes settled");
        }
        return (_a = this._attributes) !== null && _a !== void 0 ? _a : {};
      }
      /**
       * Returns a promise that will never be rejected. Resolves when all async attributes have finished being added to
       * this Resource's attributes. This is useful in exporters to block until resource detection
       * has finished.
       */
      async waitForAsyncAttributes() {
        if (this.asyncAttributesPending) {
          await this._asyncAttributesPromise;
        }
      }
      /**
       * Returns a new, merged {@link Resource} by merging the current Resource
       * with the other Resource. In case of a collision, other Resource takes
       * precedence.
       *
       * @param other the Resource that will be merged with this.
       * @returns the newly merged Resource.
       */
      merge(other) {
        var _a;
        if (!other)
          return this;
        const mergedSyncAttributes = Object.assign(Object.assign({}, this._syncAttributes), (_a = other._syncAttributes) !== null && _a !== void 0 ? _a : other.attributes);
        if (!this._asyncAttributesPromise && !other._asyncAttributesPromise) {
          return new _Resource(mergedSyncAttributes);
        }
        const mergedAttributesPromise = Promise.all([
          this._asyncAttributesPromise,
          other._asyncAttributesPromise
        ]).then(([thisAsyncAttributes, otherAsyncAttributes]) => {
          var _a2;
          return Object.assign(Object.assign(Object.assign(Object.assign({}, this._syncAttributes), thisAsyncAttributes), (_a2 = other._syncAttributes) !== null && _a2 !== void 0 ? _a2 : other.attributes), otherAsyncAttributes);
        });
        return new _Resource(mergedSyncAttributes, mergedAttributesPromise);
      }
    };
    exports2.Resource = Resource;
    Resource.EMPTY = new Resource({});
  }
});

// node_modules/@opentelemetry/resources/build/src/IResource.js
var require_IResource = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/IResource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/resources/build/src/types.js
var require_types3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/resources/build/src/config.js
var require_config3 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js
var require_BrowserDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.browserDetector = void 0;
    var __1 = require_src4();
    var BrowserDetector = class {
      detect(config) {
        return Promise.resolve(__1.browserDetectorSync.detect(config));
      }
    };
    exports2.browserDetector = new BrowserDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js
var require_EnvDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetectorSync = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var semantic_conventions_1 = require_src2();
    var Resource_1 = require_Resource();
    var EnvDetectorSync = class {
      constructor() {
        this._MAX_LENGTH = 255;
        this._COMMA_SEPARATOR = ",";
        this._LABEL_KEY_VALUE_SPLITTER = "=";
        this._ERROR_MESSAGE_INVALID_CHARS = "should be a ASCII string with a length greater than 0 and not exceed " + this._MAX_LENGTH + " characters.";
        this._ERROR_MESSAGE_INVALID_VALUE = "should be a ASCII string with a length not exceed " + this._MAX_LENGTH + " characters.";
      }
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(_config) {
        const attributes = {};
        const env2 = (0, core_1.getEnv)();
        const rawAttributes = env2.OTEL_RESOURCE_ATTRIBUTES;
        const serviceName = env2.OTEL_SERVICE_NAME;
        if (rawAttributes) {
          try {
            const parsedAttributes = this._parseResourceAttributes(rawAttributes);
            Object.assign(attributes, parsedAttributes);
          } catch (e) {
            api_1.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        }
        if (serviceName) {
          attributes[semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME] = serviceName;
        }
        return new Resource_1.Resource(attributes);
      }
      /**
       * Creates an attribute map from the OTEL_RESOURCE_ATTRIBUTES environment
       * variable.
       *
       * OTEL_RESOURCE_ATTRIBUTES: A comma-separated list of attributes describing
       * the source in more detail, e.g. “key1=val1,key2=val2”. Domain names and
       * paths are accepted as attribute keys. Values may be quoted or unquoted in
       * general. If a value contains whitespaces, =, or " characters, it must
       * always be quoted.
       *
       * @param rawEnvAttributes The resource attributes as a comma-seperated list
       * of key/value pairs.
       * @returns The sanitized resource attributes.
       */
      _parseResourceAttributes(rawEnvAttributes) {
        if (!rawEnvAttributes)
          return {};
        const attributes = {};
        const rawAttributes = rawEnvAttributes.split(this._COMMA_SEPARATOR, -1);
        for (const rawAttribute of rawAttributes) {
          const keyValuePair = rawAttribute.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (keyValuePair.length !== 2) {
            continue;
          }
          let [key, value] = keyValuePair;
          key = key.trim();
          value = value.trim().split(/^"|"$/).join("");
          if (!this._isValidAndNotEmpty(key)) {
            throw new Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          }
          if (!this._isValid(value)) {
            throw new Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          }
          attributes[key] = decodeURIComponent(value);
        }
        return attributes;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid.
       */
      _isValid(name2) {
        return name2.length <= this._MAX_LENGTH && this._isBaggageOctetString(name2);
      }
      // https://www.w3.org/TR/baggage/#definition
      _isBaggageOctetString(str) {
        for (let i = 0; i < str.length; i++) {
          const ch = str.charCodeAt(i);
          if (ch < 33 || ch === 44 || ch === 59 || ch === 92 || ch > 126) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determines whether the given String is a valid printable ASCII string with
       * a length greater than 0 and not exceed _MAX_LENGTH characters.
       *
       * @param str The String to be validated.
       * @returns Whether the String is valid and not empty.
       */
      _isValidAndNotEmpty(str) {
        return str.length > 0 && this._isValid(str);
      }
    };
    exports2.envDetectorSync = new EnvDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js
var require_EnvDetector = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/EnvDetector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.envDetector = void 0;
    var EnvDetectorSync_1 = require_EnvDetectorSync();
    var EnvDetector = class {
      /**
       * Returns a {@link Resource} populated with attributes from the
       * OTEL_RESOURCE_ATTRIBUTES environment variable. Note this is an async
       * function to conform to the Detector interface.
       *
       * @param config The resource detection config
       */
      detect(config) {
        return Promise.resolve(EnvDetectorSync_1.envDetectorSync.detect(config));
      }
    };
    exports2.envDetector = new EnvDetector();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js
var require_BrowserDetectorSync = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/BrowserDetectorSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.browserDetectorSync = void 0;
    var semantic_conventions_1 = require_src2();
    var __1 = require_src4();
    var api_1 = require_src();
    var BrowserDetectorSync = class {
      detect(config) {
        const isBrowser = typeof navigator !== "undefined";
        if (!isBrowser) {
          return __1.Resource.empty();
        }
        const browserResource = {
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: "browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION]: "Web Browser",
          [semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: navigator.userAgent
        };
        return this._getResourceAttributes(browserResource, config);
      }
      /**
       * Validates process resource attribute map from process variables
       *
       * @param browserResource The un-sanitized resource attributes from process as key/value pairs.
       * @param config: Config
       * @returns The sanitized resource attributes.
       */
      _getResourceAttributes(browserResource, _config) {
        if (browserResource[semantic_conventions_1.SemanticResourceAttributes.PROCESS_RUNTIME_VERSION] === "") {
          api_1.diag.debug("BrowserDetector failed: Unable to find required browser resources. ");
          return __1.Resource.empty();
        } else {
          return new __1.Resource(Object.assign({}, browserResource));
        }
      }
    };
    exports2.browserDetectorSync = new BrowserDetectorSync();
  }
});

// node_modules/@opentelemetry/resources/build/src/detectors/index.js
var require_detectors = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detectors/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_BrowserDetector(), exports2);
    __exportStar(require_EnvDetector(), exports2);
    __exportStar(require_BrowserDetectorSync(), exports2);
    __exportStar(require_EnvDetectorSync(), exports2);
  }
});

// node_modules/@opentelemetry/resources/build/src/utils.js
var require_utils5 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromiseLike = void 0;
    var isPromiseLike2 = (val) => {
      return val !== null && typeof val === "object" && typeof val.then === "function";
    };
    exports2.isPromiseLike = isPromiseLike2;
  }
});

// node_modules/@opentelemetry/resources/build/src/detect-resources.js
var require_detect_resources = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/detect-resources.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.detectResourcesSync = exports2.detectResources = void 0;
    var Resource_1 = require_Resource();
    var api_1 = require_src();
    var utils_1 = require_utils5();
    var detectResources = async (config = {}) => {
      const resources = await Promise.all((config.detectors || []).map(async (d) => {
        try {
          const resource = await d.detect(config);
          api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
          return resource;
        } catch (e) {
          api_1.diag.debug(`${d.constructor.name} failed: ${e.message}`);
          return Resource_1.Resource.empty();
        }
      }));
      logResources(resources);
      return resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
    };
    exports2.detectResources = detectResources;
    var detectResourcesSync = (config = {}) => {
      var _a;
      const resources = ((_a = config.detectors) !== null && _a !== void 0 ? _a : []).map((d) => {
        try {
          const resourceOrPromise = d.detect(config);
          let resource;
          if ((0, utils_1.isPromiseLike)(resourceOrPromise)) {
            const createPromise = async () => {
              const resolvedResource = await resourceOrPromise;
              return resolvedResource.attributes;
            };
            resource = new Resource_1.Resource({}, createPromise());
          } else {
            resource = resourceOrPromise;
          }
          if (resource.waitForAsyncAttributes) {
            void resource.waitForAsyncAttributes().then(() => api_1.diag.debug(`${d.constructor.name} found resource.`, resource));
          } else {
            api_1.diag.debug(`${d.constructor.name} found resource.`, resource);
          }
          return resource;
        } catch (e) {
          api_1.diag.error(`${d.constructor.name} failed: ${e.message}`);
          return Resource_1.Resource.empty();
        }
      });
      const mergedResources = resources.reduce((acc, resource) => acc.merge(resource), Resource_1.Resource.empty());
      if (mergedResources.waitForAsyncAttributes) {
        void mergedResources.waitForAsyncAttributes().then(() => {
          logResources(resources);
        });
      }
      return mergedResources;
    };
    exports2.detectResourcesSync = detectResourcesSync;
    var logResources = (resources) => {
      resources.forEach((resource) => {
        if (Object.keys(resource.attributes).length > 0) {
          const resourceDebugString = JSON.stringify(resource.attributes, null, 4);
          api_1.diag.verbose(resourceDebugString);
        }
      });
    };
  }
});

// node_modules/@opentelemetry/resources/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/@opentelemetry/resources/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Resource(), exports2);
    __exportStar(require_IResource(), exports2);
    __exportStar(require_platform4(), exports2);
    __exportStar(require_types3(), exports2);
    __exportStar(require_config3(), exports2);
    __exportStar(require_detectors(), exports2);
    __exportStar(require_detect_resources(), exports2);
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js
var require_MultiSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/MultiSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MultiSpanProcessor = void 0;
    var core_1 = require_src3();
    var MultiSpanProcessor = class {
      constructor(_spanProcessors) {
        this._spanProcessors = _spanProcessors;
      }
      forceFlush() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
          promises.push(spanProcessor.forceFlush());
        }
        return new Promise((resolve) => {
          Promise.all(promises).then(() => {
            resolve();
          }).catch((error) => {
            (0, core_1.globalErrorHandler)(error || new Error("MultiSpanProcessor: forceFlush failed"));
            resolve();
          });
        });
      }
      onStart(span, context) {
        for (const spanProcessor of this._spanProcessors) {
          spanProcessor.onStart(span, context);
        }
      }
      onEnd(span) {
        for (const spanProcessor of this._spanProcessors) {
          spanProcessor.onEnd(span);
        }
      }
      shutdown() {
        const promises = [];
        for (const spanProcessor of this._spanProcessors) {
          promises.push(spanProcessor.shutdown());
        }
        return new Promise((resolve, reject) => {
          Promise.all(promises).then(() => {
            resolve();
          }, reject);
        });
      }
    };
    exports2.MultiSpanProcessor = MultiSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js
var require_NoopSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/NoopSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoopSpanProcessor = void 0;
    var NoopSpanProcessor = class {
      onStart(_span, _context) {
      }
      onEnd(_span) {
      }
      shutdown() {
        return Promise.resolve();
      }
      forceFlush() {
        return Promise.resolve();
      }
    };
    exports2.NoopSpanProcessor = NoopSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js
var require_BasicTracerProvider = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/BasicTracerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicTracerProvider = exports2.ForceFlushState = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var resources_1 = require_src4();
    var _1 = require_src5();
    var config_1 = require_config2();
    var MultiSpanProcessor_1 = require_MultiSpanProcessor();
    var NoopSpanProcessor_1 = require_NoopSpanProcessor();
    var platform_1 = require_platform3();
    var utility_1 = require_utility();
    var ForceFlushState;
    (function(ForceFlushState2) {
      ForceFlushState2[ForceFlushState2["resolved"] = 0] = "resolved";
      ForceFlushState2[ForceFlushState2["timeout"] = 1] = "timeout";
      ForceFlushState2[ForceFlushState2["error"] = 2] = "error";
      ForceFlushState2[ForceFlushState2["unresolved"] = 3] = "unresolved";
    })(ForceFlushState = exports2.ForceFlushState || (exports2.ForceFlushState = {}));
    var BasicTracerProvider = class {
      constructor(config = {}) {
        var _a;
        this._registeredSpanProcessors = [];
        this._tracers = /* @__PURE__ */ new Map();
        const mergedConfig = (0, core_1.merge)({}, (0, config_1.loadDefaultConfig)(), (0, utility_1.reconfigureLimits)(config));
        this.resource = (_a = mergedConfig.resource) !== null && _a !== void 0 ? _a : resources_1.Resource.empty();
        this.resource = resources_1.Resource.default().merge(this.resource);
        this._config = Object.assign({}, mergedConfig, {
          resource: this.resource
        });
        const defaultExporter = this._buildExporterFromEnv();
        if (defaultExporter !== void 0) {
          const batchProcessor = new platform_1.BatchSpanProcessor(defaultExporter);
          this.activeSpanProcessor = batchProcessor;
        } else {
          this.activeSpanProcessor = new NoopSpanProcessor_1.NoopSpanProcessor();
        }
      }
      getTracer(name2, version, options) {
        const key = `${name2}@${version || ""}:${(options === null || options === void 0 ? void 0 : options.schemaUrl) || ""}`;
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new _1.Tracer({ name: name2, version, schemaUrl: options === null || options === void 0 ? void 0 : options.schemaUrl }, this._config, this));
        }
        return this._tracers.get(key);
      }
      /**
       * Adds a new {@link SpanProcessor} to this tracer.
       * @param spanProcessor the new SpanProcessor to be added.
       */
      addSpanProcessor(spanProcessor) {
        if (this._registeredSpanProcessors.length === 0) {
          this.activeSpanProcessor.shutdown().catch((err) => api_1.diag.error("Error while trying to shutdown current span processor", err));
        }
        this._registeredSpanProcessors.push(spanProcessor);
        this.activeSpanProcessor = new MultiSpanProcessor_1.MultiSpanProcessor(this._registeredSpanProcessors);
      }
      getActiveSpanProcessor() {
        return this.activeSpanProcessor;
      }
      /**
       * Register this TracerProvider for use with the OpenTelemetry API.
       * Undefined values may be replaced with defaults, and
       * null values will be skipped.
       *
       * @param config Configuration object for SDK registration
       */
      register(config = {}) {
        api_1.trace.setGlobalTracerProvider(this);
        if (config.propagator === void 0) {
          config.propagator = this._buildPropagatorFromEnv();
        }
        if (config.contextManager) {
          api_1.context.setGlobalContextManager(config.contextManager);
        }
        if (config.propagator) {
          api_1.propagation.setGlobalPropagator(config.propagator);
        }
      }
      forceFlush() {
        const timeout = this._config.forceFlushTimeoutMillis;
        const promises = this._registeredSpanProcessors.map((spanProcessor) => {
          return new Promise((resolve) => {
            let state;
            const timeoutInterval = setTimeout(() => {
              resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));
              state = ForceFlushState.timeout;
            }, timeout);
            spanProcessor.forceFlush().then(() => {
              clearTimeout(timeoutInterval);
              if (state !== ForceFlushState.timeout) {
                state = ForceFlushState.resolved;
                resolve(state);
              }
            }).catch((error) => {
              clearTimeout(timeoutInterval);
              state = ForceFlushState.error;
              resolve(error);
            });
          });
        });
        return new Promise((resolve, reject) => {
          Promise.all(promises).then((results) => {
            const errors = results.filter((result) => result !== ForceFlushState.resolved);
            if (errors.length > 0) {
              reject(errors);
            } else {
              resolve();
            }
          }).catch((error) => reject([error]));
        });
      }
      shutdown() {
        return this.activeSpanProcessor.shutdown();
      }
      /**
       * TS cannot yet infer the type of this.constructor:
       * https://github.com/Microsoft/TypeScript/issues/3841#issuecomment-337560146
       * There is no need to override either of the getters in your child class.
       * The type of the registered component maps should be the same across all
       * classes in the inheritance tree.
       */
      _getPropagator(name2) {
        var _a;
        return (_a = this.constructor._registeredPropagators.get(name2)) === null || _a === void 0 ? void 0 : _a();
      }
      _getSpanExporter(name2) {
        var _a;
        return (_a = this.constructor._registeredExporters.get(name2)) === null || _a === void 0 ? void 0 : _a();
      }
      _buildPropagatorFromEnv() {
        const uniquePropagatorNames = Array.from(new Set((0, core_1.getEnv)().OTEL_PROPAGATORS));
        const propagators = uniquePropagatorNames.map((name2) => {
          const propagator = this._getPropagator(name2);
          if (!propagator) {
            api_1.diag.warn(`Propagator "${name2}" requested through environment variable is unavailable.`);
          }
          return propagator;
        });
        const validPropagators = propagators.reduce((list, item) => {
          if (item) {
            list.push(item);
          }
          return list;
        }, []);
        if (validPropagators.length === 0) {
          return;
        } else if (uniquePropagatorNames.length === 1) {
          return validPropagators[0];
        } else {
          return new core_1.CompositePropagator({
            propagators: validPropagators
          });
        }
      }
      _buildExporterFromEnv() {
        const exporterName = (0, core_1.getEnv)().OTEL_TRACES_EXPORTER;
        if (exporterName === "none" || exporterName === "")
          return;
        const exporter = this._getSpanExporter(exporterName);
        if (!exporter) {
          api_1.diag.error(`Exporter "${exporterName}" requested through environment variable is unavailable.`);
        }
        return exporter;
      }
    };
    exports2.BasicTracerProvider = BasicTracerProvider;
    BasicTracerProvider._registeredPropagators = /* @__PURE__ */ new Map([
      ["tracecontext", () => new core_1.W3CTraceContextPropagator()],
      ["baggage", () => new core_1.W3CBaggagePropagator()]
    ]);
    BasicTracerProvider._registeredExporters = /* @__PURE__ */ new Map();
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js
var require_ConsoleSpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/ConsoleSpanExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConsoleSpanExporter = void 0;
    var core_1 = require_src3();
    var ConsoleSpanExporter = class {
      /**
       * Export spans.
       * @param spans
       * @param resultCallback
       */
      export(spans, resultCallback) {
        return this._sendSpans(spans, resultCallback);
      }
      /**
       * Shutdown the exporter.
       */
      shutdown() {
        this._sendSpans([]);
        return this.forceFlush();
      }
      /**
       * Exports any pending spans in exporter
       */
      forceFlush() {
        return Promise.resolve();
      }
      /**
       * converts span info into more readable format
       * @param span
       */
      _exportInfo(span) {
        var _a;
        return {
          traceId: span.spanContext().traceId,
          parentId: span.parentSpanId,
          traceState: (_a = span.spanContext().traceState) === null || _a === void 0 ? void 0 : _a.serialize(),
          name: span.name,
          id: span.spanContext().spanId,
          kind: span.kind,
          timestamp: (0, core_1.hrTimeToMicroseconds)(span.startTime),
          duration: (0, core_1.hrTimeToMicroseconds)(span.duration),
          attributes: span.attributes,
          status: span.status,
          events: span.events,
          links: span.links
        };
      }
      /**
       * Showing spans in console
       * @param spans
       * @param done
       */
      _sendSpans(spans, done) {
        for (const span of spans) {
          console.dir(this._exportInfo(span), { depth: 3 });
        }
        if (done) {
          return done({ code: core_1.ExportResultCode.SUCCESS });
        }
      }
    };
    exports2.ConsoleSpanExporter = ConsoleSpanExporter;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js
var require_InMemorySpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/InMemorySpanExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InMemorySpanExporter = void 0;
    var core_1 = require_src3();
    var InMemorySpanExporter = class {
      constructor() {
        this._finishedSpans = [];
        this._stopped = false;
      }
      export(spans, resultCallback) {
        if (this._stopped)
          return resultCallback({
            code: core_1.ExportResultCode.FAILED,
            error: new Error("Exporter has been stopped")
          });
        this._finishedSpans.push(...spans);
        setTimeout(() => resultCallback({ code: core_1.ExportResultCode.SUCCESS }), 0);
      }
      shutdown() {
        this._stopped = true;
        this._finishedSpans = [];
        return this.forceFlush();
      }
      /**
       * Exports any pending spans in the exporter
       */
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._finishedSpans = [];
      }
      getFinishedSpans() {
        return this._finishedSpans;
      }
    };
    exports2.InMemorySpanExporter = InMemorySpanExporter;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/ReadableSpan.js
var require_ReadableSpan = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/ReadableSpan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js
var require_SimpleSpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/SimpleSpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SimpleSpanProcessor = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var SimpleSpanProcessor = class {
      constructor(_exporter) {
        this._exporter = _exporter;
        this._shutdownOnce = new core_1.BindOnceFuture(this._shutdown, this);
        this._unresolvedExports = /* @__PURE__ */ new Set();
      }
      async forceFlush() {
        await Promise.all(Array.from(this._unresolvedExports));
        if (this._exporter.forceFlush) {
          await this._exporter.forceFlush();
        }
      }
      onStart(_span, _parentContext) {
      }
      onEnd(span) {
        var _a, _b;
        if (this._shutdownOnce.isCalled) {
          return;
        }
        if ((span.spanContext().traceFlags & api_1.TraceFlags.SAMPLED) === 0) {
          return;
        }
        const doExport = () => core_1.internal._export(this._exporter, [span]).then((result) => {
          var _a2;
          if (result.code !== core_1.ExportResultCode.SUCCESS) {
            (0, core_1.globalErrorHandler)((_a2 = result.error) !== null && _a2 !== void 0 ? _a2 : new Error(`SimpleSpanProcessor: span export failed (status ${result})`));
          }
        }).catch((error) => {
          (0, core_1.globalErrorHandler)(error);
        });
        if (span.resource.asyncAttributesPending) {
          const exportPromise = (_b = (_a = span.resource).waitForAsyncAttributes) === null || _b === void 0 ? void 0 : _b.call(_a).then(() => {
            if (exportPromise != null) {
              this._unresolvedExports.delete(exportPromise);
            }
            return doExport();
          }, (err) => (0, core_1.globalErrorHandler)(err));
          if (exportPromise != null) {
            this._unresolvedExports.add(exportPromise);
          }
        } else {
          void doExport();
        }
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return this._exporter.shutdown();
      }
    };
    exports2.SimpleSpanProcessor = SimpleSpanProcessor;
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/export/SpanExporter.js
var require_SpanExporter = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/export/SpanExporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/SpanProcessor.js
var require_SpanProcessor = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/SpanProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/TimedEvent.js
var require_TimedEvent = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/TimedEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/types.js
var require_types4 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/IdGenerator.js
var require_IdGenerator2 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/IdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@opentelemetry/sdk-trace-base/build/src/index.js
var require_src5 = __commonJS({
  "node_modules/@opentelemetry/sdk-trace-base/build/src/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Tracer(), exports2);
    __exportStar(require_BasicTracerProvider(), exports2);
    __exportStar(require_platform3(), exports2);
    __exportStar(require_ConsoleSpanExporter(), exports2);
    __exportStar(require_InMemorySpanExporter(), exports2);
    __exportStar(require_ReadableSpan(), exports2);
    __exportStar(require_SimpleSpanProcessor(), exports2);
    __exportStar(require_SpanExporter(), exports2);
    __exportStar(require_NoopSpanProcessor(), exports2);
    __exportStar(require_AlwaysOffSampler2(), exports2);
    __exportStar(require_AlwaysOnSampler2(), exports2);
    __exportStar(require_ParentBasedSampler2(), exports2);
    __exportStar(require_TraceIdRatioBasedSampler2(), exports2);
    __exportStar(require_Sampler(), exports2);
    __exportStar(require_Span(), exports2);
    __exportStar(require_SpanProcessor(), exports2);
    __exportStar(require_TimedEvent(), exports2);
    __exportStar(require_types4(), exports2);
    __exportStar(require_IdGenerator2(), exports2);
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js
var require_azure_coretracing_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/azure-coretracing.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.azureCoreTracing = exports2.AzureMonitorSymbol = void 0;
    var diagnostic_channel_1 = require_channel();
    exports2.AzureMonitorSymbol = "Azure_Monitor_Tracer";
    var publisherName = "azure-coretracing";
    var isPatched = false;
    var azureCoreTracingPatchFunction = function(coreTracing) {
      if (isPatched) {
        return coreTracing;
      }
      try {
        var tracing = require_src5();
        var api = require_src();
        var defaultProvider = new tracing.BasicTracerProvider();
        var defaultTracer = defaultProvider.getTracer("applicationinsights tracer");
        if (coreTracing.setTracer) {
          var setTracerOriginal_1 = coreTracing.setTracer;
          coreTracing.setTracer = function(tracer) {
            var startSpanOriginal = tracer.startSpan;
            tracer.startSpan = function(name2, options, context) {
              var span = startSpanOriginal.call(this, name2, options, context);
              var originalEnd = span.end;
              span.end = function() {
                var result = originalEnd.apply(this, arguments);
                diagnostic_channel_1.channel.publish(publisherName, span);
                return result;
              };
              return span;
            };
            tracer[exports2.AzureMonitorSymbol] = true;
            setTracerOriginal_1.call(this, tracer);
          };
          api.trace.getSpan(api.context.active());
          coreTracing.setTracer(defaultTracer);
        } else {
          var setGlobalTracerProviderOriginal_1 = api.trace.setGlobalTracerProvider;
          api.trace.setGlobalTracerProvider = function(tracerProvider) {
            var getTracerOriginal = tracerProvider.getTracer;
            tracerProvider.getTracer = function(tracerName, version) {
              var tracer = getTracerOriginal.call(this, tracerName, version);
              if (!tracer[exports2.AzureMonitorSymbol]) {
                var startSpanOriginal_1 = tracer.startSpan;
                tracer.startSpan = function(spanName, options, context) {
                  var span = startSpanOriginal_1.call(this, spanName, options, context);
                  var originalEnd = span.end;
                  span.end = function() {
                    var result = originalEnd.apply(this, arguments);
                    diagnostic_channel_1.channel.publish(publisherName, span);
                    return result;
                  };
                  return span;
                };
                tracer[exports2.AzureMonitorSymbol] = true;
              }
              return tracer;
            };
            return setGlobalTracerProviderOriginal_1.call(this, tracerProvider);
          };
          defaultProvider.register();
          api.trace.getSpan(api.context.active());
          var openTelemetryInstr = require("@opentelemetry/instrumentation");
          var azureSdkInstr = require("@azure/opentelemetry-instrumentation-azure-sdk");
          openTelemetryInstr.registerInstrumentations({
            instrumentations: [
              azureSdkInstr.createAzureSdkInstrumentation()
            ]
          });
        }
        isPatched = true;
      } catch (e) {
      }
      return coreTracing;
    };
    exports2.azureCoreTracing = {
      versionSpecifier: ">= 1.0.0 < 2.0.0",
      patch: azureCoreTracingPatchFunction,
      publisherName
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("@azure/core-tracing", exports2.azureCoreTracing);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js
var require_bunyan_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/bunyan.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.bunyan = void 0;
    var diagnostic_channel_1 = require_channel();
    var bunyanPatchFunction = function(originalBunyan) {
      var originalEmit = originalBunyan.prototype._emit;
      originalBunyan.prototype._emit = function(rec, noemit) {
        var ret = originalEmit.apply(this, arguments);
        if (!noemit) {
          var str = ret;
          if (!str) {
            str = originalEmit.call(this, rec, true);
          }
          diagnostic_channel_1.channel.publish("bunyan", { level: rec.level, result: str });
        }
        return ret;
      };
      return originalBunyan;
    };
    exports2.bunyan = {
      versionSpecifier: ">= 1.0.0 < 2.0.0",
      patch: bunyanPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("bunyan", exports2.bunyan);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/console.pub.js
var require_console_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/console.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.console = void 0;
    var diagnostic_channel_1 = require_channel();
    var stream_1 = require("stream");
    var consolePatchFunction = function(originalConsole) {
      var aiLoggingOutStream = new stream_1.Writable();
      var aiLoggingErrStream = new stream_1.Writable();
      aiLoggingOutStream.write = function(chunk) {
        if (!chunk) {
          return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message });
        return true;
      };
      aiLoggingErrStream.write = function(chunk) {
        if (!chunk) {
          return true;
        }
        var message = chunk.toString();
        diagnostic_channel_1.channel.publish("console", { message, stderr: true });
        return true;
      };
      var aiLoggingConsole = new originalConsole.Console(aiLoggingOutStream, aiLoggingErrStream);
      var consoleMethods = ["log", "info", "warn", "error", "dir", "time", "timeEnd", "trace", "assert"];
      var _loop_1 = function(method2) {
        var originalMethod = originalConsole[method2];
        if (originalMethod) {
          originalConsole[method2] = function() {
            if (aiLoggingConsole[method2]) {
              try {
                aiLoggingConsole[method2].apply(aiLoggingConsole, arguments);
              } catch (e) {
              }
            }
            return originalMethod.apply(originalConsole, arguments);
          };
        }
      };
      for (var _i = 0, consoleMethods_1 = consoleMethods; _i < consoleMethods_1.length; _i++) {
        var method = consoleMethods_1[_i];
        _loop_1(method);
      }
      return originalConsole;
    };
    exports2.console = {
      versionSpecifier: ">= 4.0.0",
      patch: consolePatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("console", exports2.console);
      require("console");
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js
var require_mongodb_core_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/mongodb-core.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.mongoCore = void 0;
    var diagnostic_channel_1 = require_channel();
    var mongodbcorePatchFunction = function(originalMongoCore) {
      var originalConnect = originalMongoCore.Server.prototype.connect;
      originalMongoCore.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        var originalWrite = this.s.pool.write;
        this.s.pool.write = function contextPreservingWrite() {
          var cbidx = typeof arguments[1] === "function" ? 1 : 2;
          if (typeof arguments[cbidx] === "function") {
            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
          }
          return originalWrite.apply(this, arguments);
        };
        var originalLogout = this.s.pool.logout;
        this.s.pool.logout = function contextPreservingLogout() {
          if (typeof arguments[1] === "function") {
            arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
          }
          return originalLogout.apply(this, arguments);
        };
        return ret;
      };
      return originalMongoCore;
    };
    exports2.mongoCore = {
      versionSpecifier: ">= 2.0.0 < 4.0.0",
      patch: mongodbcorePatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb-core", exports2.mongoCore);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js
var require_mongodb_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/mongodb.pub.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.mongo330 = exports2.mongo3 = exports2.mongo2 = void 0;
    var diagnostic_channel_1 = require_channel();
    var mongodbPatchFunction = function(originalMongo) {
      var listener = originalMongo.instrument({
        operationIdGenerator: {
          next: function() {
            return diagnostic_channel_1.channel.bindToContext(function(cb) {
              return cb();
            });
          }
        }
      });
      var eventMap = {};
      listener.on("started", function(event) {
        if (eventMap[event.requestId]) {
          return;
        }
        eventMap[event.requestId] = __assign2(__assign2({}, event), { time: /* @__PURE__ */ new Date() });
      });
      listener.on("succeeded", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
          event.operationId(function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
          });
        } else {
          diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
        }
      });
      listener.on("failed", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event.operationId === "function") {
          event.operationId(function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
          });
        } else {
          diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
        }
      });
      return originalMongo;
    };
    var mongodb3PatchFunction = function(originalMongo) {
      var listener = originalMongo.instrument();
      var eventMap = {};
      var contextMap = {};
      listener.on("started", function(event) {
        if (eventMap[event.requestId]) {
          return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function(cb) {
          return cb();
        });
        eventMap[event.requestId] = __assign2(__assign2({}, event), { time: /* @__PURE__ */ new Date() });
      });
      listener.on("succeeded", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
          });
          delete contextMap[event.requestId];
        }
      });
      listener.on("failed", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
          });
          delete contextMap[event.requestId];
        }
      });
      return originalMongo;
    };
    var mongodbcorePatchFunction = function(originalMongo) {
      var originalConnect = originalMongo.Server.prototype.connect;
      originalMongo.Server.prototype.connect = function contextPreservingConnect() {
        var ret = originalConnect.apply(this, arguments);
        var originalWrite = this.s.coreTopology.s.pool.write;
        this.s.coreTopology.s.pool.write = function contextPreservingWrite() {
          var cbidx = typeof arguments[1] === "function" ? 1 : 2;
          if (typeof arguments[cbidx] === "function") {
            arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(arguments[cbidx]);
          }
          return originalWrite.apply(this, arguments);
        };
        var originalLogout = this.s.coreTopology.s.pool.logout;
        this.s.coreTopology.s.pool.logout = function contextPreservingLogout() {
          if (typeof arguments[1] === "function") {
            arguments[1] = diagnostic_channel_1.channel.bindToContext(arguments[1]);
          }
          return originalLogout.apply(this, arguments);
        };
        return ret;
      };
      return originalMongo;
    };
    var mongodb330PatchFunction = function(originalMongo) {
      mongodbcorePatchFunction(originalMongo);
      var listener = originalMongo.instrument();
      var eventMap = {};
      var contextMap = {};
      listener.on("started", function(event) {
        if (eventMap[event.requestId]) {
          return;
        }
        contextMap[event.requestId] = diagnostic_channel_1.channel.bindToContext(function(cb) {
          return cb();
        });
        eventMap[event.requestId] = event;
      });
      listener.on("succeeded", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: true });
          });
          delete contextMap[event.requestId];
        }
      });
      listener.on("failed", function(event) {
        var startedData = eventMap[event.requestId];
        if (startedData) {
          delete eventMap[event.requestId];
        }
        if (typeof event === "object" && typeof contextMap[event.requestId] === "function") {
          contextMap[event.requestId](function() {
            return diagnostic_channel_1.channel.publish("mongodb", { startedData, event, succeeded: false });
          });
          delete contextMap[event.requestId];
        }
      });
      return originalMongo;
    };
    exports2.mongo2 = {
      versionSpecifier: ">= 2.0.0 <= 3.0.5",
      patch: mongodbPatchFunction
    };
    exports2.mongo3 = {
      versionSpecifier: "> 3.0.5 < 3.3.0",
      patch: mongodb3PatchFunction
    };
    exports2.mongo330 = {
      versionSpecifier: ">= 3.3.0 < 4.0.0",
      patch: mongodb330PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports2.mongo2);
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports2.mongo3);
      diagnostic_channel_1.channel.registerMonkeyPatch("mongodb", exports2.mongo330);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js
var require_mysql_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/mysql.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.mysql = void 0;
    var diagnostic_channel_1 = require_channel();
    var path2 = require("path");
    var mysqlPatchFunction = function(originalMysql, originalMysqlPath) {
      var patchObjectFunction = function(obj, name2) {
        return function(func, cbWrapper) {
          var originalFunc = obj[func];
          if (originalFunc) {
            obj[func] = function mysqlContextPreserver() {
              var cbidx = arguments.length - 1;
              for (var i = arguments.length - 1; i >= 0; --i) {
                if (typeof arguments[i] === "function") {
                  cbidx = i;
                  break;
                } else if (typeof arguments[i] !== "undefined") {
                  break;
                }
              }
              var cb = arguments[cbidx];
              var resultContainer = { result: null, startTime: null, startDate: null };
              if (typeof cb === "function") {
                if (cbWrapper) {
                  resultContainer.startTime = process.hrtime();
                  resultContainer.startDate = /* @__PURE__ */ new Date();
                  arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cbWrapper(resultContainer, cb));
                } else {
                  arguments[cbidx] = diagnostic_channel_1.channel.bindToContext(cb);
                }
              }
              var result = originalFunc.apply(this, arguments);
              resultContainer.result = result;
              return result;
            };
          }
        };
      };
      var patchClassMemberFunction = function(classObject, name2) {
        return patchObjectFunction(classObject.prototype, name2 + ".prototype");
      };
      var connectionCallbackFunctions = [
        "connect",
        "changeUser",
        "ping",
        "statistics",
        "end"
      ];
      var connectionClass = require(path2.dirname(originalMysqlPath) + "/lib/Connection");
      connectionCallbackFunctions.forEach(function(value) {
        return patchClassMemberFunction(connectionClass, "Connection")(value);
      });
      patchObjectFunction(connectionClass, "Connection")("createQuery", function(resultContainer, cb) {
        return function(err) {
          var hrDuration = process.hrtime(resultContainer.startTime);
          var duration = hrDuration[0] * 1e3 + hrDuration[1] / 1e6 | 0;
          diagnostic_channel_1.channel.publish("mysql", { query: resultContainer.result, callbackArgs: arguments, err, duration, time: resultContainer.startDate });
          cb.apply(this, arguments);
        };
      });
      var poolCallbackFunctions = [
        "_enqueueCallback"
      ];
      var poolClass = require(path2.dirname(originalMysqlPath) + "/lib/Pool");
      poolCallbackFunctions.forEach(function(value) {
        return patchClassMemberFunction(poolClass, "Pool")(value);
      });
      return originalMysql;
    };
    exports2.mysql = {
      versionSpecifier: ">= 2.0.0 < 3.0.0",
      patch: mysqlPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("mysql", exports2.mysql);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js
var require_pg_pool_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/pg-pool.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.postgresPool1 = void 0;
    var diagnostic_channel_1 = require_channel();
    function postgresPool1PatchFunction(originalPgPool) {
      var originalConnect = originalPgPool.prototype.connect;
      originalPgPool.prototype.connect = function connect(callback) {
        if (callback) {
          arguments[0] = diagnostic_channel_1.channel.bindToContext(callback);
        }
        return originalConnect.apply(this, arguments);
      };
      return originalPgPool;
    }
    exports2.postgresPool1 = {
      versionSpecifier: ">= 1.0.0 < 3.0.0",
      patch: postgresPool1PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("pg-pool", exports2.postgresPool1);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js
var require_pg_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/pg.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.postgres7 = exports2.postgres6 = void 0;
    var diagnostic_channel_1 = require_channel();
    var events_1 = require("events");
    var publisherName = "postgres";
    function postgres6PatchFunction(originalPg, originalPgPath) {
      var originalClientQuery = originalPg.Client.prototype.query;
      var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
      originalPg.Client.prototype.query = function query(config, values, callback) {
        var data = {
          query: {},
          database: {
            host: this.connectionParameters.host,
            port: this.connectionParameters.port
          },
          result: null,
          error: null,
          duration: 0,
          time: /* @__PURE__ */ new Date()
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
          if (cb && cb[diagnosticOriginalFunc]) {
            cb = cb[diagnosticOriginalFunc];
          }
          var trackingCallback = diagnostic_channel_1.channel.bindToContext(function(err, res) {
            var end = process.hrtime(start);
            data.result = res && { rowCount: res.rowCount, command: res.command };
            data.error = err;
            data.duration = Math.ceil(end[0] * 1e3 + end[1] / 1e6);
            diagnostic_channel_1.channel.publish(publisherName, data);
            if (err) {
              if (cb) {
                return cb.apply(this, arguments);
              } else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                queryResult.emit("error", err);
              }
            } else if (cb) {
              cb.apply(this, arguments);
            }
          });
          try {
            Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
            return trackingCallback;
          } catch (e) {
            return cb;
          }
        }
        try {
          if (typeof config === "string") {
            if (values instanceof Array) {
              data.query.preparable = {
                text: config,
                args: values
              };
              callback = patchCallback(callback);
            } else {
              data.query.text = config;
              if (callback) {
                callback = patchCallback(callback);
              } else {
                values = patchCallback(values);
              }
            }
          } else {
            if (typeof config.name === "string") {
              data.query.plan = config.name;
            } else if (config.values instanceof Array) {
              data.query.preparable = {
                text: config.text,
                args: config.values
              };
            } else {
              data.query.text = config.text;
            }
            if (callback) {
              callback = patchCallback(callback);
            } else if (values) {
              values = patchCallback(values);
            } else {
              config.callback = patchCallback(config.callback);
            }
          }
        } catch (e) {
          return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = arguments.length > 3 ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        return queryResult;
      };
      return originalPg;
    }
    function postgres7PatchFunction(originalPg, originalPgPath) {
      var originalClientQuery = originalPg.Client.prototype.query;
      var diagnosticOriginalFunc = "__diagnosticOriginalFunc";
      originalPg.Client.prototype.query = function query(config, values, callback) {
        var _this = this;
        var callbackProvided = !!callback;
        var data = {
          query: {},
          database: {
            host: this.connectionParameters.host,
            port: this.connectionParameters.port
          },
          result: null,
          error: null,
          duration: 0,
          time: /* @__PURE__ */ new Date()
        };
        var start = process.hrtime();
        var queryResult;
        function patchCallback(cb) {
          if (cb && cb[diagnosticOriginalFunc]) {
            cb = cb[diagnosticOriginalFunc];
          }
          var trackingCallback = diagnostic_channel_1.channel.bindToContext(function(err, res) {
            var end = process.hrtime(start);
            data.result = res && { rowCount: res.rowCount, command: res.command };
            data.error = err;
            data.duration = Math.ceil(end[0] * 1e3 + end[1] / 1e6);
            diagnostic_channel_1.channel.publish(publisherName, data);
            if (err) {
              if (cb) {
                return cb.apply(this, arguments);
              } else if (queryResult && queryResult instanceof events_1.EventEmitter) {
                queryResult.emit("error", err);
              }
            } else if (cb) {
              cb.apply(this, arguments);
            }
          });
          try {
            Object.defineProperty(trackingCallback, diagnosticOriginalFunc, { value: cb });
            return trackingCallback;
          } catch (e) {
            return cb;
          }
        }
        try {
          if (typeof config === "string") {
            if (values instanceof Array) {
              data.query.preparable = {
                text: config,
                args: values
              };
              callbackProvided = typeof callback === "function";
              callback = callbackProvided ? patchCallback(callback) : callback;
            } else {
              data.query.text = config;
              if (callback) {
                callbackProvided = typeof callback === "function";
                callback = callbackProvided ? patchCallback(callback) : callback;
              } else {
                callbackProvided = typeof values === "function";
                values = callbackProvided ? patchCallback(values) : values;
              }
            }
          } else {
            if (typeof config.name === "string") {
              data.query.plan = config.name;
            } else if (config.values instanceof Array) {
              data.query.preparable = {
                text: config.text,
                args: config.values
              };
            } else {
              data.query.text = config.text;
            }
            if (callback) {
              callbackProvided = typeof callback === "function";
              callback = patchCallback(callback);
            } else if (values) {
              callbackProvided = typeof values === "function";
              values = callbackProvided ? patchCallback(values) : values;
            } else {
              callbackProvided = typeof config.callback === "function";
              config.callback = callbackProvided ? patchCallback(config.callback) : config.callback;
            }
          }
        } catch (e) {
          return originalClientQuery.apply(this, arguments);
        }
        arguments[0] = config;
        arguments[1] = values;
        arguments[2] = callback;
        arguments.length = arguments.length > 3 ? arguments.length : 3;
        queryResult = originalClientQuery.apply(this, arguments);
        if (!callbackProvided) {
          return queryResult.then(function(result) {
            patchCallback()(void 0, result);
            return new _this._Promise(function(resolve, reject) {
              resolve(result);
            });
          }).catch(function(error) {
            patchCallback()(error, void 0);
            return new _this._Promise(function(resolve, reject) {
              reject(error);
            });
          });
        }
        return queryResult;
      };
      return originalPg;
    }
    exports2.postgres6 = {
      versionSpecifier: "6.*",
      patch: postgres6PatchFunction
    };
    exports2.postgres7 = {
      versionSpecifier: ">=7.* <=8.*",
      patch: postgres7PatchFunction,
      publisherName
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports2.postgres6);
      diagnostic_channel_1.channel.registerMonkeyPatch("pg", exports2.postgres7);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js
var require_redis_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/redis.pub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.redis = void 0;
    var diagnostic_channel_1 = require_channel();
    var redisPatchFunction = function(originalRedis) {
      var originalSend = originalRedis.RedisClient.prototype.internal_send_command;
      originalRedis.RedisClient.prototype.internal_send_command = function(commandObj) {
        if (commandObj) {
          var cb_1 = commandObj.callback;
          if (!cb_1 || !cb_1.pubsubBound) {
            var address_1 = this.address;
            var startTime_1 = process.hrtime();
            var startDate_1 = /* @__PURE__ */ new Date();
            commandObj.callback = diagnostic_channel_1.channel.bindToContext(function(err, result) {
              var hrDuration = process.hrtime(startTime_1);
              var duration = hrDuration[0] * 1e3 + hrDuration[1] / 1e6 | 0;
              diagnostic_channel_1.channel.publish("redis", { duration, address: address_1, commandObj, err, result, time: startDate_1 });
              if (typeof cb_1 === "function") {
                cb_1.apply(this, arguments);
              }
            });
            commandObj.callback.pubsubBound = true;
          }
        }
        return originalSend.call(this, commandObj);
      };
      return originalRedis;
    };
    exports2.redis = {
      versionSpecifier: ">= 2.0.0 < 4.0.0",
      patch: redisPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("redis", exports2.redis);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js
var require_tedious_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/tedious.pub.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.tedious = void 0;
    var diagnostic_channel_1 = require_channel();
    var tediousPatchFunction = function(originalTedious) {
      var originalMakeRequest = originalTedious.Connection.prototype.makeRequest;
      originalTedious.Connection.prototype.makeRequest = function makeRequest() {
        function getPatchedCallback(origCallback) {
          var start = process.hrtime();
          var data = {
            query: {},
            database: {
              host: null,
              port: null
            },
            result: null,
            error: null,
            duration: 0
          };
          return diagnostic_channel_1.channel.bindToContext(function(err, rowCount, rows) {
            var end = process.hrtime(start);
            data = __assign2(__assign2({}, data), { database: {
              host: this.connection.config.server,
              port: this.connection.config.options.port
            }, result: !err && { rowCount, rows }, query: {
              text: this.parametersByName.statement.value
            }, error: err, duration: Math.ceil(end[0] * 1e3 + end[1] / 1e6) });
            diagnostic_channel_1.channel.publish("tedious", data);
            origCallback.call(this, err, rowCount, rows);
          });
        }
        var request = arguments[0];
        arguments[0].callback = getPatchedCallback(request.callback);
        originalMakeRequest.apply(this, arguments);
      };
      return originalTedious;
    };
    exports2.tedious = {
      versionSpecifier: ">= 6.0.0 < 9.0.0",
      patch: tediousPatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("tedious", exports2.tedious);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js
var require_winston_pub = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/winston.pub.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __rest = exports2 && exports2.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.winston2 = exports2.winston3 = void 0;
    var diagnostic_channel_1 = require_channel();
    var winston2PatchFunction = function(originalWinston) {
      var originalLog = originalWinston.Logger.prototype.log;
      var curLevels;
      var loggingFilter = function(level, message, meta) {
        var levelKind;
        if (curLevels === originalWinston.config.npm.levels) {
          levelKind = "npm";
        } else if (curLevels === originalWinston.config.syslog.levels) {
          levelKind = "syslog";
        } else {
          levelKind = "unknown";
        }
        diagnostic_channel_1.channel.publish("winston", { level, message, meta, levelKind });
        return message;
      };
      originalWinston.Logger.prototype.log = function log() {
        curLevels = this.levels;
        if (!this.filters || this.filters.length === 0) {
          this.filters = [loggingFilter];
        } else if (this.filters[this.filters.length - 1] !== loggingFilter) {
          this.filters = this.filters.filter(function(f) {
            return f !== loggingFilter;
          });
          this.filters.push(loggingFilter);
        }
        return originalLog.apply(this, arguments);
      };
      return originalWinston;
    };
    var winston3PatchFunction = function(originalWinston) {
      var mapLevelToKind = function(winston, level) {
        var levelKind;
        if (winston.config.npm.levels[level] != null) {
          levelKind = "npm";
        } else if (winston.config.syslog.levels[level] != null) {
          levelKind = "syslog";
        } else {
          levelKind = "unknown";
        }
        return levelKind;
      };
      var AppInsightsTransport = (
        /** @class */
        function(_super) {
          __extends2(AppInsightsTransport2, _super);
          function AppInsightsTransport2(winston, opts) {
            var _this = _super.call(this, opts) || this;
            _this.winston = winston;
            return _this;
          }
          AppInsightsTransport2.prototype.log = function(info, callback) {
            var message = info.message, level = info.level, meta = info.meta, splat = __rest(info, ["message", "level", "meta"]);
            level = typeof Symbol["for"] === "function" ? info[Symbol["for"]("level")] : level;
            message = info instanceof Error ? info : message;
            var levelKind = mapLevelToKind(this.winston, level);
            meta = meta || {};
            for (var key in splat) {
              if (splat.hasOwnProperty(key)) {
                meta[key] = splat[key];
              }
            }
            diagnostic_channel_1.channel.publish("winston", { message, level, levelKind, meta });
            callback();
          };
          return AppInsightsTransport2;
        }(originalWinston.Transport)
      );
      function patchedConfigure() {
        var levels = originalWinston.config.npm.levels;
        if (arguments && arguments[0] && arguments[0].levels) {
          levels = arguments[0].levels;
        }
        var lastLevel;
        for (var level in levels) {
          if (levels.hasOwnProperty(level)) {
            lastLevel = lastLevel === void 0 || levels[level] > levels[lastLevel] ? level : lastLevel;
          }
        }
        this.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
      }
      var origCreate = originalWinston.createLogger;
      originalWinston.createLogger = function patchedCreate() {
        var levels = originalWinston.config.npm.levels;
        if (arguments && arguments[0] && arguments[0].levels) {
          levels = arguments[0].levels;
        }
        var lastLevel;
        for (var level in levels) {
          if (levels.hasOwnProperty(level)) {
            lastLevel = lastLevel === void 0 || levels[level] > levels[lastLevel] ? level : lastLevel;
          }
        }
        var result = origCreate.apply(this, arguments);
        result.add(new AppInsightsTransport(originalWinston, { level: lastLevel }));
        var origConfigure = result.configure;
        result.configure = function() {
          origConfigure.apply(this, arguments);
          patchedConfigure.apply(this, arguments);
        };
        return result;
      };
      var origRootConfigure = originalWinston.configure;
      originalWinston.configure = function() {
        origRootConfigure.apply(this, arguments);
        patchedConfigure.apply(this, arguments);
      };
      originalWinston.add(new AppInsightsTransport(originalWinston));
      return originalWinston;
    };
    exports2.winston3 = {
      versionSpecifier: "3.x",
      patch: winston3PatchFunction
    };
    exports2.winston2 = {
      versionSpecifier: "2.x",
      patch: winston2PatchFunction
    };
    function enable() {
      diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports2.winston2);
      diagnostic_channel_1.channel.registerMonkeyPatch("winston", exports2.winston3);
    }
    exports2.enable = enable;
  }
});

// node_modules/diagnostic-channel-publishers/dist/src/index.js
var require_src6 = __commonJS({
  "node_modules/diagnostic-channel-publishers/dist/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.tedious = exports2.pgPool = exports2.pg = exports2.winston = exports2.redis = exports2.mysql = exports2.mongodb = exports2.mongodbCore = exports2.console = exports2.bunyan = exports2.azuresdk = void 0;
    var azuresdk = require_azure_coretracing_pub();
    exports2.azuresdk = azuresdk;
    var bunyan = require_bunyan_pub();
    exports2.bunyan = bunyan;
    var consolePub = require_console_pub();
    exports2.console = consolePub;
    var mongodbCore = require_mongodb_core_pub();
    exports2.mongodbCore = mongodbCore;
    var mongodb = require_mongodb_pub();
    exports2.mongodb = mongodb;
    var mysql = require_mysql_pub();
    exports2.mysql = mysql;
    var pgPool = require_pg_pool_pub();
    exports2.pgPool = pgPool;
    var pg = require_pg_pub();
    exports2.pg = pg;
    var redis = require_redis_pub();
    exports2.redis = redis;
    var tedious = require_tedious_pub();
    exports2.tedious = tedious;
    var winston = require_winston_pub();
    exports2.winston = winston;
    function enable() {
      bunyan.enable();
      consolePub.enable();
      mongodbCore.enable();
      mongodb.enable();
      mysql.enable();
      pg.enable();
      pgPool.enable();
      redis.enable();
      winston.enable();
      azuresdk.enable();
      tedious.enable();
    }
    exports2.enable = enable;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js
var require_initialization = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/initialization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerContextPreservation = exports2.IsInitialized = void 0;
    var Logging = require_Logging();
    var JsonConfig_1 = require_JsonConfig();
    exports2.IsInitialized = !JsonConfig_1.JsonConfig.getInstance().noDiagnosticChannel;
    var TAG = "DiagnosticChannel";
    if (exports2.IsInitialized) {
      publishers = require_src6();
      individualOptOuts = JsonConfig_1.JsonConfig.getInstance().noPatchModules;
      unpatchedModules = individualOptOuts.split(",");
      modules = {
        bunyan: publishers.bunyan,
        console: publishers.console,
        mongodb: publishers.mongodb,
        mongodbCore: publishers.mongodbCore,
        mysql: publishers.mysql,
        redis: publishers.redis,
        pg: publishers.pg,
        pgPool: publishers.pgPool,
        winston: publishers.winston,
        azuresdk: publishers.azuresdk
      };
      for (mod in modules) {
        if (unpatchedModules.indexOf(mod) === -1) {
          modules[mod].enable();
          Logging.info(TAG, "Subscribed to " + mod + " events");
        }
      }
      if (unpatchedModules.length > 0) {
        Logging.info(TAG, "Some modules will not be patched", unpatchedModules);
      }
    } else {
      Logging.info(TAG, "Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set");
    }
    var publishers;
    var individualOptOuts;
    var unpatchedModules;
    var modules;
    var mod;
    function registerContextPreservation(cb) {
      if (!exports2.IsInitialized) {
        return;
      }
      var diagChannel = require_channel();
      diagChannel.channel.addContextPreservation(cb);
    }
    exports2.registerContextPreservation = registerContextPreservation;
  }
});

// node_modules/applicationinsights/out/Library/RequestResponseHeaders.js
var require_RequestResponseHeaders = __commonJS({
  "node_modules/applicationinsights/out/Library/RequestResponseHeaders.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * Request-Context header
       */
      requestContextHeader: "request-context",
      /**
       * Source instrumentation header that is added by an application while making http
       * requests and retrieved by the other application when processing incoming requests.
       */
      requestContextSourceKey: "appId",
      /**
       * Target instrumentation header that is added to the response and retrieved by the
       * calling application when processing incoming responses.
       */
      requestContextTargetKey: "appId",
      /**
       * Request-Id header
       */
      requestIdHeader: "request-id",
      /**
       * Legacy Header containing the id of the immediate caller
       */
      parentIdHeader: "x-ms-request-id",
      /**
       * Legacy Header containing the correlation id that kept the same for every telemetry item
       * across transactions
       */
      rootIdHeader: "x-ms-request-root-id",
      /**
       * Correlation-Context header
       *
       * Not currently actively used, but the contents should be passed from incoming to outgoing requests
       */
      correlationContextHeader: "correlation-context",
      /**
       * W3C distributed tracing protocol header
       */
      traceparentHeader: "traceparent",
      /**
       * W3C distributed tracing protocol state header
       */
      traceStateHeader: "tracestate"
    };
  }
});

// node_modules/applicationinsights/out/Library/Util.js
var require_Util = __commonJS({
  "node_modules/applicationinsights/out/Library/Util.js"(exports2, module2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var http = require("http");
    var https = require("https");
    var url = require("url");
    var constants = require("constants");
    var Logging = require_Logging();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var JsonConfig_1 = require_JsonConfig();
    var Util = (
      /** @class */
      function() {
        function Util2() {
          Util2._addCloseHandler();
        }
        Util2.getCookie = function(name2, cookie) {
          var value = "";
          if (name2 && name2.length && typeof cookie === "string") {
            var cookieName = name2 + "=";
            var cookies = cookie.split(";");
            for (var i = 0; i < cookies.length; i++) {
              var cookie = cookies[i];
              cookie = Util2.trim(cookie);
              if (cookie && cookie.indexOf(cookieName) === 0) {
                value = cookie.substring(cookieName.length, cookies[i].length);
                break;
              }
            }
          }
          return value;
        };
        Util2.trim = function(str) {
          if (typeof str === "string") {
            return str.replace(/^\s+|\s+$/g, "");
          } else {
            return "";
          }
        };
        Util2.int32ArrayToBase64 = function(array) {
          var toChar = function(v, i) {
            return String.fromCharCode(v >> i & 255);
          };
          var int32AsString = function(v) {
            return toChar(v, 24) + toChar(v, 16) + toChar(v, 8) + toChar(v, 0);
          };
          var x = array.map(int32AsString).join("");
          var b = Buffer.from ? Buffer.from(x, "binary") : new Buffer(x, "binary");
          var s = b.toString("base64");
          return s.substr(0, s.indexOf("="));
        };
        Util2.random32 = function() {
          return 4294967296 * Math.random() | 0;
        };
        Util2.randomu32 = function() {
          return Util2.random32() + 2147483648;
        };
        Util2.w3cTraceId = function() {
          var hexValues = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
          var oct = "", tmp;
          for (var a = 0; a < 4; a++) {
            tmp = Util2.random32();
            oct += hexValues[tmp & 15] + hexValues[tmp >> 4 & 15] + hexValues[tmp >> 8 & 15] + hexValues[tmp >> 12 & 15] + hexValues[tmp >> 16 & 15] + hexValues[tmp >> 20 & 15] + hexValues[tmp >> 24 & 15] + hexValues[tmp >> 28 & 15];
          }
          var clockSequenceHi = hexValues[8 + Math.random() * 4 | 0];
          return oct.substr(0, 8) + oct.substr(9, 4) + "4" + oct.substr(13, 3) + clockSequenceHi + oct.substr(16, 3) + oct.substr(19, 12);
        };
        Util2.w3cSpanId = function() {
          return Util2.w3cTraceId().substring(16);
        };
        Util2.isValidW3CId = function(id) {
          return id.length === 32 && id !== "00000000000000000000000000000000";
        };
        Util2.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
        Util2.isError = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Error]";
        };
        Util2.isPrimitive = function(input) {
          var propType = typeof input;
          return propType === "string" || propType === "number" || propType === "boolean";
        };
        Util2.isDate = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Date]";
        };
        Util2.msToTimeSpan = function(totalms) {
          if (isNaN(totalms) || totalms < 0) {
            totalms = 0;
          }
          var sec = (totalms / 1e3 % 60).toFixed(7).replace(/0{0,4}$/, "");
          var min = "" + Math.floor(totalms / (1e3 * 60)) % 60;
          var hour = "" + Math.floor(totalms / (1e3 * 60 * 60)) % 24;
          var days = Math.floor(totalms / (1e3 * 60 * 60 * 24));
          sec = sec.indexOf(".") < 2 ? "0" + sec : sec;
          min = min.length < 2 ? "0" + min : min;
          hour = hour.length < 2 ? "0" + hour : hour;
          var daysText = days > 0 ? days + "." : "";
          return daysText + hour + ":" + min + ":" + sec;
        };
        Util2.extractError = function(err) {
          var looseError = err;
          return {
            message: err.message,
            code: looseError.code || looseError.id || ""
          };
        };
        Util2.extractObject = function(origProperty) {
          if (origProperty instanceof Error) {
            return Util2.extractError(origProperty);
          }
          if (typeof origProperty.toJSON === "function") {
            return origProperty.toJSON();
          }
          return origProperty;
        };
        Util2.validateStringMap = function(obj) {
          if (typeof obj !== "object") {
            Logging.info("Invalid properties dropped from payload");
            return;
          }
          var map = {};
          for (var field in obj) {
            var property = "";
            var origProperty = obj[field];
            var propType = typeof origProperty;
            if (Util2.isPrimitive(origProperty)) {
              property = origProperty.toString();
            } else if (origProperty === null || propType === "undefined") {
              property = "";
            } else if (propType === "function") {
              Logging.info("key: " + field + " was function; will not serialize");
              continue;
            } else {
              var stringTarget = Util2.isArray(origProperty) ? origProperty : Util2.extractObject(origProperty);
              try {
                if (Util2.isPrimitive(stringTarget)) {
                  property = stringTarget;
                } else {
                  property = JSON.stringify(stringTarget);
                }
              } catch (e) {
                property = origProperty.constructor.name.toString() + " (Error: " + e.message + ")";
                Logging.info("key: " + field + ", could not be serialized");
              }
            }
            map[field] = property.substring(0, Util2.MAX_PROPERTY_LENGTH);
          }
          return map;
        };
        Util2.canIncludeCorrelationHeader = function(client, requestUrl) {
          var excludedDomains = client && client.config && client.config.correlationHeaderExcludedDomains;
          if (!excludedDomains || excludedDomains.length == 0 || !requestUrl) {
            return true;
          }
          for (var i = 0; i < excludedDomains.length; i++) {
            var regex = new RegExp(excludedDomains[i].replace(/\./g, ".").replace(/\*/g, ".*"));
            try {
              if (regex.test(new url.URL(requestUrl).hostname)) {
                return false;
              }
            } catch (ex) {
            }
          }
          return true;
        };
        Util2.getCorrelationContextTarget = function(response, key) {
          var contextHeaders = response.headers && response.headers[RequestResponseHeaders.requestContextHeader];
          if (contextHeaders) {
            var keyValues = contextHeaders.split(",");
            for (var i = 0; i < keyValues.length; ++i) {
              var keyValue = keyValues[i].split("=");
              if (keyValue.length == 2 && keyValue[0] == key) {
                return keyValue[1];
              }
            }
          }
        };
        Util2.makeRequest = function(config, requestUrl, requestOptions, requestCallback, useProxy, useAgent) {
          if (useProxy === void 0) {
            useProxy = true;
          }
          if (useAgent === void 0) {
            useAgent = true;
          }
          if (requestUrl && requestUrl.indexOf("//") === 0) {
            requestUrl = "https:" + requestUrl;
          }
          var requestUrlParsed = new url.URL(requestUrl);
          var options = __assign2(__assign2({}, requestOptions), { host: requestUrlParsed.hostname, port: requestUrlParsed.port, path: requestUrlParsed.pathname });
          var proxyUrl = void 0;
          if (useProxy) {
            if (requestUrlParsed.protocol === "https:") {
              proxyUrl = config.proxyHttpsUrl || void 0;
            }
            if (requestUrlParsed.protocol === "http:") {
              proxyUrl = config.proxyHttpUrl || void 0;
            }
            if (proxyUrl) {
              if (proxyUrl.indexOf("//") === 0) {
                proxyUrl = "http:" + proxyUrl;
              }
              try {
                var proxyUrlParsed = new url.URL(proxyUrl);
                if (proxyUrlParsed.protocol === "https:") {
                  Logging.info("Proxies that use HTTPS are not supported");
                  proxyUrl = void 0;
                } else {
                  options = __assign2(__assign2({}, options), { host: proxyUrlParsed.hostname, port: proxyUrlParsed.port || "80", path: requestUrl, headers: __assign2(__assign2({}, options.headers), { Host: requestUrlParsed.hostname }) });
                }
              } catch (err) {
                Logging.warn("Wrong proxy URL provided");
              }
            }
          }
          var isHttps = requestUrlParsed.protocol === "https:" && !proxyUrl;
          if (useAgent) {
            if (isHttps && config.httpsAgent !== void 0) {
              options.agent = config.httpsAgent;
            } else if (!isHttps && config.httpAgent !== void 0) {
              options.agent = config.httpAgent;
            } else if (isHttps) {
              options.agent = Util2._useKeepAlive ? Util2.keepAliveAgent : Util2.tlsRestrictedAgent;
            }
          }
          if (isHttps) {
            return https.request(options, requestCallback);
          } else {
            return http.request(options, requestCallback);
          }
        };
        Util2.safeIncludeCorrelationHeader = function(client, request, correlationHeader) {
          var header;
          if (typeof correlationHeader === "string") {
            header = correlationHeader;
          } else if (correlationHeader instanceof Array) {
            header = correlationHeader.join(",");
          } else if (correlationHeader && typeof correlationHeader.toString === "function") {
            try {
              header = correlationHeader.toString();
            } catch (err) {
              Logging.warn("Outgoing request-context header could not be read. Correlation of requests may be lost.", err, correlationHeader);
            }
          }
          if (header) {
            Util2.addCorrelationIdHeaderFromString(client, request, header);
          } else {
            request.setHeader(RequestResponseHeaders.requestContextHeader, RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
          }
        };
        Util2.dumpObj = function(object) {
          if (object) {
            try {
              var objectTypeDump = Object["prototype"].toString.call(object);
              var propertyValueDump = "";
              if (objectTypeDump === "[object Error]") {
                propertyValueDump = "{ stack: '" + object.stack + "', message: '" + object.message + "', name: '" + object.name + "'";
              } else {
                propertyValueDump = this.stringify(object);
              }
              return objectTypeDump + propertyValueDump;
            } catch (ex) {
              return object.toString();
            }
          }
        };
        Util2.stringify = function(payload) {
          try {
            return JSON.stringify(payload);
          } catch (error) {
            Logging.warn("Failed to serialize payload", error, payload);
          }
        };
        Util2.addCorrelationIdHeaderFromString = function(client, response, correlationHeader) {
          var components = correlationHeader.split(",");
          var key = RequestResponseHeaders.requestContextSourceKey + "=";
          var found2 = components.some(function(value) {
            return value.substring(0, key.length) === key;
          });
          if (!found2) {
            response.setHeader(RequestResponseHeaders.requestContextHeader, correlationHeader + "," + RequestResponseHeaders.requestContextSourceKey + "=" + client.config.correlationId);
          }
        };
        Util2._addCloseHandler = function() {
          if (!Util2._listenerAttached) {
            process.on("exit", function() {
              Util2.isNodeExit = true;
              Util2._useKeepAlive = false;
            });
            Util2._listenerAttached = true;
          }
        };
        Util2._useKeepAlive = !JsonConfig_1.JsonConfig.getInstance().noHttpAgentKeepAlive;
        Util2._listenerAttached = false;
        Util2.MAX_PROPERTY_LENGTH = 8192;
        Util2.keepAliveAgent = new https.Agent({
          keepAlive: true,
          maxSockets: 25,
          secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
        });
        Util2.tlsRestrictedAgent = new https.Agent({
          secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3 | constants.SSL_OP_NO_TLSv1 | constants.SSL_OP_NO_TLSv1_1
        });
        Util2.isNodeExit = false;
        return Util2;
      }()
    );
    module2.exports = Util;
  }
});

// node_modules/applicationinsights/out/Library/CorrelationIdManager.js
var require_CorrelationIdManager = __commonJS({
  "node_modules/applicationinsights/out/Library/CorrelationIdManager.js"(exports2, module2) {
    "use strict";
    var Util = require_Util();
    var CorrelationIdManager = (
      /** @class */
      function() {
        function CorrelationIdManager2() {
        }
        CorrelationIdManager2.queryCorrelationId = function(config, callback) {
        };
        CorrelationIdManager2.cancelCorrelationIdQuery = function(config, callback) {
        };
        CorrelationIdManager2.generateRequestId = function(parentId) {
          if (parentId) {
            parentId = parentId[0] == "|" ? parentId : "|" + parentId;
            if (parentId[parentId.length - 1] !== ".") {
              parentId += ".";
            }
            var suffix = (CorrelationIdManager2.currentRootId++).toString(16);
            return CorrelationIdManager2.appendSuffix(parentId, suffix, "_");
          } else {
            return CorrelationIdManager2.generateRootId();
          }
        };
        CorrelationIdManager2.getRootId = function(id) {
          var endIndex = id.indexOf(".");
          if (endIndex < 0) {
            endIndex = id.length;
          }
          var startIndex = id[0] === "|" ? 1 : 0;
          return id.substring(startIndex, endIndex);
        };
        CorrelationIdManager2.generateRootId = function() {
          return "|" + Util.w3cTraceId() + ".";
        };
        CorrelationIdManager2.appendSuffix = function(parentId, suffix, delimiter) {
          if (parentId.length + suffix.length < CorrelationIdManager2.requestIdMaxLength) {
            return parentId + suffix + delimiter;
          }
          var trimPosition = CorrelationIdManager2.requestIdMaxLength - 9;
          if (parentId.length > trimPosition) {
            for (; trimPosition > 1; --trimPosition) {
              var c = parentId[trimPosition - 1];
              if (c === "." || c === "_") {
                break;
              }
            }
          }
          if (trimPosition <= 1) {
            return CorrelationIdManager2.generateRootId();
          }
          suffix = Util.randomu32().toString(16);
          while (suffix.length < 8) {
            suffix = "0" + suffix;
          }
          return parentId.substring(0, trimPosition) + suffix + "#";
        };
        CorrelationIdManager2.correlationIdPrefix = "cid-v1:";
        CorrelationIdManager2.w3cEnabled = true;
        CorrelationIdManager2.HTTP_TIMEOUT = 2500;
        CorrelationIdManager2.requestIdMaxLength = 1024;
        CorrelationIdManager2.currentRootId = Util.randomu32();
        return CorrelationIdManager2;
      }()
    );
    module2.exports = CorrelationIdManager;
  }
});

// node_modules/applicationinsights/out/Library/Traceparent.js
var require_Traceparent = __commonJS({
  "node_modules/applicationinsights/out/Library/Traceparent.js"(exports2, module2) {
    "use strict";
    var Util = require_Util();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Traceparent = (
      /** @class */
      function() {
        function Traceparent2(traceparent, parentId) {
          this.traceFlag = Traceparent2.DEFAULT_TRACE_FLAG;
          this.version = Traceparent2.DEFAULT_VERSION;
          if (traceparent && typeof traceparent === "string") {
            if (traceparent.split(",").length > 1) {
              this.traceId = Util.w3cTraceId();
              this.spanId = Util.w3cTraceId().substr(0, 16);
            } else {
              var traceparentArr = traceparent.trim().split("-");
              var len = traceparentArr.length;
              if (len >= 4) {
                this.version = traceparentArr[0];
                this.traceId = traceparentArr[1];
                this.spanId = traceparentArr[2];
                this.traceFlag = traceparentArr[3];
              } else {
                this.traceId = Util.w3cTraceId();
                this.spanId = Util.w3cTraceId().substr(0, 16);
              }
              if (!this.version.match(/^[0-9a-f]{2}$/g)) {
                this.version = Traceparent2.DEFAULT_VERSION;
                this.traceId = Util.w3cTraceId();
              }
              if (this.version === "00" && len !== 4) {
                this.traceId = Util.w3cTraceId();
                this.spanId = Util.w3cTraceId().substr(0, 16);
              }
              if (this.version === "ff") {
                this.version = Traceparent2.DEFAULT_VERSION;
                this.traceId = Util.w3cTraceId();
                this.spanId = Util.w3cTraceId().substr(0, 16);
              }
              if (!this.version.match(/^0[0-9a-f]$/g)) {
                this.version = Traceparent2.DEFAULT_VERSION;
              }
              if (!this.traceFlag.match(/^[0-9a-f]{2}$/g)) {
                this.traceFlag = Traceparent2.DEFAULT_TRACE_FLAG;
                this.traceId = Util.w3cTraceId();
              }
              if (!Traceparent2.isValidTraceId(this.traceId)) {
                this.traceId = Util.w3cTraceId();
              }
              if (!Traceparent2.isValidSpanId(this.spanId)) {
                this.spanId = Util.w3cTraceId().substr(0, 16);
                this.traceId = Util.w3cTraceId();
              }
              this.parentId = this.getBackCompatRequestId();
            }
          } else if (parentId) {
            this.parentId = parentId.slice();
            var operationId = CorrelationIdManager.getRootId(parentId);
            if (!Traceparent2.isValidTraceId(operationId)) {
              this.legacyRootId = operationId;
              operationId = Util.w3cTraceId();
            }
            if (parentId.indexOf("|") !== -1) {
              parentId = parentId.substring(1 + parentId.substring(0, parentId.length - 1).lastIndexOf("."), parentId.length - 1);
            }
            this.traceId = operationId;
            this.spanId = parentId;
          } else {
            this.traceId = Util.w3cTraceId();
            this.spanId = Util.w3cTraceId().substr(0, 16);
          }
        }
        Traceparent2.isValidTraceId = function(id) {
          return id.match(/^[0-9a-f]{32}$/) && id !== "00000000000000000000000000000000";
        };
        Traceparent2.isValidSpanId = function(id) {
          return id.match(/^[0-9a-f]{16}$/) && id !== "0000000000000000";
        };
        Traceparent2.formatOpenTelemetryTraceFlags = function(traceFlags) {
          var formattedFlags = "0" + traceFlags.toString(16);
          return formattedFlags.substring(formattedFlags.length - 2);
        };
        Traceparent2.prototype.getBackCompatRequestId = function() {
          return "|" + this.traceId + "." + this.spanId + ".";
        };
        Traceparent2.prototype.toString = function() {
          return this.version + "-" + this.traceId + "-" + this.spanId + "-" + this.traceFlag;
        };
        Traceparent2.prototype.updateSpanId = function() {
          this.spanId = Util.w3cTraceId().substr(0, 16);
        };
        Traceparent2.DEFAULT_TRACE_FLAG = "01";
        Traceparent2.DEFAULT_VERSION = "00";
        return Traceparent2;
      }()
    );
    module2.exports = Traceparent;
  }
});

// node_modules/applicationinsights/out/Library/Tracestate.js
var require_Tracestate = __commonJS({
  "node_modules/applicationinsights/out/Library/Tracestate.js"(exports2, module2) {
    "use strict";
    var Tracestate = (
      /** @class */
      function() {
        function Tracestate2(id) {
          this.fieldmap = [];
          if (!id) {
            return;
          }
          this.fieldmap = this.parseHeader(id);
        }
        Tracestate2.prototype.toString = function() {
          var fieldarr = this.fieldmap;
          if (!fieldarr || fieldarr.length == 0) {
            return null;
          }
          return fieldarr.join(", ");
        };
        Tracestate2.validateKeyChars = function(key) {
          var keyParts = key.split("@");
          if (keyParts.length == 2) {
            var tenant = keyParts[0].trim();
            var vendor = keyParts[1].trim();
            var tenantValid = Boolean(tenant.match(/^[\ ]?[a-z0-9\*\-\_/]{1,241}$/));
            var vendorValid = Boolean(vendor.match(/^[\ ]?[a-z0-9\*\-\_/]{1,14}$/));
            return tenantValid && vendorValid;
          } else if (keyParts.length == 1) {
            return Boolean(key.match(/^[\ ]?[a-z0-9\*\-\_/]{1,256}$/));
          }
          return false;
        };
        Tracestate2.prototype.parseHeader = function(id) {
          var res = [];
          var keydeduper = {};
          var parts = id.split(",");
          if (parts.length > 32)
            return null;
          for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
            var rawPart = parts_1[_i];
            var part = rawPart.trim();
            if (part.length === 0) {
              continue;
            }
            var pair = part.split("=");
            if (pair.length !== 2) {
              return null;
            }
            if (!Tracestate2.validateKeyChars(pair[0])) {
              return null;
            }
            if (keydeduper[pair[0]]) {
              return null;
            } else {
              keydeduper[pair[0]] = true;
            }
            res.push(part);
          }
          return res;
        };
        Tracestate2.strict = true;
        return Tracestate2;
      }()
    );
    module2.exports = Tracestate;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js
var require_Domain = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/Domain.js"(exports2, module2) {
    "use strict";
    var Domain = (
      /** @class */
      function() {
        function Domain2() {
        }
        return Domain2;
      }()
    );
    module2.exports = Domain;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js
var require_AvailabilityData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/AvailabilityData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var AvailabilityData = (
      /** @class */
      function(_super) {
        __extends2(AvailabilityData2, _super);
        function AvailabilityData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.properties = {};
          _this.measurements = {};
          return _this;
        }
        return AvailabilityData2;
      }(Domain)
    );
    module2.exports = AvailabilityData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js
var require_Base = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/Base.js"(exports2, module2) {
    "use strict";
    var Base = (
      /** @class */
      function() {
        function Base2() {
        }
        return Base2;
      }()
    );
    module2.exports = Base;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js
var require_ContextTagKeys = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/ContextTagKeys.js"(exports2, module2) {
    "use strict";
    var ContextTagKeys = (
      /** @class */
      function() {
        function ContextTagKeys2() {
          this.applicationVersion = "ai.application.ver";
          this.deviceId = "ai.device.id";
          this.deviceLocale = "ai.device.locale";
          this.deviceModel = "ai.device.model";
          this.deviceOEMName = "ai.device.oemName";
          this.deviceOSVersion = "ai.device.osVersion";
          this.deviceType = "ai.device.type";
          this.locationIp = "ai.location.ip";
          this.operationId = "ai.operation.id";
          this.operationName = "ai.operation.name";
          this.operationParentId = "ai.operation.parentId";
          this.operationSyntheticSource = "ai.operation.syntheticSource";
          this.operationCorrelationVector = "ai.operation.correlationVector";
          this.sessionId = "ai.session.id";
          this.sessionIsFirst = "ai.session.isFirst";
          this.userAccountId = "ai.user.accountId";
          this.userId = "ai.user.id";
          this.userAuthUserId = "ai.user.authUserId";
          this.cloudRole = "ai.cloud.role";
          this.cloudRoleInstance = "ai.cloud.roleInstance";
          this.internalSdkVersion = "ai.internal.sdkVersion";
          this.internalAgentVersion = "ai.internal.agentVersion";
          this.internalNodeName = "ai.internal.nodeName";
        }
        return ContextTagKeys2;
      }()
    );
    module2.exports = ContextTagKeys;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js
var require_Data = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/Data.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Base = require_Base();
    var Data = (
      /** @class */
      function(_super) {
        __extends2(Data2, _super);
        function Data2() {
          return _super.call(this) || this;
        }
        return Data2;
      }(Base)
    );
    module2.exports = Data;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js
var require_DataPointType = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPointType.js"(exports2, module2) {
    "use strict";
    var DataPointType;
    (function(DataPointType2) {
      DataPointType2[DataPointType2["Measurement"] = 0] = "Measurement";
      DataPointType2[DataPointType2["Aggregation"] = 1] = "Aggregation";
    })(DataPointType || (DataPointType = {}));
    module2.exports = DataPointType;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js
var require_DataPoint = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/DataPoint.js"(exports2, module2) {
    "use strict";
    var DataPointType = require_DataPointType();
    var DataPoint = (
      /** @class */
      function() {
        function DataPoint2() {
          this.kind = DataPointType.Measurement;
        }
        return DataPoint2;
      }()
    );
    module2.exports = DataPoint;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js
var require_Envelope = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/Envelope.js"(exports2, module2) {
    "use strict";
    var Envelope = (
      /** @class */
      function() {
        function Envelope2() {
          this.ver = 1;
          this.sampleRate = 100;
          this.tags = {};
        }
        return Envelope2;
      }()
    );
    module2.exports = Envelope;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js
var require_EventData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/EventData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var EventData = (
      /** @class */
      function(_super) {
        __extends2(EventData2, _super);
        function EventData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.properties = {};
          _this.measurements = {};
          return _this;
        }
        return EventData2;
      }(Domain)
    );
    module2.exports = EventData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js
var require_ExceptionData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var ExceptionData = (
      /** @class */
      function(_super) {
        __extends2(ExceptionData2, _super);
        function ExceptionData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.exceptions = [];
          _this.properties = {};
          _this.measurements = {};
          return _this;
        }
        return ExceptionData2;
      }(Domain)
    );
    module2.exports = ExceptionData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js
var require_ExceptionDetails = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/ExceptionDetails.js"(exports2, module2) {
    "use strict";
    var ExceptionDetails = (
      /** @class */
      function() {
        function ExceptionDetails2() {
          this.hasFullStack = true;
          this.parsedStack = [];
        }
        return ExceptionDetails2;
      }()
    );
    module2.exports = ExceptionDetails;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js
var require_MessageData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/MessageData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var MessageData = (
      /** @class */
      function(_super) {
        __extends2(MessageData2, _super);
        function MessageData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.properties = {};
          return _this;
        }
        return MessageData2;
      }(Domain)
    );
    module2.exports = MessageData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js
var require_MetricData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/MetricData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var MetricData = (
      /** @class */
      function(_super) {
        __extends2(MetricData2, _super);
        function MetricData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.metrics = [];
          _this.properties = {};
          return _this;
        }
        return MetricData2;
      }(Domain)
    );
    module2.exports = MetricData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js
var require_PageViewData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/PageViewData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var EventData = require_EventData();
    var PageViewData = (
      /** @class */
      function(_super) {
        __extends2(PageViewData2, _super);
        function PageViewData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.properties = {};
          _this.measurements = {};
          return _this;
        }
        return PageViewData2;
      }(EventData)
    );
    module2.exports = PageViewData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js
var require_RemoteDependencyData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/RemoteDependencyData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var RemoteDependencyData = (
      /** @class */
      function(_super) {
        __extends2(RemoteDependencyData2, _super);
        function RemoteDependencyData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.success = true;
          _this.properties = {};
          _this.measurements = {};
          return _this;
        }
        return RemoteDependencyData2;
      }(Domain)
    );
    module2.exports = RemoteDependencyData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js
var require_RequestData = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/RequestData.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var Domain = require_Domain();
    var RequestData = (
      /** @class */
      function(_super) {
        __extends2(RequestData2, _super);
        function RequestData2() {
          var _this = _super.call(this) || this;
          _this.ver = 2;
          _this.properties = {};
          _this.measurements = {};
          return _this;
        }
        return RequestData2;
      }(Domain)
    );
    module2.exports = RequestData;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js
var require_SeverityLevel = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/SeverityLevel.js"(exports2, module2) {
    "use strict";
    var SeverityLevel;
    (function(SeverityLevel2) {
      SeverityLevel2[SeverityLevel2["Verbose"] = 0] = "Verbose";
      SeverityLevel2[SeverityLevel2["Information"] = 1] = "Information";
      SeverityLevel2[SeverityLevel2["Warning"] = 2] = "Warning";
      SeverityLevel2[SeverityLevel2["Error"] = 3] = "Error";
      SeverityLevel2[SeverityLevel2["Critical"] = 4] = "Critical";
    })(SeverityLevel || (SeverityLevel = {}));
    module2.exports = SeverityLevel;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js
var require_StackFrame = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/StackFrame.js"(exports2, module2) {
    "use strict";
    var StackFrame = (
      /** @class */
      function() {
        function StackFrame2() {
        }
        return StackFrame2;
      }()
    );
    module2.exports = StackFrame;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js
var require_Generated = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AvailabilityData = require_AvailabilityData();
    exports2.Base = require_Base();
    exports2.ContextTagKeys = require_ContextTagKeys();
    exports2.Data = require_Data();
    exports2.DataPoint = require_DataPoint();
    exports2.DataPointType = require_DataPointType();
    exports2.Domain = require_Domain();
    exports2.Envelope = require_Envelope();
    exports2.EventData = require_EventData();
    exports2.ExceptionData = require_ExceptionData();
    exports2.ExceptionDetails = require_ExceptionDetails();
    exports2.MessageData = require_MessageData();
    exports2.MetricData = require_MetricData();
    exports2.PageViewData = require_PageViewData();
    exports2.RemoteDependencyData = require_RemoteDependencyData();
    exports2.RequestData = require_RequestData();
    exports2.SeverityLevel = require_SeverityLevel();
    exports2.StackFrame = require_StackFrame();
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/Constants.js
var require_Constants = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/Constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.domainSupportsProperties = exports2.RemoteDependencyDataConstants = void 0;
    var Generated_1 = require_Generated();
    var RemoteDependencyDataConstants = (
      /** @class */
      function() {
        function RemoteDependencyDataConstants2() {
        }
        RemoteDependencyDataConstants2.TYPE_HTTP = "Http";
        RemoteDependencyDataConstants2.TYPE_AI = "Http (tracked component)";
        return RemoteDependencyDataConstants2;
      }()
    );
    exports2.RemoteDependencyDataConstants = RemoteDependencyDataConstants;
    function domainSupportsProperties(domain) {
      return "properties" in domain || // Do extra typechecks in case the type supports it but properties is null/undefined
      domain instanceof Generated_1.EventData || domain instanceof Generated_1.ExceptionData || domain instanceof Generated_1.MessageData || domain instanceof Generated_1.MetricData || domain instanceof Generated_1.PageViewData || domain instanceof Generated_1.RemoteDependencyData || domain instanceof Generated_1.RequestData;
    }
    exports2.domainSupportsProperties = domainSupportsProperties;
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/DependencyTelemetry.js
var require_DependencyTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/DependencyTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/EventTelemetry.js
var require_EventTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/EventTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/ExceptionTelemetry.js
var require_ExceptionTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/ExceptionTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/MetricTelemetry.js
var require_MetricTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/MetricTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/RequestTelemetry.js
var require_RequestTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/RequestTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TraceTelemetry.js
var require_TraceTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TraceTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/Telemetry.js
var require_Telemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/Telemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/NodeHttpDependencyTelemetry.js
var require_NodeHttpDependencyTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/NodeHttpDependencyTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/NodeHttpRequestTelemetry.js
var require_NodeHttpRequestTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/NodeHttpRequestTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/AvailabilityTelemetry.js
var require_AvailabilityTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/AvailabilityTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/PageViewTelemetry.js
var require_PageViewTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/PageViewTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/EnvelopeTelemetry.js
var require_EnvelopeTelemetry = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/EnvelopeTelemetry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js
var require_TelemetryType = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/TelemetryType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TelemetryType = exports2.TelemetryTypeString = exports2.baseTypeToTelemetryType = exports2.telemetryTypeToBaseType = void 0;
    function telemetryTypeToBaseType(type) {
      switch (type) {
        case TelemetryType.Event:
          return "EventData";
        case TelemetryType.Exception:
          return "ExceptionData";
        case TelemetryType.Trace:
          return "MessageData";
        case TelemetryType.Metric:
          return "MetricData";
        case TelemetryType.Request:
          return "RequestData";
        case TelemetryType.Dependency:
          return "RemoteDependencyData";
        case TelemetryType.Availability:
          return "AvailabilityData";
        case TelemetryType.PageView:
          return "PageViewData";
      }
      return void 0;
    }
    exports2.telemetryTypeToBaseType = telemetryTypeToBaseType;
    function baseTypeToTelemetryType(baseType) {
      switch (baseType) {
        case "EventData":
          return TelemetryType.Event;
        case "ExceptionData":
          return TelemetryType.Exception;
        case "MessageData":
          return TelemetryType.Trace;
        case "MetricData":
          return TelemetryType.Metric;
        case "RequestData":
          return TelemetryType.Request;
        case "RemoteDependencyData":
          return TelemetryType.Dependency;
        case "AvailabilityData":
          return TelemetryType.Availability;
        case "PageViewData":
          return TelemetryType.PageView;
      }
      return void 0;
    }
    exports2.baseTypeToTelemetryType = baseTypeToTelemetryType;
    exports2.TelemetryTypeString = {
      Event: "EventData",
      Exception: "ExceptionData",
      Trace: "MessageData",
      Metric: "MetricData",
      Request: "RequestData",
      Dependency: "RemoteDependencyData",
      Availability: "AvailabilityData",
      PageView: "PageViewData"
    };
    var TelemetryType;
    (function(TelemetryType2) {
      TelemetryType2[TelemetryType2["Event"] = 0] = "Event";
      TelemetryType2[TelemetryType2["Exception"] = 1] = "Exception";
      TelemetryType2[TelemetryType2["Trace"] = 2] = "Trace";
      TelemetryType2[TelemetryType2["Metric"] = 3] = "Metric";
      TelemetryType2[TelemetryType2["Request"] = 4] = "Request";
      TelemetryType2[TelemetryType2["Dependency"] = 5] = "Dependency";
      TelemetryType2[TelemetryType2["Availability"] = 6] = "Availability";
      TelemetryType2[TelemetryType2["PageView"] = 7] = "PageView";
    })(TelemetryType = exports2.TelemetryType || (exports2.TelemetryType = {}));
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js
var require_TelemetryTypes = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/TelemetryTypes/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_DependencyTelemetry(), exports2);
    __exportStar(require_EventTelemetry(), exports2);
    __exportStar(require_ExceptionTelemetry(), exports2);
    __exportStar(require_MetricTelemetry(), exports2);
    __exportStar(require_RequestTelemetry(), exports2);
    __exportStar(require_TraceTelemetry(), exports2);
    __exportStar(require_Telemetry(), exports2);
    __exportStar(require_NodeHttpDependencyTelemetry(), exports2);
    __exportStar(require_NodeHttpRequestTelemetry(), exports2);
    __exportStar(require_AvailabilityTelemetry(), exports2);
    __exportStar(require_PageViewTelemetry(), exports2);
    __exportStar(require_EnvelopeTelemetry(), exports2);
    __exportStar(require_TelemetryType(), exports2);
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/MetricQuickPulse.js
var require_MetricQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/MetricQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/EnvelopeQuickPulse.js
var require_EnvelopeQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/EnvelopeQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/DocumentQuickPulse.js
var require_DocumentQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/DocumentQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/ExceptionDocumentQuickPulse.js
var require_ExceptionDocumentQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/ExceptionDocumentQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/MessageDocumentQuickPulse.js
var require_MessageDocumentQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/MessageDocumentQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/DependencyDocumentQuickPulse.js
var require_DependencyDocumentQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/DependencyDocumentQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/RequestDocumentQuickPulse.js
var require_RequestDocumentQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/RequestDocumentQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/EventDocumentQuickPulse.js
var require_EventDocumentQuickPulse = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/EventDocumentQuickPulse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/index.js
var require_QuickPulseTypes = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/QuickPulseTypes/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_MetricQuickPulse(), exports2);
    __exportStar(require_EnvelopeQuickPulse(), exports2);
    __exportStar(require_DocumentQuickPulse(), exports2);
    __exportStar(require_ExceptionDocumentQuickPulse(), exports2);
    __exportStar(require_MessageDocumentQuickPulse(), exports2);
    __exportStar(require_DependencyDocumentQuickPulse(), exports2);
    __exportStar(require_RequestDocumentQuickPulse(), exports2);
    __exportStar(require_EventDocumentQuickPulse(), exports2);
  }
});

// node_modules/applicationinsights/out/Declarations/Contracts/index.js
var require_Contracts = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Contracts/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_Constants(), exports2);
    __exportStar(require_Generated(), exports2);
    __exportStar(require_TelemetryTypes(), exports2);
    __exportStar(require_QuickPulseTypes(), exports2);
  }
});

// node_modules/applicationinsights/out/AutoCollection/RequestParser.js
var require_RequestParser = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/RequestParser.js"(exports2, module2) {
    "use strict";
    var RequestParser = (
      /** @class */
      function() {
        function RequestParser2() {
        }
        RequestParser2.prototype.getUrl = function() {
          return this.url;
        };
        RequestParser2.prototype.RequestParser = function() {
          this.startTime = +/* @__PURE__ */ new Date();
        };
        RequestParser2.prototype._setStatus = function(status, error) {
          var endTime = +/* @__PURE__ */ new Date();
          this.duration = endTime - this.startTime;
          this.statusCode = status;
          var properties = this.properties || {};
          if (error) {
            if (typeof error === "string") {
              properties["error"] = error;
            } else if (error instanceof Error) {
              properties["error"] = error.message;
            } else if (typeof error === "object") {
              for (var key in error) {
                properties[key] = error[key] && error[key].toString && error[key].toString();
              }
            }
          }
          this.properties = properties;
        };
        RequestParser2.prototype._isSuccess = function() {
          return 0 < this.statusCode && this.statusCode < 400;
        };
        return RequestParser2;
      }()
    );
    module2.exports = RequestParser;
  }
});

// node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js
var require_HttpRequestParser = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/HttpRequestParser.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var url = require("url");
    var Contracts = require_Contracts();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var RequestParser = require_RequestParser();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Tracestate = require_Tracestate();
    var Traceparent = require_Traceparent();
    var HttpRequestParser = (
      /** @class */
      function(_super) {
        __extends2(HttpRequestParser2, _super);
        function HttpRequestParser2(request, requestId) {
          var _this = _super.call(this) || this;
          if (request) {
            _this.method = request.method;
            _this.url = _this._getAbsoluteUrl(request);
            _this.startTime = +/* @__PURE__ */ new Date();
            _this.socketRemoteAddress = request.socket && request.socket.remoteAddress;
            _this.parseHeaders(request, requestId);
            if (request.connection) {
              _this.connectionRemoteAddress = request.connection.remoteAddress;
              _this.legacySocketRemoteAddress = request.connection["socket"] && request.connection["socket"].remoteAddress;
            }
          }
          return _this;
        }
        HttpRequestParser2.prototype.onError = function(error, ellapsedMilliseconds) {
          this._setStatus(void 0, error);
          if (ellapsedMilliseconds) {
            this.duration = ellapsedMilliseconds;
          }
        };
        HttpRequestParser2.prototype.onResponse = function(response, ellapsedMilliseconds) {
          this._setStatus(response.statusCode, void 0);
          if (ellapsedMilliseconds) {
            this.duration = ellapsedMilliseconds;
          }
        };
        HttpRequestParser2.prototype.getRequestTelemetry = function(baseTelemetry) {
          var name2 = this.method;
          try {
            name2 += " " + new url.URL(this.url).pathname;
          } catch (ex) {
          }
          var requestTelemetry = {
            id: this.requestId,
            name: name2,
            url: this.url,
            /*
            See https://github.com/microsoft/ApplicationInsights-dotnet-server/blob/25d695e6a906fbe977f67be3966d25dbf1c50a79/Src/Web/Web.Shared.Net/RequestTrackingTelemetryModule.cs#L250
            for reference
            */
            source: this.sourceCorrelationId,
            duration: this.duration,
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            success: this._isSuccess(),
            properties: this.properties
          };
          if (baseTelemetry && baseTelemetry.time) {
            requestTelemetry.time = baseTelemetry.time;
          } else if (this.startTime) {
            requestTelemetry.time = new Date(this.startTime);
          }
          if (baseTelemetry) {
            for (var key in baseTelemetry) {
              if (!requestTelemetry[key]) {
                requestTelemetry[key] = baseTelemetry[key];
              }
            }
            if (baseTelemetry.properties) {
              for (var key in baseTelemetry.properties) {
                requestTelemetry.properties[key] = baseTelemetry.properties[key];
              }
            }
          }
          return requestTelemetry;
        };
        HttpRequestParser2.prototype.getRequestTags = function(tags) {
          var newTags = {};
          for (var key in tags) {
            newTags[key] = tags[key];
          }
          newTags[HttpRequestParser2.keys.locationIp] = tags[HttpRequestParser2.keys.locationIp] || this._getIp();
          newTags[HttpRequestParser2.keys.sessionId] = tags[HttpRequestParser2.keys.sessionId] || this._getId("ai_session");
          newTags[HttpRequestParser2.keys.userId] = tags[HttpRequestParser2.keys.userId] || this._getId("ai_user");
          newTags[HttpRequestParser2.keys.userAuthUserId] = tags[HttpRequestParser2.keys.userAuthUserId] || this._getId("ai_authUser");
          newTags[HttpRequestParser2.keys.operationName] = this.getOperationName(tags);
          newTags[HttpRequestParser2.keys.operationParentId] = this.getOperationParentId(tags);
          newTags[HttpRequestParser2.keys.operationId] = this.getOperationId(tags);
          return newTags;
        };
        HttpRequestParser2.prototype.getOperationId = function(tags) {
          return tags[HttpRequestParser2.keys.operationId] || this.operationId;
        };
        HttpRequestParser2.prototype.getOperationParentId = function(tags) {
          return tags[HttpRequestParser2.keys.operationParentId] || this.parentId || this.getOperationId(tags);
        };
        HttpRequestParser2.prototype.getOperationName = function(tags) {
          if (tags[HttpRequestParser2.keys.operationName]) {
            return tags[HttpRequestParser2.keys.operationName];
          }
          var pathName = "";
          try {
            pathName = new url.URL(this.url).pathname;
          } catch (ex) {
          }
          var operationName = this.method;
          if (pathName) {
            operationName += " " + pathName;
          }
          return operationName;
        };
        HttpRequestParser2.prototype.getRequestId = function() {
          return this.requestId;
        };
        HttpRequestParser2.prototype.getCorrelationContextHeader = function() {
          return this.correlationContextHeader;
        };
        HttpRequestParser2.prototype.getTraceparent = function() {
          return this.traceparent;
        };
        HttpRequestParser2.prototype.getTracestate = function() {
          return this.tracestate;
        };
        HttpRequestParser2.prototype.getLegacyRootId = function() {
          return this.legacyRootId;
        };
        HttpRequestParser2.prototype._getAbsoluteUrl = function(request) {
          if (!request.headers) {
            return request.url;
          }
          var encrypted = request.connection ? request.connection.encrypted : null;
          var protocol = encrypted || request.headers["x-forwarded-proto"] == "https" ? "https" : "http";
          var baseUrl = protocol + "://" + request.headers.host + "/";
          var pathName = "";
          var search = "";
          try {
            var requestUrl = new url.URL(request.url, baseUrl);
            pathName = requestUrl.pathname;
            search = requestUrl.search;
          } catch (ex) {
          }
          var absoluteUrl = url.format({
            protocol,
            host: request.headers.host,
            pathname: pathName,
            search
          });
          return absoluteUrl;
        };
        HttpRequestParser2.prototype._getIp = function() {
          var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/;
          var check = function(str) {
            var results = ipMatch.exec(str);
            if (results) {
              return results[0];
            }
          };
          var ip = check(this.rawHeaders["x-forwarded-for"]) || check(this.rawHeaders["x-client-ip"]) || check(this.rawHeaders["x-real-ip"]) || check(this.connectionRemoteAddress) || check(this.socketRemoteAddress) || check(this.legacySocketRemoteAddress);
          if (!ip && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && this.connectionRemoteAddress.substr(0, 2) === "::") {
            ip = "127.0.0.1";
          }
          return ip;
        };
        HttpRequestParser2.prototype._getId = function(name2) {
          var cookie = this.rawHeaders && this.rawHeaders["cookie"] && typeof this.rawHeaders["cookie"] === "string" && this.rawHeaders["cookie"] || "";
          var value = HttpRequestParser2.parseId(Util.getCookie(name2, cookie));
          return value;
        };
        HttpRequestParser2.prototype.setBackCompatFromThisTraceContext = function() {
          this.operationId = this.traceparent.traceId;
          if (this.traceparent.legacyRootId) {
            this.legacyRootId = this.traceparent.legacyRootId;
          }
          this.parentId = this.traceparent.parentId;
          this.traceparent.updateSpanId();
          this.requestId = this.traceparent.getBackCompatRequestId();
        };
        HttpRequestParser2.prototype.parseHeaders = function(request, requestId) {
          this.rawHeaders = request.headers || request.rawHeaders;
          this.userAgent = request.headers && request.headers["user-agent"];
          this.sourceCorrelationId = Util.getCorrelationContextTarget(request, RequestResponseHeaders.requestContextSourceKey);
          if (request.headers) {
            var tracestateHeader = request.headers[RequestResponseHeaders.traceStateHeader] ? request.headers[RequestResponseHeaders.traceStateHeader].toString() : null;
            var traceparentHeader = request.headers[RequestResponseHeaders.traceparentHeader] ? request.headers[RequestResponseHeaders.traceparentHeader].toString() : null;
            var requestIdHeader = request.headers[RequestResponseHeaders.requestIdHeader] ? request.headers[RequestResponseHeaders.requestIdHeader].toString() : null;
            var legacy_parentId = request.headers[RequestResponseHeaders.parentIdHeader] ? request.headers[RequestResponseHeaders.parentIdHeader].toString() : null;
            var legacy_rootId = request.headers[RequestResponseHeaders.rootIdHeader] ? request.headers[RequestResponseHeaders.rootIdHeader].toString() : null;
            this.correlationContextHeader = request.headers[RequestResponseHeaders.correlationContextHeader] ? request.headers[RequestResponseHeaders.correlationContextHeader].toString() : null;
            if (CorrelationIdManager.w3cEnabled && (traceparentHeader || tracestateHeader)) {
              this.traceparent = new Traceparent(traceparentHeader ? traceparentHeader.toString() : null);
              this.tracestate = traceparentHeader && tracestateHeader && new Tracestate(tracestateHeader ? tracestateHeader.toString() : null);
              this.setBackCompatFromThisTraceContext();
            } else if (requestIdHeader) {
              if (CorrelationIdManager.w3cEnabled) {
                this.traceparent = new Traceparent(null, requestIdHeader);
                this.setBackCompatFromThisTraceContext();
              } else {
                this.parentId = requestIdHeader;
                this.requestId = CorrelationIdManager.generateRequestId(this.parentId);
                this.operationId = CorrelationIdManager.getRootId(this.requestId);
              }
            } else {
              if (CorrelationIdManager.w3cEnabled) {
                this.traceparent = new Traceparent();
                this.traceparent.parentId = legacy_parentId;
                this.traceparent.legacyRootId = legacy_rootId || legacy_parentId;
                this.setBackCompatFromThisTraceContext();
              } else {
                this.parentId = legacy_parentId;
                this.requestId = CorrelationIdManager.generateRequestId(legacy_rootId || this.parentId);
                this.correlationContextHeader = null;
                this.operationId = CorrelationIdManager.getRootId(this.requestId);
              }
            }
            if (requestId) {
              this.requestId = requestId;
              this.operationId = CorrelationIdManager.getRootId(this.requestId);
            }
          }
        };
        HttpRequestParser2.parseId = function(cookieValue) {
          var cookieParts = cookieValue.split("|");
          if (cookieParts.length > 0) {
            return cookieParts[0];
          }
          return "";
        };
        HttpRequestParser2.keys = new Contracts.ContextTagKeys();
        return HttpRequestParser2;
      }(RequestParser)
    );
    module2.exports = HttpRequestParser;
  }
});

// node_modules/cls-hooked/node_modules/semver/semver.js
var require_semver3 = __commonJS({
  "node_modules/cls-hooked/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "\\d+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[COMPARATORTRIM]);
      range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
      var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(safeRe[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/shimmer/index.js
var require_shimmer = __commonJS({
  "node_modules/shimmer/index.js"(exports2, module2) {
    "use strict";
    function isFunction(funktion) {
      return typeof funktion === "function";
    }
    var logger = console.error.bind(console);
    function defineProperty(obj, name2, value) {
      var enumerable = !!obj[name2] && obj.propertyIsEnumerable(name2);
      Object.defineProperty(obj, name2, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function shimmer(options) {
      if (options && options.logger) {
        if (!isFunction(options.logger))
          logger("new logger isn't a function, not replacing");
        else
          logger = options.logger;
      }
    }
    function wrap(nodule, name2, wrapper) {
      if (!nodule || !nodule[name2]) {
        logger("no original function " + name2 + " to wrap");
        return;
      }
      if (!wrapper) {
        logger("no wrapper function");
        logger(new Error().stack);
        return;
      }
      if (!isFunction(nodule[name2]) || !isFunction(wrapper)) {
        logger("original object and wrapper must be functions");
        return;
      }
      var original = nodule[name2];
      var wrapped = wrapper(original, name2);
      defineProperty(wrapped, "__original", original);
      defineProperty(wrapped, "__unwrap", function() {
        if (nodule[name2] === wrapped)
          defineProperty(nodule, name2, original);
      });
      defineProperty(wrapped, "__wrapped", true);
      defineProperty(nodule, name2, wrapped);
      return wrapped;
    }
    function massWrap(nodules, names, wrapper) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to wrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name2) {
          wrap(nodule, name2, wrapper);
        });
      });
    }
    function unwrap(nodule, name2) {
      if (!nodule || !nodule[name2]) {
        logger("no function to unwrap.");
        logger(new Error().stack);
        return;
      }
      if (!nodule[name2].__unwrap) {
        logger("no original to unwrap to -- has " + name2 + " already been unwrapped?");
      } else {
        return nodule[name2].__unwrap();
      }
    }
    function massUnwrap(nodules, names) {
      if (!nodules) {
        logger("must provide one or more modules to patch");
        logger(new Error().stack);
        return;
      } else if (!Array.isArray(nodules)) {
        nodules = [nodules];
      }
      if (!(names && Array.isArray(names))) {
        logger("must provide one or more functions to unwrap on modules");
        return;
      }
      nodules.forEach(function(nodule) {
        names.forEach(function(name2) {
          unwrap(nodule, name2);
        });
      });
    }
    shimmer.wrap = wrap;
    shimmer.massWrap = massWrap;
    shimmer.unwrap = unwrap;
    shimmer.massUnwrap = massUnwrap;
    module2.exports = shimmer;
  }
});

// node_modules/emitter-listener/listener.js
var require_listener = __commonJS({
  "node_modules/emitter-listener/listener.js"(exports2, module2) {
    "use strict";
    var shimmer = require_shimmer();
    var wrap = shimmer.wrap;
    var unwrap = shimmer.unwrap;
    var SYMBOL = "wrap@before";
    function defineProperty(obj, name2, value) {
      var enumerable = !!obj[name2] && obj.propertyIsEnumerable(name2);
      Object.defineProperty(obj, name2, {
        configurable: true,
        enumerable,
        writable: true,
        value
      });
    }
    function _process(self2, listeners) {
      var l = listeners.length;
      for (var p = 0; p < l; p++) {
        var listener = listeners[p];
        var before = self2[SYMBOL];
        if (typeof before === "function") {
          before(listener);
        } else if (Array.isArray(before)) {
          var length = before.length;
          for (var i = 0; i < length; i++)
            before[i](listener);
        }
      }
    }
    function _listeners(self2, event) {
      var listeners;
      listeners = self2._events && self2._events[event];
      if (!Array.isArray(listeners)) {
        if (listeners) {
          listeners = [listeners];
        } else {
          listeners = [];
        }
      }
      return listeners;
    }
    function _findAndProcess(self2, event, before) {
      var after = _listeners(self2, event);
      var unprocessed = after.filter(function(fn) {
        return before.indexOf(fn) === -1;
      });
      if (unprocessed.length > 0)
        _process(self2, unprocessed);
    }
    function _wrap(unwrapped, visit) {
      if (!unwrapped)
        return;
      var wrapped = unwrapped;
      if (typeof unwrapped === "function") {
        wrapped = visit(unwrapped);
      } else if (Array.isArray(unwrapped)) {
        wrapped = [];
        for (var i = 0; i < unwrapped.length; i++) {
          wrapped[i] = visit(unwrapped[i]);
        }
      }
      return wrapped;
    }
    module2.exports = function wrapEmitter(emitter, onAddListener, onEmit) {
      if (!emitter || !emitter.on || !emitter.addListener || !emitter.removeListener || !emitter.emit) {
        throw new Error("can only wrap real EEs");
      }
      if (!onAddListener)
        throw new Error("must have function to run on listener addition");
      if (!onEmit)
        throw new Error("must have function to wrap listeners when emitting");
      function adding(on) {
        return function added(event, listener) {
          var existing = _listeners(this, event).slice();
          try {
            var returned = on.call(this, event, listener);
            _findAndProcess(this, event, existing);
            return returned;
          } finally {
            if (!this.on.__wrapped)
              wrap(this, "on", adding);
            if (!this.addListener.__wrapped)
              wrap(this, "addListener", adding);
          }
        };
      }
      function emitting(emit) {
        return function emitted(event) {
          if (!this._events || !this._events[event])
            return emit.apply(this, arguments);
          var unwrapped = this._events[event];
          function remover(removeListener) {
            return function removed() {
              this._events[event] = unwrapped;
              try {
                return removeListener.apply(this, arguments);
              } finally {
                unwrapped = this._events[event];
                this._events[event] = _wrap(unwrapped, onEmit);
              }
            };
          }
          wrap(this, "removeListener", remover);
          try {
            this._events[event] = _wrap(unwrapped, onEmit);
            return emit.apply(this, arguments);
          } finally {
            unwrap(this, "removeListener");
            this._events[event] = unwrapped;
          }
        };
      }
      if (!emitter[SYMBOL]) {
        defineProperty(emitter, SYMBOL, onAddListener);
      } else if (typeof emitter[SYMBOL] === "function") {
        defineProperty(emitter, SYMBOL, [emitter[SYMBOL], onAddListener]);
      } else if (Array.isArray(emitter[SYMBOL])) {
        emitter[SYMBOL].push(onAddListener);
      }
      if (!emitter.__wrapped) {
        wrap(emitter, "addListener", adding);
        wrap(emitter, "on", adding);
        wrap(emitter, "emit", emitting);
        defineProperty(emitter, "__unwrap", function() {
          unwrap(emitter, "addListener");
          unwrap(emitter, "on");
          unwrap(emitter, "emit");
          delete emitter[SYMBOL];
          delete emitter.__wrapped;
        });
        defineProperty(emitter, "__wrapped", true);
      }
    };
  }
});

// node_modules/cls-hooked/context.js
var require_context3 = __commonJS({
  "node_modules/cls-hooked/context.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var assert = require("assert");
    var wrapEmitter = require_listener();
    var async_hooks = require("async_hooks");
    var CONTEXTS_SYMBOL = "cls@contexts";
    var ERROR_SYMBOL = "error@context";
    var DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;
    var currentUid = -1;
    module2.exports = {
      getNamespace,
      createNamespace,
      destroyNamespace,
      reset,
      ERROR_SYMBOL
    };
    function Namespace(name2) {
      this.name = name2;
      this.active = null;
      this._set = [];
      this.id = null;
      this._contexts = /* @__PURE__ */ new Map();
      this._indent = 0;
    }
    Namespace.prototype.set = function set(key, value) {
      if (!this.active) {
        throw new Error("No context available. ns.run() or ns.bind() must be called first.");
      }
      this.active[key] = value;
      if (DEBUG_CLS_HOOKED) {
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(indentStr + "CONTEXT-SET KEY:" + key + "=" + value + " in ns:" + this.name + " currentUid:" + currentUid + " active:" + util.inspect(this.active, { showHidden: true, depth: 2, colors: true }));
      }
      return value;
    };
    Namespace.prototype.get = function get(key) {
      if (!this.active) {
        if (DEBUG_CLS_HOOKED) {
          const asyncHooksCurrentId = async_hooks.currentId();
          const triggerId = async_hooks.triggerAsyncId();
          const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
          debug2(`${indentStr}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${key}=undefined currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length}`);
        }
        return void 0;
      }
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(indentStr + "CONTEXT-GETTING KEY:" + key + "=" + this.active[key] + " (" + this.name + ") currentUid:" + currentUid + " active:" + util.inspect(this.active, { showHidden: true, depth: 2, colors: true }));
        debug2(`${indentStr}CONTEXT-GETTING KEY: (${this.name}) ${key}=${this.active[key]} currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} active:${util.inspect(this.active)}`);
      }
      return this.active[key];
    };
    Namespace.prototype.createContext = function createContext() {
      let context = Object.create(this.active ? this.active : Object.prototype);
      context._ns_name = this.name;
      context.id = currentUid;
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-CREATED Context: (${this.name}) currentUid:${currentUid} asyncHooksCurrentId:${asyncHooksCurrentId} triggerId:${triggerId} len:${this._set.length} context:${util.inspect(context, { showHidden: true, depth: 2, colors: true })}`);
      }
      return context;
    };
    Namespace.prototype.run = function run(fn) {
      let context = this.createContext();
      this.enter(context);
      try {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          const asyncHooksCurrentId = async_hooks.executionAsyncId();
          const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
          debug2(`${indentStr}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} context:${util.inspect(context)}`);
        }
        fn(context);
        return context;
      } catch (exception) {
        if (exception) {
          exception[ERROR_SYMBOL] = context;
        }
        throw exception;
      } finally {
        if (DEBUG_CLS_HOOKED) {
          const triggerId = async_hooks.triggerAsyncId();
          const asyncHooksCurrentId = async_hooks.executionAsyncId();
          const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
          debug2(`${indentStr}CONTEXT-RUN END: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
        }
        this.exit(context);
      }
    };
    Namespace.prototype.runAndReturn = function runAndReturn(fn) {
      let value;
      this.run(function(context) {
        value = fn(context);
      });
      return value;
    };
    Namespace.prototype.runPromise = function runPromise(fn) {
      let context = this.createContext();
      this.enter(context);
      let promise = fn(context);
      if (!promise || !promise.then || !promise.catch) {
        throw new Error("fn must return a promise.");
      }
      if (DEBUG_CLS_HOOKED) {
        debug2("CONTEXT-runPromise BEFORE: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
      }
      return promise.then((result) => {
        if (DEBUG_CLS_HOOKED) {
          debug2("CONTEXT-runPromise AFTER then: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        return result;
      }).catch((err) => {
        err[ERROR_SYMBOL] = context;
        if (DEBUG_CLS_HOOKED) {
          debug2("CONTEXT-runPromise AFTER catch: (" + this.name + ") currentUid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        throw err;
      });
    };
    Namespace.prototype.bind = function bindFactory(fn, context) {
      if (!context) {
        if (!this.active) {
          context = this.createContext();
        } else {
          context = this.active;
        }
      }
      let self2 = this;
      return function clsBind() {
        self2.enter(context);
        try {
          return fn.apply(this, arguments);
        } catch (exception) {
          if (exception) {
            exception[ERROR_SYMBOL] = context;
          }
          throw exception;
        } finally {
          self2.exit(context);
        }
      };
    };
    Namespace.prototype.enter = function enter(context) {
      assert.ok(context, "context must be provided for entering");
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-ENTER: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
      }
      this._set.push(this.active);
      this.active = context;
    };
    Namespace.prototype.exit = function exit(context) {
      assert.ok(context, "context must be provided for exiting");
      if (DEBUG_CLS_HOOKED) {
        const asyncHooksCurrentId = async_hooks.executionAsyncId();
        const triggerId = async_hooks.triggerAsyncId();
        const indentStr = " ".repeat(this._indent < 0 ? 0 : this._indent);
        debug2(`${indentStr}CONTEXT-EXIT: (${this.name}) currentUid:${currentUid} triggerId:${triggerId} asyncHooksCurrentId:${asyncHooksCurrentId} len:${this._set.length} ${util.inspect(context)}`);
      }
      if (this.active === context) {
        assert.ok(this._set.length, "can't remove top context");
        this.active = this._set.pop();
        return;
      }
      let index = this._set.lastIndexOf(context);
      if (index < 0) {
        if (DEBUG_CLS_HOOKED) {
          debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context));
        }
        assert.ok(index >= 0, "context not currently entered; can't exit. \n" + util.inspect(this) + "\n" + util.inspect(context));
      } else {
        assert.ok(index, "can't remove top context");
        this._set.splice(index, 1);
      }
    };
    Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
      assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
      let namespace = this;
      let thisSymbol = "context@" + this.name;
      function attach(listener) {
        if (!listener) {
          return;
        }
        if (!listener[CONTEXTS_SYMBOL]) {
          listener[CONTEXTS_SYMBOL] = /* @__PURE__ */ Object.create(null);
        }
        listener[CONTEXTS_SYMBOL][thisSymbol] = {
          namespace,
          context: namespace.active
        };
      }
      function bind(unwrapped) {
        if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
          return unwrapped;
        }
        let wrapped = unwrapped;
        let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
        Object.keys(unwrappedContexts).forEach(function(name2) {
          let thunk = unwrappedContexts[name2];
          wrapped = thunk.namespace.bind(wrapped, thunk.context);
        });
        return wrapped;
      }
      wrapEmitter(emitter, attach, bind);
    };
    Namespace.prototype.fromException = function fromException(exception) {
      return exception[ERROR_SYMBOL];
    };
    function getNamespace(name2) {
      return process.namespaces[name2];
    }
    function createNamespace(name2) {
      assert.ok(name2, "namespace must be given a name.");
      if (DEBUG_CLS_HOOKED) {
        debug2(`NS-CREATING NAMESPACE (${name2})`);
      }
      let namespace = new Namespace(name2);
      namespace.id = currentUid;
      const hook = async_hooks.createHook({
        init(asyncId, type, triggerId, resource) {
          currentUid = async_hooks.executionAsyncId();
          if (namespace.active) {
            namespace._contexts.set(asyncId, namespace.active);
            if (DEBUG_CLS_HOOKED) {
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}INIT [${type}] (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
            }
          } else if (currentUid === 0) {
            const triggerId2 = async_hooks.triggerAsyncId();
            const triggerIdContext = namespace._contexts.get(triggerId2);
            if (triggerIdContext) {
              namespace._contexts.set(asyncId, triggerIdContext);
              if (DEBUG_CLS_HOOKED) {
                const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
                debug2(`${indentStr}INIT USING CONTEXT FROM TRIGGERID [${type}] (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId2} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
              }
            } else if (DEBUG_CLS_HOOKED) {
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}INIT MISSING CONTEXT [${type}] (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId2} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
            }
          }
          if (DEBUG_CLS_HOOKED && type === "PROMISE") {
            debug2(util.inspect(resource, { showHidden: true }));
            const parentId = resource.parentId;
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}INIT RESOURCE-PROMISE [${type}] (${name2}) parentId:${parentId} asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} resource:${resource}`);
          }
        },
        before(asyncId) {
          currentUid = async_hooks.executionAsyncId();
          let context;
          context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              const triggerId = async_hooks.triggerAsyncId();
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}BEFORE (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(context)}`);
              namespace._indent += 2;
            }
            namespace.enter(context);
          } else if (DEBUG_CLS_HOOKED) {
            const triggerId = async_hooks.triggerAsyncId();
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}BEFORE MISSING CONTEXT (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} namespace._contexts:${util.inspect(namespace._contexts, { showHidden: true, depth: 2, colors: true })}`);
            namespace._indent += 2;
          }
        },
        after(asyncId) {
          currentUid = async_hooks.executionAsyncId();
          let context;
          context = namespace._contexts.get(asyncId) || namespace._contexts.get(currentUid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              const triggerId = async_hooks.triggerAsyncId();
              namespace._indent -= 2;
              const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
              debug2(`${indentStr}AFTER (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(context)}`);
            }
            namespace.exit(context);
          } else if (DEBUG_CLS_HOOKED) {
            const triggerId = async_hooks.triggerAsyncId();
            namespace._indent -= 2;
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}AFTER MISSING CONTEXT (${name2}) asyncId:${asyncId} currentUid:${currentUid} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(context)}`);
          }
        },
        destroy(asyncId) {
          currentUid = async_hooks.executionAsyncId();
          if (DEBUG_CLS_HOOKED) {
            const triggerId = async_hooks.triggerAsyncId();
            const indentStr = " ".repeat(namespace._indent < 0 ? 0 : namespace._indent);
            debug2(`${indentStr}DESTROY (${name2}) currentUid:${currentUid} asyncId:${asyncId} triggerId:${triggerId} active:${util.inspect(namespace.active, { showHidden: true, depth: 2, colors: true })} context:${util.inspect(namespace._contexts.get(currentUid))}`);
          }
          namespace._contexts.delete(asyncId);
        }
      });
      hook.enable();
      process.namespaces[name2] = namespace;
      return namespace;
    }
    function destroyNamespace(name2) {
      let namespace = getNamespace(name2);
      assert.ok(namespace, `can't delete nonexistent namespace! "` + name2 + '"');
      assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace));
      process.namespaces[name2] = null;
    }
    function reset() {
      if (process.namespaces) {
        Object.keys(process.namespaces).forEach(function(name2) {
          destroyNamespace(name2);
        });
      }
      process.namespaces = /* @__PURE__ */ Object.create(null);
    }
    process.namespaces = {};
    function debug2(...args) {
      if (DEBUG_CLS_HOOKED) {
        process._rawDebug(`${util.format(...args)}`);
      }
    }
  }
});

// node_modules/async-hook-jl/patches/next-tick.js
var require_next_tick = __commonJS({
  "node_modules/async-hook-jl/patches/next-tick.js"(exports2, module2) {
    "use strict";
    function NextTickWrap() {
    }
    module2.exports = function patch() {
      const hooks = this._hooks;
      const state = this._state;
      const oldNextTick = process.nextTick;
      process.nextTick = function() {
        if (!state.enabled)
          return oldNextTick.apply(process, arguments);
        const args = new Array(arguments.length);
        for (let i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        const callback = args[0];
        if (typeof callback !== "function") {
          throw new TypeError("callback is not a function");
        }
        const handle = new NextTickWrap();
        const uid = --state.counter;
        hooks.init.call(handle, uid, 0, null, null);
        args[0] = function() {
          hooks.pre.call(handle, uid);
          let didThrow = true;
          try {
            callback.apply(this, arguments);
            didThrow = false;
          } finally {
            if (didThrow && process.listenerCount("uncaughtException") > 0) {
              process.once("uncaughtException", function() {
                hooks.post.call(handle, uid, true);
                hooks.destroy.call(null, uid);
              });
            }
          }
          hooks.post.call(handle, uid, false);
          hooks.destroy.call(null, uid);
        };
        return oldNextTick.apply(process, args);
      };
    };
  }
});

// node_modules/async-hook-jl/patches/promise.js
var require_promise2 = __commonJS({
  "node_modules/async-hook-jl/patches/promise.js"(exports2, module2) {
    "use strict";
    function PromiseWrap() {
    }
    module2.exports = function patchPromise() {
      const hooks = this._hooks;
      const state = this._state;
      const Promise2 = global.Promise;
      const oldThen = Promise2.prototype.then;
      Promise2.prototype.then = wrappedThen;
      function makeWrappedHandler(fn, handle, uid, isOnFulfilled) {
        if ("function" !== typeof fn) {
          return isOnFulfilled ? makeUnhandledResolutionHandler(uid) : makeUnhandledRejectionHandler(uid);
        }
        return function wrappedHandler() {
          hooks.pre.call(handle, uid);
          try {
            return fn.apply(this, arguments);
          } finally {
            hooks.post.call(handle, uid, false);
            hooks.destroy.call(null, uid);
          }
        };
      }
      function makeUnhandledResolutionHandler(uid) {
        return function unhandledResolutionHandler(val) {
          hooks.destroy.call(null, uid);
          return val;
        };
      }
      function makeUnhandledRejectionHandler(uid) {
        return function unhandledRejectedHandler(val) {
          hooks.destroy.call(null, uid);
          throw val;
        };
      }
      function wrappedThen(onFulfilled, onRejected) {
        if (!state.enabled)
          return oldThen.call(this, onFulfilled, onRejected);
        const handle = new PromiseWrap();
        const uid = --state.counter;
        hooks.init.call(handle, uid, 0, null, null);
        return oldThen.call(
          this,
          makeWrappedHandler(onFulfilled, handle, uid, true),
          makeWrappedHandler(onRejected, handle, uid, false)
        );
      }
    };
  }
});

// node_modules/async-hook-jl/patches/timers.js
var require_timers = __commonJS({
  "node_modules/async-hook-jl/patches/timers.js"(exports2, module2) {
    "use strict";
    var timers = require("timers");
    function TimeoutWrap() {
    }
    function IntervalWrap() {
    }
    function ImmediateWrap() {
    }
    var timeoutMap = /* @__PURE__ */ new Map();
    var intervalMap = /* @__PURE__ */ new Map();
    var ImmediateMap = /* @__PURE__ */ new Map();
    var activeCallback = null;
    var clearedInCallback = false;
    module2.exports = function patch() {
      patchTimer(this._hooks, this._state, "setTimeout", "clearTimeout", TimeoutWrap, timeoutMap, true);
      patchTimer(this._hooks, this._state, "setInterval", "clearInterval", IntervalWrap, intervalMap, false);
      patchTimer(this._hooks, this._state, "setImmediate", "clearImmediate", ImmediateWrap, ImmediateMap, true);
      global.setTimeout = timers.setTimeout;
      global.setInterval = timers.setInterval;
      global.setImmediate = timers.setImmediate;
      global.clearTimeout = timers.clearTimeout;
      global.clearInterval = timers.clearInterval;
      global.clearImmediate = timers.clearImmediate;
    };
    function patchTimer(hooks, state, setFn, clearFn, Handle, timerMap, singleCall) {
      const oldSetFn = timers[setFn];
      const oldClearFn = timers[clearFn];
      timers[setFn] = function() {
        if (!state.enabled)
          return oldSetFn.apply(timers, arguments);
        const args = new Array(arguments.length);
        for (let i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        const callback = args[0];
        if (typeof callback !== "function") {
          throw new TypeError('"callback" argument must be a function');
        }
        const handle = new Handle();
        const uid = --state.counter;
        let timerId = void 0;
        hooks.init.call(handle, uid, 0, null, null);
        args[0] = function() {
          activeCallback = timerId;
          hooks.pre.call(handle, uid);
          let didThrow = true;
          try {
            callback.apply(this, arguments);
            didThrow = false;
          } finally {
            if (didThrow && process.listenerCount("uncaughtException") > 0) {
              process.once("uncaughtException", function() {
                hooks.post.call(handle, uid, true);
                timerMap.delete(timerId);
                hooks.destroy.call(null, uid);
              });
            }
          }
          hooks.post.call(handle, uid, false);
          activeCallback = null;
          if (singleCall || clearedInCallback) {
            clearedInCallback = false;
            timerMap.delete(timerId);
            hooks.destroy.call(null, uid);
          }
        };
        timerId = oldSetFn.apply(timers, args);
        timerMap.set(timerId, uid);
        return timerId;
      };
      timers[clearFn] = function(timerId) {
        if (activeCallback === timerId && timerId !== null) {
          clearedInCallback = true;
        } else if (timerMap.has(timerId)) {
          const uid = timerMap.get(timerId);
          timerMap.delete(timerId);
          hooks.destroy.call(null, uid);
        }
        oldClearFn.apply(timers, arguments);
      };
    }
  }
});

// node_modules/async-hook-jl/package.json
var require_package2 = __commonJS({
  "node_modules/async-hook-jl/package.json"(exports2, module2) {
    module2.exports = {
      name: "async-hook-jl",
      description: "Inspect the life of handle objects in node",
      version: "1.7.6",
      author: "Andreas Madsen <amwebdk@gmail.com>",
      main: "./index.js",
      scripts: {
        test: "node ./test/runner.js && eslint ."
      },
      repository: {
        type: "git",
        url: "git://github.com/jeff-lewis/async-hook-jl.git"
      },
      keywords: [
        "async",
        "async hooks",
        "inspect",
        "async wrap"
      ],
      license: "MIT",
      dependencies: {
        "stack-chain": "^1.3.7"
      },
      devDependencies: {
        async: "1.5.x",
        "cli-color": "1.1.x",
        eslint: "^3.4.0",
        endpoint: "0.4.x"
      },
      engines: {
        node: "^4.7 || >=6.9 || >=7.3"
      }
    };
  }
});

// node_modules/async-hook-jl/async-hook.js
var require_async_hook = __commonJS({
  "node_modules/async-hook-jl/async-hook.js"(exports2, module2) {
    "use strict";
    var asyncWrap = process.binding("async_wrap");
    var TIMERWRAP = asyncWrap.Providers.TIMERWRAP;
    var patchs = {
      "nextTick": require_next_tick(),
      "promise": require_promise2(),
      "timers": require_timers()
    };
    var ignoreUIDs = /* @__PURE__ */ new Set();
    function State() {
      this.enabled = false;
      this.counter = 0;
    }
    function Hooks() {
      const initFns = this.initFns = [];
      const preFns = this.preFns = [];
      const postFns = this.postFns = [];
      const destroyFns = this.destroyFns = [];
      this.init = function(uid, provider, parentUid, parentHandle) {
        if (provider === TIMERWRAP) {
          ignoreUIDs.add(uid);
          return;
        }
        for (const hook of initFns) {
          hook(uid, this, provider, parentUid, parentHandle);
        }
      };
      this.pre = function(uid) {
        if (ignoreUIDs.has(uid))
          return;
        for (const hook of preFns) {
          hook(uid, this);
        }
      };
      this.post = function(uid, didThrow) {
        if (ignoreUIDs.has(uid))
          return;
        for (const hook of postFns) {
          hook(uid, this, didThrow);
        }
      };
      this.destroy = function(uid) {
        if (ignoreUIDs.has(uid)) {
          ignoreUIDs.delete(uid);
          return;
        }
        for (const hook of destroyFns) {
          hook(uid);
        }
      };
    }
    Hooks.prototype.add = function(hooks) {
      if (hooks.init)
        this.initFns.push(hooks.init);
      if (hooks.pre)
        this.preFns.push(hooks.pre);
      if (hooks.post)
        this.postFns.push(hooks.post);
      if (hooks.destroy)
        this.destroyFns.push(hooks.destroy);
    };
    function removeElement(array, item) {
      const index = array.indexOf(item);
      if (index === -1)
        return;
      array.splice(index, 1);
    }
    Hooks.prototype.remove = function(hooks) {
      if (hooks.init)
        removeElement(this.initFns, hooks.init);
      if (hooks.pre)
        removeElement(this.preFns, hooks.pre);
      if (hooks.post)
        removeElement(this.postFns, hooks.post);
      if (hooks.destroy)
        removeElement(this.destroyFns, hooks.destroy);
    };
    function AsyncHook() {
      this._state = new State();
      this._hooks = new Hooks();
      this.version = require_package2().version;
      this.providers = asyncWrap.Providers;
      for (const key of Object.keys(patchs)) {
        patchs[key].call(this);
      }
      if (process.env.hasOwnProperty("NODE_ASYNC_HOOK_WARNING")) {
        console.warn("warning: you are using async-hook-jl which is unstable.");
      }
      asyncWrap.setupHooks({
        init: this._hooks.init,
        pre: this._hooks.pre,
        post: this._hooks.post,
        destroy: this._hooks.destroy
      });
    }
    module2.exports = AsyncHook;
    AsyncHook.prototype.addHooks = function(hooks) {
      this._hooks.add(hooks);
    };
    AsyncHook.prototype.removeHooks = function(hooks) {
      this._hooks.remove(hooks);
    };
    AsyncHook.prototype.enable = function() {
      this._state.enabled = true;
      asyncWrap.enable();
    };
    AsyncHook.prototype.disable = function() {
      this._state.enabled = false;
      asyncWrap.disable();
    };
  }
});

// node_modules/stack-chain/package.json
var require_package3 = __commonJS({
  "node_modules/stack-chain/package.json"(exports2, module2) {
    module2.exports = {
      name: "stack-chain",
      description: "API for combining call site modifiers",
      version: "1.3.7",
      author: "Andreas Madsen <amwebdk@gmail.com>",
      scripts: {
        test: "tap ./test/simple"
      },
      repository: {
        type: "git",
        url: "git://github.com/AndreasMadsen/stack-chain.git"
      },
      keywords: [
        "stack",
        "chain",
        "trace",
        "call site",
        "concat",
        "format"
      ],
      devDependencies: {
        tap: "2.x.x",
        "uglify-js": "2.5.x"
      },
      license: "MIT"
    };
  }
});

// node_modules/stack-chain/format.js
var require_format = __commonJS({
  "node_modules/stack-chain/format.js"(exports2, module2) {
    function FormatErrorString(error) {
      try {
        return Error.prototype.toString.call(error);
      } catch (e) {
        try {
          return "<error: " + e + ">";
        } catch (ee) {
          return "<error>";
        }
      }
    }
    module2.exports = function FormatStackTrace(error, frames) {
      var lines = [];
      lines.push(FormatErrorString(error));
      for (var i = 0; i < frames.length; i++) {
        var frame = frames[i];
        var line;
        try {
          line = frame.toString();
        } catch (e) {
          try {
            line = "<error: " + e + ">";
          } catch (ee) {
            line = "<error>";
          }
        }
        lines.push("    at " + line);
      }
      return lines.join("\n");
    };
  }
});

// node_modules/stack-chain/stack-chain.js
var require_stack_chain = __commonJS({
  "node_modules/stack-chain/stack-chain.js"(exports2, module2) {
    var defaultFormater = require_format();
    function stackChain() {
      this.extend = new TraceModifier();
      this.filter = new TraceModifier();
      this.format = new StackFormater();
      this.version = require_package3().version;
    }
    var SHORTCIRCUIT_CALLSITE = false;
    stackChain.prototype.callSite = function collectCallSites(options) {
      if (!options)
        options = {};
      SHORTCIRCUIT_CALLSITE = true;
      var obj = {};
      Error.captureStackTrace(obj, collectCallSites);
      var callSites = obj.stack;
      SHORTCIRCUIT_CALLSITE = false;
      callSites = callSites.slice(options.slice || 0);
      if (options.extend)
        callSites = this.extend._modify(obj, callSites);
      if (options.filter)
        callSites = this.filter._modify(obj, callSites);
      return callSites;
    };
    var chain = new stackChain();
    function TraceModifier() {
      this._modifiers = [];
    }
    TraceModifier.prototype._modify = function(error, frames) {
      for (var i = 0, l = this._modifiers.length; i < l; i++) {
        frames = this._modifiers[i](error, frames);
      }
      return frames;
    };
    TraceModifier.prototype.attach = function(modifier) {
      this._modifiers.push(modifier);
    };
    TraceModifier.prototype.deattach = function(modifier) {
      var index = this._modifiers.indexOf(modifier);
      if (index === -1)
        return false;
      this._modifiers.splice(index, 1);
      return true;
    };
    function StackFormater() {
      this._formater = defaultFormater;
      this._previous = void 0;
    }
    StackFormater.prototype.replace = function(formater) {
      if (formater) {
        this._formater = formater;
      } else {
        this.restore();
      }
    };
    StackFormater.prototype.restore = function() {
      this._formater = defaultFormater;
      this._previous = void 0;
    };
    StackFormater.prototype._backup = function() {
      this._previous = this._formater;
    };
    StackFormater.prototype._roolback = function() {
      if (this._previous === defaultFormater) {
        this.replace(void 0);
      } else {
        this.replace(this._previous);
      }
      this._previous = void 0;
    };
    if (Error.prepareStackTrace) {
      chain.format.replace(Error.prepareStackTrace);
    }
    var SHORTCIRCUIT_FORMATER = false;
    function prepareStackTrace(error, originalFrames) {
      if (SHORTCIRCUIT_CALLSITE)
        return originalFrames;
      if (SHORTCIRCUIT_FORMATER)
        return defaultFormater(error, originalFrames);
      var frames = originalFrames.concat();
      frames = chain.extend._modify(error, frames);
      frames = chain.filter._modify(error, frames);
      frames = frames.slice(0, Error.stackTraceLimit);
      if (Object.isExtensible(error) && Object.getOwnPropertyDescriptor(error, "callSite") === void 0) {
        error.callSite = {
          original: originalFrames,
          mutated: frames
        };
      }
      SHORTCIRCUIT_FORMATER = true;
      var format = chain.format._formater(error, frames);
      SHORTCIRCUIT_FORMATER = false;
      return format;
    }
    Object.defineProperty(Error, "prepareStackTrace", {
      "get": function() {
        return prepareStackTrace;
      },
      "set": function(formater) {
        if (formater === prepareStackTrace) {
          chain.format._roolback();
        } else {
          chain.format._backup();
          chain.format.replace(formater);
        }
      }
    });
    function callSiteGetter() {
      this.stack;
      return this.callSite;
    }
    Object.defineProperty(Error.prototype, "callSite", {
      "get": callSiteGetter,
      "set": function(frames) {
        Object.defineProperty(this, "callSite", {
          value: frames,
          writable: true,
          configurable: true
        });
      },
      configurable: true
    });
    module2.exports = chain;
  }
});

// node_modules/stack-chain/index.js
var require_stack_chain2 = __commonJS({
  "node_modules/stack-chain/index.js"(exports2, module2) {
    if (global._stackChain) {
      if (global._stackChain.version === require_package3().version) {
        module2.exports = global._stackChain;
      } else {
        throw new Error("Conflicting version of stack-chain found");
      }
    } else {
      module2.exports = global._stackChain = require_stack_chain();
    }
  }
});

// node_modules/async-hook-jl/index.js
var require_async_hook_jl = __commonJS({
  "node_modules/async-hook-jl/index.js"(exports2, module2) {
    "use strict";
    var AsyncHook = require_async_hook();
    if (global._asyncHook) {
      if (global._asyncHook.version === require_package2().version) {
        module2.exports = global._asyncHook;
      } else {
        throw new Error("Conflicting version of async-hook-jl found");
      }
    } else {
      const stackChain = require_stack_chain2();
      stackChain.filter.attach(function(error, frames) {
        return frames.filter(function(callSite) {
          const filename = callSite.getFileName();
          return !(filename && filename.slice(0, __dirname.length) === __dirname);
        });
      });
      module2.exports = global._asyncHook = new AsyncHook();
    }
  }
});

// node_modules/cls-hooked/context-legacy.js
var require_context_legacy = __commonJS({
  "node_modules/cls-hooked/context-legacy.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var assert = require("assert");
    var wrapEmitter = require_listener();
    var asyncHook = require_async_hook_jl();
    var CONTEXTS_SYMBOL = "cls@contexts";
    var ERROR_SYMBOL = "error@context";
    var invertedProviders = [];
    for (let key in asyncHook.providers) {
      invertedProviders[asyncHook.providers[key]] = key;
    }
    var DEBUG_CLS_HOOKED = process.env.DEBUG_CLS_HOOKED;
    var currentUid = -1;
    module2.exports = {
      getNamespace,
      createNamespace,
      destroyNamespace,
      reset,
      //trace: trace,
      ERROR_SYMBOL
    };
    function Namespace(name2) {
      this.name = name2;
      this.active = null;
      this._set = [];
      this.id = null;
      this._contexts = /* @__PURE__ */ new Map();
    }
    Namespace.prototype.set = function set(key, value) {
      if (!this.active) {
        throw new Error("No context available. ns.run() or ns.bind() must be called first.");
      }
      if (DEBUG_CLS_HOOKED) {
        debug2("    SETTING KEY:" + key + "=" + value + " in ns:" + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, true));
      }
      this.active[key] = value;
      return value;
    };
    Namespace.prototype.get = function get(key) {
      if (!this.active) {
        if (DEBUG_CLS_HOOKED) {
          debug2("    GETTING KEY:" + key + "=undefined " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, true));
        }
        return void 0;
      }
      if (DEBUG_CLS_HOOKED) {
        debug2("    GETTING KEY:" + key + "=" + this.active[key] + " " + this.name + " uid:" + currentUid + " active:" + util.inspect(this.active, true));
      }
      return this.active[key];
    };
    Namespace.prototype.createContext = function createContext() {
      if (DEBUG_CLS_HOOKED) {
        debug2("   CREATING Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  active:" + util.inspect(this.active, true, 2, true));
      }
      let context = Object.create(this.active ? this.active : Object.prototype);
      context._ns_name = this.name;
      context.id = currentUid;
      if (DEBUG_CLS_HOOKED) {
        debug2("   CREATED Context: " + this.name + " uid:" + currentUid + " len:" + this._set.length + "  context:" + util.inspect(context, true, 2, true));
      }
      return context;
    };
    Namespace.prototype.run = function run(fn) {
      let context = this.createContext();
      this.enter(context);
      try {
        if (DEBUG_CLS_HOOKED) {
          debug2(" BEFORE RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        fn(context);
        return context;
      } catch (exception) {
        if (exception) {
          exception[ERROR_SYMBOL] = context;
        }
        throw exception;
      } finally {
        if (DEBUG_CLS_HOOKED) {
          debug2(" AFTER RUN: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
      }
    };
    Namespace.prototype.runAndReturn = function runAndReturn(fn) {
      var value;
      this.run(function(context) {
        value = fn(context);
      });
      return value;
    };
    Namespace.prototype.runPromise = function runPromise(fn) {
      let context = this.createContext();
      this.enter(context);
      let promise = fn(context);
      if (!promise || !promise.then || !promise.catch) {
        throw new Error("fn must return a promise.");
      }
      if (DEBUG_CLS_HOOKED) {
        debug2(" BEFORE runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
      }
      return promise.then((result) => {
        if (DEBUG_CLS_HOOKED) {
          debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        return result;
      }).catch((err) => {
        err[ERROR_SYMBOL] = context;
        if (DEBUG_CLS_HOOKED) {
          debug2(" AFTER runPromise: " + this.name + " uid:" + currentUid + " len:" + this._set.length + " " + util.inspect(context));
        }
        this.exit(context);
        throw err;
      });
    };
    Namespace.prototype.bind = function bindFactory(fn, context) {
      if (!context) {
        if (!this.active) {
          context = this.createContext();
        } else {
          context = this.active;
        }
      }
      let self2 = this;
      return function clsBind() {
        self2.enter(context);
        try {
          return fn.apply(this, arguments);
        } catch (exception) {
          if (exception) {
            exception[ERROR_SYMBOL] = context;
          }
          throw exception;
        } finally {
          self2.exit(context);
        }
      };
    };
    Namespace.prototype.enter = function enter(context) {
      assert.ok(context, "context must be provided for entering");
      if (DEBUG_CLS_HOOKED) {
        debug2("  ENTER " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context));
      }
      this._set.push(this.active);
      this.active = context;
    };
    Namespace.prototype.exit = function exit(context) {
      assert.ok(context, "context must be provided for exiting");
      if (DEBUG_CLS_HOOKED) {
        debug2("  EXIT " + this.name + " uid:" + currentUid + " len:" + this._set.length + " context: " + util.inspect(context));
      }
      if (this.active === context) {
        assert.ok(this._set.length, "can't remove top context");
        this.active = this._set.pop();
        return;
      }
      let index = this._set.lastIndexOf(context);
      if (index < 0) {
        if (DEBUG_CLS_HOOKED) {
          debug2("??ERROR?? context exiting but not entered - ignoring: " + util.inspect(context));
        }
        assert.ok(index >= 0, "context not currently entered; can't exit. \n" + util.inspect(this) + "\n" + util.inspect(context));
      } else {
        assert.ok(index, "can't remove top context");
        this._set.splice(index, 1);
      }
    };
    Namespace.prototype.bindEmitter = function bindEmitter(emitter) {
      assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
      let namespace = this;
      let thisSymbol = "context@" + this.name;
      function attach(listener) {
        if (!listener) {
          return;
        }
        if (!listener[CONTEXTS_SYMBOL]) {
          listener[CONTEXTS_SYMBOL] = /* @__PURE__ */ Object.create(null);
        }
        listener[CONTEXTS_SYMBOL][thisSymbol] = {
          namespace,
          context: namespace.active
        };
      }
      function bind(unwrapped) {
        if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL])) {
          return unwrapped;
        }
        let wrapped = unwrapped;
        let unwrappedContexts = unwrapped[CONTEXTS_SYMBOL];
        Object.keys(unwrappedContexts).forEach(function(name2) {
          let thunk = unwrappedContexts[name2];
          wrapped = thunk.namespace.bind(wrapped, thunk.context);
        });
        return wrapped;
      }
      wrapEmitter(emitter, attach, bind);
    };
    Namespace.prototype.fromException = function fromException(exception) {
      return exception[ERROR_SYMBOL];
    };
    function getNamespace(name2) {
      return process.namespaces[name2];
    }
    function createNamespace(name2) {
      assert.ok(name2, "namespace must be given a name.");
      if (DEBUG_CLS_HOOKED) {
        debug2("CREATING NAMESPACE " + name2);
      }
      let namespace = new Namespace(name2);
      namespace.id = currentUid;
      asyncHook.addHooks({
        init(uid, handle, provider, parentUid, parentHandle) {
          currentUid = uid;
          if (parentUid) {
            namespace._contexts.set(uid, namespace._contexts.get(parentUid));
            if (DEBUG_CLS_HOOKED) {
              debug2("PARENTID: " + name2 + " uid:" + uid + " parent:" + parentUid + " provider:" + provider);
            }
          } else {
            namespace._contexts.set(currentUid, namespace.active);
          }
          if (DEBUG_CLS_HOOKED) {
            debug2("INIT " + name2 + " uid:" + uid + " parent:" + parentUid + " provider:" + invertedProviders[provider] + " active:" + util.inspect(namespace.active, true));
          }
        },
        pre(uid, handle) {
          currentUid = uid;
          let context = namespace._contexts.get(uid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              debug2(" PRE " + name2 + " uid:" + uid + " handle:" + getFunctionName(handle) + " context:" + util.inspect(context));
            }
            namespace.enter(context);
          } else {
            if (DEBUG_CLS_HOOKED) {
              debug2(" PRE MISSING CONTEXT " + name2 + " uid:" + uid + " handle:" + getFunctionName(handle));
            }
          }
        },
        post(uid, handle) {
          currentUid = uid;
          let context = namespace._contexts.get(uid);
          if (context) {
            if (DEBUG_CLS_HOOKED) {
              debug2(" POST " + name2 + " uid:" + uid + " handle:" + getFunctionName(handle) + " context:" + util.inspect(context));
            }
            namespace.exit(context);
          } else {
            if (DEBUG_CLS_HOOKED) {
              debug2(" POST MISSING CONTEXT " + name2 + " uid:" + uid + " handle:" + getFunctionName(handle));
            }
          }
        },
        destroy(uid) {
          currentUid = uid;
          if (DEBUG_CLS_HOOKED) {
            debug2("DESTROY " + name2 + " uid:" + uid + " context:" + util.inspect(namespace._contexts.get(currentUid)) + " active:" + util.inspect(namespace.active, true));
          }
          namespace._contexts.delete(uid);
        }
      });
      process.namespaces[name2] = namespace;
      return namespace;
    }
    function destroyNamespace(name2) {
      let namespace = getNamespace(name2);
      assert.ok(namespace, `can't delete nonexistent namespace! "` + name2 + '"');
      assert.ok(namespace.id, "don't assign to process.namespaces directly! " + util.inspect(namespace));
      process.namespaces[name2] = null;
    }
    function reset() {
      if (process.namespaces) {
        Object.keys(process.namespaces).forEach(function(name2) {
          destroyNamespace(name2);
        });
      }
      process.namespaces = /* @__PURE__ */ Object.create(null);
    }
    process.namespaces = {};
    if (asyncHook._state && !asyncHook._state.enabled) {
      asyncHook.enable();
    }
    function debug2(msg) {
      if (process.env.DEBUG) {
        process._rawDebug(msg);
      }
    }
    function getFunctionName(fn) {
      if (!fn) {
        return fn;
      }
      if (typeof fn === "function") {
        if (fn.name) {
          return fn.name;
        }
        return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
      } else if (fn.constructor && fn.constructor.name) {
        return fn.constructor.name;
      }
    }
    if (DEBUG_CLS_HOOKED) {
      stackChain = require_stack_chain2();
      for (modifier in stackChain.filter._modifiers) {
        stackChain.filter.deattach(modifier);
      }
    }
    var stackChain;
    var modifier;
  }
});

// node_modules/cls-hooked/index.js
var require_cls_hooked = __commonJS({
  "node_modules/cls-hooked/index.js"(exports2, module2) {
    "use strict";
    var semver = require_semver3();
    if (process && semver.gte(process.versions.node, "8.0.0")) {
      module2.exports = require_context3();
    } else {
      module2.exports = require_context_legacy();
    }
  }
});

// node_modules/async-listener/node_modules/semver/semver.js
var require_semver4 = __commonJS({
  "node_modules/async-listener/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "\\d+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[COMPARATORTRIM]);
      range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
      var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(safeRe[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// node_modules/async-listener/glue.js
var require_glue = __commonJS({
  "node_modules/async-listener/glue.js"(exports2, module2) {
    var wrap = require_shimmer().wrap;
    var HAS_CREATE_AL = 1 << 0;
    var HAS_BEFORE_AL = 1 << 1;
    var HAS_AFTER_AL = 1 << 2;
    var HAS_ERROR_AL = 1 << 3;
    var listeners = [];
    var uid = 0;
    var inAsyncTick = false;
    var listenerStack = [];
    var asyncCatcher;
    var asyncWrap;
    function union(dest, added) {
      var destLength = dest.length;
      var addedLength = added.length;
      var returned = [];
      if (destLength === 0 && addedLength === 0)
        return returned;
      for (var j = 0; j < destLength; j++)
        returned[j] = dest[j];
      if (addedLength === 0)
        return returned;
      for (var i = 0; i < addedLength; i++) {
        var missing = true;
        for (j = 0; j < destLength; j++) {
          if (dest[j].uid === added[i].uid) {
            missing = false;
            break;
          }
        }
        if (missing)
          returned.push(added[i]);
      }
      return returned;
    }
    if (process._fatalException) {
      inErrorTick = false;
      asyncCatcher = function asyncCatcher2(er) {
        var length = listeners.length;
        if (inErrorTick || length === 0)
          return false;
        var handled = false;
        inErrorTick = true;
        for (var i = 0; i < length; ++i) {
          var listener = listeners[i];
          if ((listener.flags & HAS_ERROR_AL) === 0)
            continue;
          var value = errorValues && errorValues[listener.uid];
          handled = listener.error(value, er) || handled;
        }
        inErrorTick = false;
        if (listenerStack.length > 0)
          listeners = listenerStack.pop();
        errorValues = void 0;
        return handled && !inAsyncTick;
      };
      asyncWrap = function asyncWrap2(original, list, length) {
        var values = [];
        inAsyncTick = true;
        for (var i = 0; i < length; ++i) {
          var listener = list[i];
          values[listener.uid] = listener.data;
          if ((listener.flags & HAS_CREATE_AL) === 0)
            continue;
          var value = listener.create(listener.data);
          if (value !== void 0)
            values[listener.uid] = value;
        }
        inAsyncTick = false;
        return function() {
          errorValues = values;
          listenerStack.push(listeners);
          listeners = union(list, listeners);
          inAsyncTick = true;
          for (var i2 = 0; i2 < length; ++i2) {
            if ((list[i2].flags & HAS_BEFORE_AL) > 0) {
              list[i2].before(this, values[list[i2].uid]);
            }
          }
          inAsyncTick = false;
          var returned = original.apply(this, arguments);
          inAsyncTick = true;
          for (i2 = 0; i2 < length; ++i2) {
            if ((list[i2].flags & HAS_AFTER_AL) > 0) {
              list[i2].after(this, values[list[i2].uid]);
            }
          }
          inAsyncTick = false;
          listeners = listenerStack.pop();
          errorValues = void 0;
          return returned;
        };
      };
      wrap(process, "_fatalException", function(_fatalException) {
        return function _asyncFatalException(er) {
          return asyncCatcher(er) || _fatalException(er);
        };
      });
    } else {
      errorThrew = false;
      asyncCatcher = function uncaughtCatcher(er) {
        if (errorThrew)
          throw er;
        var handled = false;
        var length = listeners.length;
        for (var i = 0; i < length; ++i) {
          var listener = listeners[i];
          if ((listener.flags & HAS_ERROR_AL) === 0)
            continue;
          handled = listener.error(null, er) || handled;
        }
        if (!handled && inAsyncTick)
          throw er;
      };
      asyncWrap = function asyncWrap2(original, list, length) {
        var values = [];
        inAsyncTick = true;
        for (var i = 0; i < length; ++i) {
          var listener = list[i];
          values[listener.uid] = listener.data;
          if ((listener.flags & HAS_CREATE_AL) === 0)
            continue;
          var value = listener.create(listener.data);
          if (value !== void 0)
            values[listener.uid] = value;
        }
        inAsyncTick = false;
        return function() {
          var threw = false;
          var handled = false;
          listenerStack.push(listeners);
          listeners = union(list, listeners);
          inAsyncTick = true;
          for (var i2 = 0; i2 < length; ++i2) {
            if ((list[i2].flags & HAS_BEFORE_AL) > 0) {
              list[i2].before(this, values[list[i2].uid]);
            }
          }
          inAsyncTick = false;
          var returned;
          try {
            returned = original.apply(this, arguments);
          } catch (er) {
            threw = true;
            for (var i2 = 0; i2 < length; ++i2) {
              if ((listeners[i2].flags & HAS_ERROR_AL) == 0)
                continue;
              try {
                handled = listeners[i2].error(values[list[i2].uid], er) || handled;
              } catch (x) {
                errorThrew = true;
                throw x;
              }
            }
            if (!handled) {
              process.removeListener("uncaughtException", asyncCatcher);
              process._originalNextTick(function() {
                process.addListener("uncaughtException", asyncCatcher);
              });
              throw er;
            }
          } finally {
            if (!threw || handled) {
              inAsyncTick = true;
              for (i2 = 0; i2 < length; ++i2) {
                if ((list[i2].flags & HAS_AFTER_AL) > 0) {
                  list[i2].after(this, values[list[i2].uid]);
                }
              }
              inAsyncTick = false;
            }
            listeners = listenerStack.pop();
          }
          return returned;
        };
      };
      process.addListener("uncaughtException", asyncCatcher);
    }
    var inErrorTick;
    var errorValues;
    var errorThrew;
    function simpleWrap(original, list, length) {
      inAsyncTick = true;
      for (var i = 0; i < length; ++i) {
        var listener = list[i];
        if (listener.create)
          listener.create(listener.data);
      }
      inAsyncTick = false;
      return function() {
        listenerStack.push(listeners);
        listeners = union(list, listeners);
        var returned = original.apply(this, arguments);
        listeners = listenerStack.pop();
        return returned;
      };
    }
    function wrapCallback(original) {
      var length = listeners.length;
      if (length === 0)
        return original;
      var list = listeners.slice();
      for (var i = 0; i < length; ++i) {
        if (list[i].flags > 0)
          return asyncWrap(original, list, length);
      }
      return simpleWrap(original, list, length);
    }
    function AsyncListener(callbacks, data) {
      if (typeof callbacks.create === "function") {
        this.create = callbacks.create;
        this.flags |= HAS_CREATE_AL;
      }
      if (typeof callbacks.before === "function") {
        this.before = callbacks.before;
        this.flags |= HAS_BEFORE_AL;
      }
      if (typeof callbacks.after === "function") {
        this.after = callbacks.after;
        this.flags |= HAS_AFTER_AL;
      }
      if (typeof callbacks.error === "function") {
        this.error = callbacks.error;
        this.flags |= HAS_ERROR_AL;
      }
      this.uid = ++uid;
      this.data = data === void 0 ? null : data;
    }
    AsyncListener.prototype.create = void 0;
    AsyncListener.prototype.before = void 0;
    AsyncListener.prototype.after = void 0;
    AsyncListener.prototype.error = void 0;
    AsyncListener.prototype.data = void 0;
    AsyncListener.prototype.uid = 0;
    AsyncListener.prototype.flags = 0;
    function createAsyncListener(callbacks, data) {
      if (typeof callbacks !== "object" || !callbacks) {
        throw new TypeError("callbacks argument must be an object");
      }
      if (callbacks instanceof AsyncListener) {
        return callbacks;
      } else {
        return new AsyncListener(callbacks, data);
      }
    }
    function addAsyncListener(callbacks, data) {
      var listener;
      if (!(callbacks instanceof AsyncListener)) {
        listener = createAsyncListener(callbacks, data);
      } else {
        listener = callbacks;
      }
      var registered = false;
      for (var i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          registered = true;
          break;
        }
      }
      if (!registered)
        listeners.push(listener);
      return listener;
    }
    function removeAsyncListener(listener) {
      for (var i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          break;
        }
      }
    }
    process.createAsyncListener = createAsyncListener;
    process.addAsyncListener = addAsyncListener;
    process.removeAsyncListener = removeAsyncListener;
    module2.exports = wrapCallback;
  }
});

// node_modules/async-listener/es6-wrapped-promise.js
var require_es6_wrapped_promise = __commonJS({
  "node_modules/async-listener/es6-wrapped-promise.js"(exports2, module2) {
    "use strict";
    module2.exports = (Promise2, ensureAslWrapper) => {
      return class WrappedPromise extends Promise2 {
        constructor(executor) {
          var context, args;
          super(wrappedExecutor);
          var promise = this;
          try {
            executor.apply(context, args);
          } catch (err) {
            args[1](err);
          }
          return promise;
          function wrappedExecutor(resolve, reject) {
            context = this;
            args = [wrappedResolve, wrappedReject];
            function wrappedResolve(val) {
              ensureAslWrapper(promise, false);
              return resolve(val);
            }
            function wrappedReject(val) {
              ensureAslWrapper(promise, false);
              return reject(val);
            }
          }
        }
      };
    };
  }
});

// node_modules/async-listener/index.js
var require_async_listener = __commonJS({
  "node_modules/async-listener/index.js"() {
    "use strict";
    if (process.addAsyncListener)
      throw new Error("Don't require polyfill unless needed");
    var shimmer = require_shimmer();
    var semver = require_semver4();
    var wrap = shimmer.wrap;
    var massWrap = shimmer.massWrap;
    var wrapCallback = require_glue();
    var util = require("util");
    var v6plus = semver.gte(process.version, "6.0.0");
    var v7plus = semver.gte(process.version, "7.0.0");
    var v8plus = semver.gte(process.version, "8.0.0");
    var v11plus = semver.gte(process.version, "11.0.0");
    var net = require("net");
    if (v7plus && !net._normalizeArgs) {
      net._normalizeArgs = function(args) {
        if (args.length === 0) {
          return [{}, null];
        }
        var arg0 = args[0];
        var options = {};
        if (typeof arg0 === "object" && arg0 !== null) {
          options = arg0;
        } else if (isPipeName(arg0)) {
          options.path = arg0;
        } else {
          options.port = arg0;
          if (args.length > 1 && typeof args[1] === "string") {
            options.host = args[1];
          }
        }
        var cb = args[args.length - 1];
        if (typeof cb !== "function")
          return [options, null];
        else
          return [options, cb];
      };
    } else if (!v7plus && !net._normalizeConnectArgs) {
      net._normalizeConnectArgs = function(args) {
        var options = {};
        function toNumber2(x) {
          return (x = Number(x)) >= 0 ? x : false;
        }
        if (typeof args[0] === "object" && args[0] !== null) {
          options = args[0];
        } else if (typeof args[0] === "string" && toNumber2(args[0]) === false) {
          options.path = args[0];
        } else {
          options.port = args[0];
          if (typeof args[1] === "string") {
            options.host = args[1];
          }
        }
        var cb = args[args.length - 1];
        return typeof cb === "function" ? [options, cb] : [options];
      };
    }
    if ("_setUpListenHandle" in net.Server.prototype) {
      wrap(net.Server.prototype, "_setUpListenHandle", wrapSetUpListenHandle);
    } else {
      wrap(net.Server.prototype, "_listen2", wrapSetUpListenHandle);
    }
    function wrapSetUpListenHandle(original) {
      return function() {
        this.on("connection", function(socket) {
          if (socket._handle) {
            socket._handle.onread = wrapCallback(socket._handle.onread);
          }
        });
        try {
          return original.apply(this, arguments);
        } finally {
          if (this._handle && this._handle.onconnection) {
            this._handle.onconnection = wrapCallback(this._handle.onconnection);
          }
        }
      };
    }
    function patchOnRead(ctx) {
      if (ctx && ctx._handle) {
        var handle = ctx._handle;
        if (!handle._originalOnread) {
          handle._originalOnread = handle.onread;
        }
        handle.onread = wrapCallback(handle._originalOnread);
      }
    }
    wrap(net.Socket.prototype, "connect", function(original) {
      return function() {
        var args;
        if (v8plus && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0) {
          args = arguments[0];
        } else {
          args = v7plus ? net._normalizeArgs(arguments) : net._normalizeConnectArgs(arguments);
        }
        if (args[1])
          args[1] = wrapCallback(args[1]);
        var result = original.apply(this, args);
        patchOnRead(this);
        return result;
      };
    });
    var http = require("http");
    wrap(http.Agent.prototype, "addRequest", function(original) {
      return function(req) {
        var onSocket = req.onSocket;
        req.onSocket = wrapCallback(function(socket) {
          patchOnRead(socket);
          return onSocket.apply(this, arguments);
        });
        return original.apply(this, arguments);
      };
    });
    var childProcess = require("child_process");
    function wrapChildProcess(child) {
      if (Array.isArray(child.stdio)) {
        child.stdio.forEach(function(socket) {
          if (socket && socket._handle) {
            socket._handle.onread = wrapCallback(socket._handle.onread);
            wrap(socket._handle, "close", activatorFirst);
          }
        });
      }
      if (child._handle) {
        child._handle.onexit = wrapCallback(child._handle.onexit);
      }
    }
    if (childProcess.ChildProcess) {
      wrap(childProcess.ChildProcess.prototype, "spawn", function(original) {
        return function() {
          var result = original.apply(this, arguments);
          wrapChildProcess(this);
          return result;
        };
      });
    } else {
      massWrap(childProcess, [
        "execFile",
        // exec is implemented in terms of execFile
        "fork",
        "spawn"
      ], function(original) {
        return function() {
          var result = original.apply(this, arguments);
          wrapChildProcess(result);
          return result;
        };
      });
    }
    if (!process._fatalException) {
      process._originalNextTick = process.nextTick;
    }
    var processors = [];
    if (process._nextDomainTick)
      processors.push("_nextDomainTick");
    if (process._tickDomainCallback)
      processors.push("_tickDomainCallback");
    massWrap(
      process,
      processors,
      activator
    );
    wrap(process, "nextTick", activatorFirst);
    var asynchronizers = [
      "setTimeout",
      "setInterval"
    ];
    if (global.setImmediate)
      asynchronizers.push("setImmediate");
    var timers = require("timers");
    var patchGlobalTimers = global.setTimeout === timers.setTimeout;
    massWrap(
      timers,
      asynchronizers,
      activatorFirst
    );
    if (patchGlobalTimers) {
      massWrap(
        global,
        asynchronizers,
        activatorFirst
      );
    }
    var dns = require("dns");
    massWrap(
      dns,
      [
        "lookup",
        "resolve",
        "resolve4",
        "resolve6",
        "resolveCname",
        "resolveMx",
        "resolveNs",
        "resolveTxt",
        "resolveSrv",
        "reverse"
      ],
      activator
    );
    if (dns.resolveNaptr)
      wrap(dns, "resolveNaptr", activator);
    var fs = require("fs");
    massWrap(
      fs,
      [
        "watch",
        "rename",
        "truncate",
        "chown",
        "fchown",
        "chmod",
        "fchmod",
        "stat",
        "lstat",
        "fstat",
        "link",
        "symlink",
        "readlink",
        "realpath",
        "unlink",
        "rmdir",
        "mkdir",
        "readdir",
        "close",
        "open",
        "utimes",
        "futimes",
        "fsync",
        "write",
        "read",
        "readFile",
        "writeFile",
        "appendFile",
        "watchFile",
        "unwatchFile",
        "exists"
      ],
      activator
    );
    if (fs.lchown)
      wrap(fs, "lchown", activator);
    if (fs.lchmod)
      wrap(fs, "lchmod", activator);
    if (fs.ftruncate)
      wrap(fs, "ftruncate", activator);
    var zlib;
    try {
      zlib = require("zlib");
    } catch (err) {
    }
    if (zlib && zlib.Deflate && zlib.Deflate.prototype) {
      proto = Object.getPrototypeOf(zlib.Deflate.prototype);
      if (proto._transform) {
        wrap(proto, "_transform", activator);
      } else if (proto.write && proto.flush && proto.end) {
        massWrap(
          proto,
          [
            "write",
            "flush",
            "end"
          ],
          activator
        );
      }
    }
    var proto;
    var crypto;
    try {
      crypto = require("crypto");
    } catch (err) {
    }
    if (crypto) {
      toWrap = [
        "pbkdf2",
        "randomBytes"
      ];
      if (!v11plus) {
        toWrap.push("pseudoRandomBytes");
      }
      massWrap(crypto, toWrap, activator);
    }
    var toWrap;
    var instrumentPromise = !!global.Promise && Promise.toString() === "function Promise() { [native code] }" && Promise.toString.toString() === "function toString() { [native code] }";
    if (instrumentPromise) {
      promiseListener = process.addAsyncListener({
        create: function create() {
          instrumentPromise = false;
        }
      });
      global.Promise.resolve(true).then(function notSync() {
        instrumentPromise = false;
      });
      process.removeAsyncListener(promiseListener);
    }
    var promiseListener;
    if (instrumentPromise) {
      wrapPromise();
    }
    function wrapPromise() {
      var Promise2 = global.Promise;
      function wrappedPromise(executor) {
        if (!(this instanceof wrappedPromise)) {
          return Promise2(executor);
        }
        if (typeof executor !== "function") {
          return new Promise2(executor);
        }
        var context, args;
        var promise = new Promise2(wrappedExecutor);
        promise.__proto__ = wrappedPromise.prototype;
        try {
          executor.apply(context, args);
        } catch (err) {
          args[1](err);
        }
        return promise;
        function wrappedExecutor(resolve, reject) {
          context = this;
          args = [wrappedResolve, wrappedReject];
          function wrappedResolve(val) {
            ensureAslWrapper(promise, false);
            return resolve(val);
          }
          function wrappedReject(val) {
            ensureAslWrapper(promise, false);
            return reject(val);
          }
        }
      }
      util.inherits(wrappedPromise, Promise2);
      wrap(Promise2.prototype, "then", wrapThen);
      if (Promise2.prototype.chain) {
        wrap(Promise2.prototype, "chain", wrapThen);
      }
      if (v6plus) {
        global.Promise = require_es6_wrapped_promise()(Promise2, ensureAslWrapper);
      } else {
        var PromiseFunctions = [
          "all",
          "race",
          "reject",
          "resolve",
          "accept",
          // Node.js <v7 only
          "defer"
          // Node.js <v7 only
        ];
        PromiseFunctions.forEach(function(key) {
          if (typeof Promise2[key] === "function") {
            wrappedPromise[key] = Promise2[key];
          }
        });
        global.Promise = wrappedPromise;
      }
      function ensureAslWrapper(promise, overwrite) {
        if (!promise.__asl_wrapper || overwrite) {
          promise.__asl_wrapper = wrapCallback(propagateAslWrapper);
        }
      }
      function propagateAslWrapper(ctx, fn, result, next) {
        var nextResult;
        try {
          nextResult = fn.call(ctx, result);
          return { returnVal: nextResult, error: false };
        } catch (err) {
          return { errorVal: err, error: true };
        } finally {
          if (nextResult instanceof Promise2) {
            next.__asl_wrapper = function proxyWrapper() {
              var aslWrapper = nextResult.__asl_wrapper || propagateAslWrapper;
              return aslWrapper.apply(this, arguments);
            };
          } else {
            ensureAslWrapper(next, true);
          }
        }
      }
      function wrapThen(original) {
        return function wrappedThen() {
          var promise = this;
          var next = original.apply(promise, Array.prototype.map.call(arguments, bind));
          next.__asl_wrapper = function proxyWrapper(ctx, fn, val, last) {
            if (promise.__asl_wrapper) {
              promise.__asl_wrapper(ctx, function() {
              }, null, next);
              return next.__asl_wrapper(ctx, fn, val, last);
            }
            return propagateAslWrapper(ctx, fn, val, last);
          };
          return next;
          function bind(fn) {
            if (typeof fn !== "function")
              return fn;
            return wrapCallback(function(val) {
              var result = (promise.__asl_wrapper || propagateAslWrapper)(this, fn, val, next);
              if (result.error) {
                throw result.errorVal;
              } else {
                return result.returnVal;
              }
            });
          }
        };
      }
    }
    function activator(fn) {
      var fallback = function() {
        var args;
        var cbIdx = arguments.length - 1;
        if (typeof arguments[cbIdx] === "function") {
          args = Array(arguments.length);
          for (var i = 0; i < arguments.length - 1; i++) {
            args[i] = arguments[i];
          }
          args[cbIdx] = wrapCallback(arguments[cbIdx]);
        }
        return fn.apply(this, args || arguments);
      };
      switch (fn.length) {
        case 1:
          return function(cb) {
            if (arguments.length !== 1)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb);
          };
        case 2:
          return function(a, cb) {
            if (arguments.length !== 2)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, cb);
          };
        case 3:
          return function(a, b, cb) {
            if (arguments.length !== 3)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, cb);
          };
        case 4:
          return function(a, b, c, cb) {
            if (arguments.length !== 4)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, c, cb);
          };
        case 5:
          return function(a, b, c, d, cb) {
            if (arguments.length !== 5)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, c, d, cb);
          };
        case 6:
          return function(a, b, c, d, e, cb) {
            if (arguments.length !== 6)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, a, b, c, d, e, cb);
          };
        default:
          return fallback;
      }
    }
    function activatorFirst(fn) {
      var fallback = function() {
        var args;
        if (typeof arguments[0] === "function") {
          args = Array(arguments.length);
          args[0] = wrapCallback(arguments[0]);
          for (var i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
        }
        return fn.apply(this, args || arguments);
      };
      switch (fn.length) {
        case 1:
          return function(cb) {
            if (arguments.length !== 1)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb);
          };
        case 2:
          return function(cb, a) {
            if (arguments.length !== 2)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a);
          };
        case 3:
          return function(cb, a, b) {
            if (arguments.length !== 3)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b);
          };
        case 4:
          return function(cb, a, b, c) {
            if (arguments.length !== 4)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b, c);
          };
        case 5:
          return function(cb, a, b, c, d) {
            if (arguments.length !== 5)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b, c, d);
          };
        case 6:
          return function(cb, a, b, c, d, e) {
            if (arguments.length !== 6)
              return fallback.apply(this, arguments);
            if (typeof cb === "function")
              cb = wrapCallback(cb);
            return fn.call(this, cb, a, b, c, d, e);
          };
        default:
          return fallback;
      }
    }
    function toNumber(x) {
      return (x = Number(x)) >= 0 ? x : false;
    }
    function isPipeName(s) {
      return typeof s === "string" && toNumber(s) === false;
    }
  }
});

// node_modules/continuation-local-storage/context.js
var require_context4 = __commonJS({
  "node_modules/continuation-local-storage/context.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var wrapEmitter = require_listener();
    var CONTEXTS_SYMBOL = "cls@contexts";
    var ERROR_SYMBOL = "error@context";
    if (!process.addAsyncListener)
      require_async_listener();
    function Namespace(name2) {
      this.name = name2;
      this.active = null;
      this._set = [];
      this.id = null;
    }
    Namespace.prototype.set = function(key, value) {
      if (!this.active) {
        throw new Error("No context available. ns.run() or ns.bind() must be called first.");
      }
      this.active[key] = value;
      return value;
    };
    Namespace.prototype.get = function(key) {
      if (!this.active)
        return void 0;
      return this.active[key];
    };
    Namespace.prototype.createContext = function() {
      return Object.create(this.active);
    };
    Namespace.prototype.run = function(fn) {
      var context = this.createContext();
      this.enter(context);
      try {
        fn(context);
        return context;
      } catch (exception) {
        if (exception) {
          exception[ERROR_SYMBOL] = context;
        }
        throw exception;
      } finally {
        this.exit(context);
      }
    };
    Namespace.prototype.runAndReturn = function(fn) {
      var value;
      this.run(function(context) {
        value = fn(context);
      });
      return value;
    };
    Namespace.prototype.bind = function(fn, context) {
      if (!context) {
        if (!this.active) {
          context = this.createContext();
        } else {
          context = this.active;
        }
      }
      var self2 = this;
      return function() {
        self2.enter(context);
        try {
          return fn.apply(this, arguments);
        } catch (exception) {
          if (exception) {
            exception[ERROR_SYMBOL] = context;
          }
          throw exception;
        } finally {
          self2.exit(context);
        }
      };
    };
    Namespace.prototype.enter = function(context) {
      assert.ok(context, "context must be provided for entering");
      this._set.push(this.active);
      this.active = context;
    };
    Namespace.prototype.exit = function(context) {
      assert.ok(context, "context must be provided for exiting");
      if (this.active === context) {
        assert.ok(this._set.length, "can't remove top context");
        this.active = this._set.pop();
        return;
      }
      var index = this._set.lastIndexOf(context);
      assert.ok(index >= 0, "context not currently entered; can't exit");
      assert.ok(index, "can't remove top context");
      this._set.splice(index, 1);
    };
    Namespace.prototype.bindEmitter = function(emitter) {
      assert.ok(emitter.on && emitter.addListener && emitter.emit, "can only bind real EEs");
      var namespace = this;
      var thisSymbol = "context@" + this.name;
      function attach(listener) {
        if (!listener)
          return;
        if (!listener[CONTEXTS_SYMBOL])
          listener[CONTEXTS_SYMBOL] = /* @__PURE__ */ Object.create(null);
        listener[CONTEXTS_SYMBOL][thisSymbol] = {
          namespace,
          context: namespace.active
        };
      }
      function bind(unwrapped) {
        if (!(unwrapped && unwrapped[CONTEXTS_SYMBOL]))
          return unwrapped;
        var wrapped = unwrapped;
        var contexts = unwrapped[CONTEXTS_SYMBOL];
        Object.keys(contexts).forEach(function(name2) {
          var thunk = contexts[name2];
          wrapped = thunk.namespace.bind(wrapped, thunk.context);
        });
        return wrapped;
      }
      wrapEmitter(emitter, attach, bind);
    };
    Namespace.prototype.fromException = function(exception) {
      return exception[ERROR_SYMBOL];
    };
    function get(name2) {
      return process.namespaces[name2];
    }
    function create(name2) {
      assert.ok(name2, "namespace must be given a name!");
      var namespace = new Namespace(name2);
      namespace.id = process.addAsyncListener({
        create: function() {
          return namespace.active;
        },
        before: function(context, storage) {
          if (storage)
            namespace.enter(storage);
        },
        after: function(context, storage) {
          if (storage)
            namespace.exit(storage);
        },
        error: function(storage) {
          if (storage)
            namespace.exit(storage);
        }
      });
      process.namespaces[name2] = namespace;
      return namespace;
    }
    function destroy(name2) {
      var namespace = get(name2);
      assert.ok(namespace, "can't delete nonexistent namespace!");
      assert.ok(namespace.id, "don't assign to process.namespaces directly!");
      process.removeAsyncListener(namespace.id);
      process.namespaces[name2] = null;
    }
    function reset() {
      if (process.namespaces) {
        Object.keys(process.namespaces).forEach(function(name2) {
          destroy(name2);
        });
      }
      process.namespaces = /* @__PURE__ */ Object.create(null);
    }
    if (!process.namespaces)
      reset();
    module2.exports = {
      getNamespace: get,
      createNamespace: create,
      destroyNamespace: destroy,
      reset
    };
  }
});

// node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js
var require_CorrelationContextManager = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/CorrelationContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CorrelationContextManager = void 0;
    var Logging = require_Logging();
    var DiagChannel = require_initialization();
    var Traceparent = require_Traceparent();
    var Tracestate = require_Tracestate();
    var HttpRequestParser = require_HttpRequestParser();
    var Util = require_Util();
    var CorrelationContextManager = (
      /** @class */
      function() {
        function CorrelationContextManager2() {
        }
        CorrelationContextManager2.getCurrentContext = function() {
          if (!CorrelationContextManager2.enabled) {
            return null;
          }
          var context = CorrelationContextManager2.session.get(CorrelationContextManager2.CONTEXT_NAME);
          if (context === void 0) {
            return null;
          }
          return context;
        };
        CorrelationContextManager2.generateContextObject = function(operationId, parentId, operationName, correlationContextHeader, traceparent, tracestate) {
          parentId = parentId || operationId;
          if (this.enabled) {
            return {
              operation: {
                name: operationName,
                id: operationId,
                parentId,
                traceparent,
                tracestate
              },
              customProperties: new CustomPropertiesImpl(correlationContextHeader)
            };
          }
          return null;
        };
        CorrelationContextManager2.spanToContextObject = function(spanContext, parentId, name2) {
          var traceContext = new Traceparent();
          traceContext.traceId = spanContext.traceId;
          traceContext.spanId = spanContext.spanId;
          traceContext.traceFlag = Traceparent.formatOpenTelemetryTraceFlags(spanContext.traceFlags) || Traceparent.DEFAULT_TRACE_FLAG;
          traceContext.parentId = parentId;
          return CorrelationContextManager2.generateContextObject(traceContext.traceId, traceContext.parentId, name2, null, traceContext);
        };
        CorrelationContextManager2.runWithContext = function(context, fn) {
          var _a;
          if (CorrelationContextManager2.enabled) {
            try {
              return CorrelationContextManager2.session.bind(fn, (_a = {}, _a[CorrelationContextManager2.CONTEXT_NAME] = context, _a))();
            } catch (error) {
              Logging.warn("Error binding to session context", Util.dumpObj(error));
            }
          }
          return fn();
        };
        CorrelationContextManager2.wrapEmitter = function(emitter) {
          if (CorrelationContextManager2.enabled) {
            try {
              CorrelationContextManager2.session.bindEmitter(emitter);
            } catch (error) {
              Logging.warn("Error binding to session context", Util.dumpObj(error));
            }
          }
        };
        CorrelationContextManager2.wrapCallback = function(fn, context) {
          var _a;
          if (CorrelationContextManager2.enabled) {
            try {
              return CorrelationContextManager2.session.bind(fn, context ? (_a = {}, _a[CorrelationContextManager2.CONTEXT_NAME] = context, _a) : void 0);
            } catch (error) {
              Logging.warn("Error binding to session context", Util.dumpObj(error));
            }
          }
          return fn;
        };
        CorrelationContextManager2.enable = function(forceClsHooked) {
          if (this.enabled) {
            return;
          }
          if (!this.isNodeVersionCompatible()) {
            this.enabled = false;
            return;
          }
          if (!CorrelationContextManager2.hasEverEnabled) {
            this.forceClsHooked = forceClsHooked;
            this.hasEverEnabled = true;
            if (typeof this.cls === "undefined") {
              if (CorrelationContextManager2.forceClsHooked === true || CorrelationContextManager2.forceClsHooked === void 0 && CorrelationContextManager2.shouldUseClsHooked()) {
                this.cls = require_cls_hooked();
              } else {
                this.cls = require_context4();
              }
            }
            CorrelationContextManager2.session = this.cls.createNamespace("AI-CLS-Session");
            DiagChannel.registerContextPreservation(function(cb) {
              try {
                return CorrelationContextManager2.session.bind(cb);
              } catch (error) {
                Logging.warn("Error binding to session context", Util.dumpObj(error));
              }
            });
          }
          this.enabled = true;
        };
        CorrelationContextManager2.startOperation = function(input, request) {
          var traceContext = input && input.traceContext || null;
          var span = input && input.spanContext ? input : null;
          var spanContext = input && input.traceId ? input : null;
          var headers = input && input.headers;
          if (span) {
            return this.spanToContextObject(span.spanContext(), span.parentSpanId, span.name);
          }
          if (spanContext) {
            return this.spanToContextObject(spanContext, "|" + spanContext.traceId + "." + spanContext.spanId + ".", typeof request === "string" ? request : "");
          }
          var operationName = typeof request === "string" ? request : "";
          if (traceContext) {
            var traceparent = null;
            var tracestate = null;
            operationName = traceContext.attributes["OperationName"] || operationName;
            if (request) {
              var azureFnRequest = request;
              if (azureFnRequest.headers) {
                if (azureFnRequest.headers.traceparent) {
                  traceparent = new Traceparent(azureFnRequest.headers.traceparent);
                } else if (azureFnRequest.headers["request-id"]) {
                  traceparent = new Traceparent(null, azureFnRequest.headers["request-id"]);
                }
                if (azureFnRequest.headers.tracestate) {
                  tracestate = new Tracestate(azureFnRequest.headers.tracestate);
                }
              }
            }
            if (!traceparent) {
              traceparent = new Traceparent(traceContext.traceparent);
            }
            if (!tracestate) {
              tracestate = new Tracestate(traceContext.tracestate);
            }
            var correlationContextHeader = void 0;
            if (typeof request === "object") {
              var parser = new HttpRequestParser(request);
              correlationContextHeader = parser.getCorrelationContextHeader();
              operationName = parser.getOperationName({});
            }
            var correlationContext = CorrelationContextManager2.generateContextObject(traceparent.traceId, traceparent.parentId, operationName, correlationContextHeader, traceparent, tracestate);
            return correlationContext;
          }
          if (headers) {
            var traceparent = new Traceparent(headers.traceparent ? headers.traceparent.toString() : null);
            var tracestate = new Tracestate(headers.tracestate ? headers.tracestate.toString() : null);
            var parser = new HttpRequestParser(input);
            var correlationContext = CorrelationContextManager2.generateContextObject(traceparent.traceId, traceparent.parentId, parser.getOperationName({}), parser.getCorrelationContextHeader(), traceparent, tracestate);
            return correlationContext;
          }
          Logging.warn("startOperation was called with invalid arguments", arguments);
          return null;
        };
        CorrelationContextManager2.disable = function() {
          this.enabled = false;
        };
        CorrelationContextManager2.reset = function() {
          if (CorrelationContextManager2.hasEverEnabled) {
            CorrelationContextManager2.session = null;
            CorrelationContextManager2.session = this.cls.createNamespace("AI-CLS-Session");
          }
        };
        CorrelationContextManager2.isNodeVersionCompatible = function() {
          var nodeVer = process.versions.node.split(".");
          return parseInt(nodeVer[0]) > 3 || parseInt(nodeVer[0]) > 2 && parseInt(nodeVer[1]) > 2;
        };
        CorrelationContextManager2.shouldUseClsHooked = function() {
          var nodeVer = process.versions.node.split(".");
          return parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 2;
        };
        CorrelationContextManager2.canUseClsHooked = function() {
          var nodeVer = process.versions.node.split(".");
          var greater800 = parseInt(nodeVer[0]) > 8 || parseInt(nodeVer[0]) >= 8 && parseInt(nodeVer[1]) >= 0;
          var less820 = parseInt(nodeVer[0]) < 8 || parseInt(nodeVer[0]) <= 8 && parseInt(nodeVer[1]) < 2;
          var greater470 = parseInt(nodeVer[0]) > 4 || parseInt(nodeVer[0]) >= 4 && parseInt(nodeVer[1]) >= 7;
          return !(greater800 && less820) && greater470;
        };
        CorrelationContextManager2.enabled = false;
        CorrelationContextManager2.hasEverEnabled = false;
        CorrelationContextManager2.forceClsHooked = void 0;
        CorrelationContextManager2.CONTEXT_NAME = "ApplicationInsights-Context";
        return CorrelationContextManager2;
      }()
    );
    exports2.CorrelationContextManager = CorrelationContextManager;
    var CustomPropertiesImpl = (
      /** @class */
      function() {
        function CustomPropertiesImpl2(header) {
          this.props = [];
          this.addHeaderData(header);
        }
        CustomPropertiesImpl2.prototype.addHeaderData = function(header) {
          var keyvals = header ? header.split(", ") : [];
          this.props = keyvals.map(function(keyval) {
            var parts = keyval.split("=");
            return { key: parts[0], value: parts[1] };
          }).concat(this.props);
        };
        CustomPropertiesImpl2.prototype.serializeToHeader = function() {
          return this.props.map(function(keyval) {
            return keyval.key + "=" + keyval.value;
          }).join(", ");
        };
        CustomPropertiesImpl2.prototype.getProperty = function(prop) {
          for (var i = 0; i < this.props.length; ++i) {
            var keyval = this.props[i];
            if (keyval.key === prop) {
              return keyval.value;
            }
          }
          return;
        };
        CustomPropertiesImpl2.prototype.setProperty = function(prop, val) {
          if (CustomPropertiesImpl2.bannedCharacters.test(prop) || CustomPropertiesImpl2.bannedCharacters.test(val)) {
            Logging.warn("Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: " + prop + " and value: " + val);
            return;
          }
          for (var i = 0; i < this.props.length; ++i) {
            var keyval = this.props[i];
            if (keyval.key === prop) {
              keyval.value = val;
              return;
            }
          }
          this.props.push({ key: prop, value: val });
        };
        CustomPropertiesImpl2.bannedCharacters = /[,=]/;
        return CustomPropertiesImpl2;
      }()
    );
  }
});

// node_modules/applicationinsights/out/Declarations/Constants.js
var require_Constants2 = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Constants.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = exports2.WEB_INSTRUMENTATION_DEFAULT_SOURCE = exports2.TIME_SINCE_ENQUEUED = exports2.ENQUEUED_TIME = exports2.MessageBusDestination = exports2.MicrosoftEventHub = exports2.AzNamespace = exports2.StatsbeatNetworkCategory = exports2.StatsbeatFeatureType = exports2.StatsbeatInstrumentation = exports2.StatsbeatFeature = exports2.StatsbeatCounter = exports2.StatsbeatAttach = exports2.StatsbeatResourceProvider = exports2.StatsbeatTelemetryName = exports2.HeartBeatMetricName = exports2.DependencyTypeName = exports2.TelemetryTypeStringToQuickPulseDocumentType = exports2.TelemetryTypeStringToQuickPulseType = exports2.QuickPulseType = exports2.QuickPulseDocumentType = exports2.PerformanceToQuickPulseCounter = exports2.MetricId = exports2.PerformanceCounter = exports2.QuickPulseCounter = exports2.DEFAULT_LIVEMETRICS_HOST = exports2.DEFAULT_LIVEMETRICS_ENDPOINT = exports2.DEFAULT_BREEZE_ENDPOINT = exports2.APPLICATION_INSIGHTS_SDK_VERSION = void 0;
    exports2.APPLICATION_INSIGHTS_SDK_VERSION = "2.5.0";
    exports2.DEFAULT_BREEZE_ENDPOINT = "https://dc.services.visualstudio.com";
    exports2.DEFAULT_LIVEMETRICS_ENDPOINT = "https://rt.services.visualstudio.com";
    exports2.DEFAULT_LIVEMETRICS_HOST = "rt.services.visualstudio.com";
    var QuickPulseCounter;
    (function(QuickPulseCounter2) {
      QuickPulseCounter2["COMMITTED_BYTES"] = "\\Memory\\Committed Bytes";
      QuickPulseCounter2["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
      QuickPulseCounter2["REQUEST_RATE"] = "\\ApplicationInsights\\Requests/Sec";
      QuickPulseCounter2["REQUEST_FAILURE_RATE"] = "\\ApplicationInsights\\Requests Failed/Sec";
      QuickPulseCounter2["REQUEST_DURATION"] = "\\ApplicationInsights\\Request Duration";
      QuickPulseCounter2["DEPENDENCY_RATE"] = "\\ApplicationInsights\\Dependency Calls/Sec";
      QuickPulseCounter2["DEPENDENCY_FAILURE_RATE"] = "\\ApplicationInsights\\Dependency Calls Failed/Sec";
      QuickPulseCounter2["DEPENDENCY_DURATION"] = "\\ApplicationInsights\\Dependency Call Duration";
      QuickPulseCounter2["EXCEPTION_RATE"] = "\\ApplicationInsights\\Exceptions/Sec";
    })(QuickPulseCounter = exports2.QuickPulseCounter || (exports2.QuickPulseCounter = {}));
    var PerformanceCounter;
    (function(PerformanceCounter2) {
      PerformanceCounter2["PRIVATE_BYTES"] = "\\Process(??APP_WIN32_PROC??)\\Private Bytes";
      PerformanceCounter2["AVAILABLE_BYTES"] = "\\Memory\\Available Bytes";
      PerformanceCounter2["PROCESSOR_TIME"] = "\\Processor(_Total)\\% Processor Time";
      PerformanceCounter2["PROCESS_TIME"] = "\\Process(??APP_WIN32_PROC??)\\% Processor Time";
      PerformanceCounter2["REQUEST_RATE"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Requests/Sec";
      PerformanceCounter2["REQUEST_DURATION"] = "\\ASP.NET Applications(??APP_W3SVC_PROC??)\\Request Execution Time";
    })(PerformanceCounter = exports2.PerformanceCounter || (exports2.PerformanceCounter = {}));
    var MetricId;
    (function(MetricId2) {
      MetricId2["REQUESTS_DURATION"] = "requests/duration";
      MetricId2["DEPENDENCIES_DURATION"] = "dependencies/duration";
      MetricId2["EXCEPTIONS_COUNT"] = "exceptions/count";
      MetricId2["TRACES_COUNT"] = "traces/count";
    })(MetricId = exports2.MetricId || (exports2.MetricId = {}));
    exports2.PerformanceToQuickPulseCounter = (_a = {}, _a[PerformanceCounter.PROCESSOR_TIME] = QuickPulseCounter.PROCESSOR_TIME, _a[PerformanceCounter.REQUEST_RATE] = QuickPulseCounter.REQUEST_RATE, _a[PerformanceCounter.REQUEST_DURATION] = QuickPulseCounter.REQUEST_DURATION, // Remap quick pulse only counters
    _a[QuickPulseCounter.COMMITTED_BYTES] = QuickPulseCounter.COMMITTED_BYTES, _a[QuickPulseCounter.REQUEST_FAILURE_RATE] = QuickPulseCounter.REQUEST_FAILURE_RATE, _a[QuickPulseCounter.DEPENDENCY_RATE] = QuickPulseCounter.DEPENDENCY_RATE, _a[QuickPulseCounter.DEPENDENCY_FAILURE_RATE] = QuickPulseCounter.DEPENDENCY_FAILURE_RATE, _a[QuickPulseCounter.DEPENDENCY_DURATION] = QuickPulseCounter.DEPENDENCY_DURATION, _a[QuickPulseCounter.EXCEPTION_RATE] = QuickPulseCounter.EXCEPTION_RATE, _a);
    exports2.QuickPulseDocumentType = {
      Event: "Event",
      Exception: "Exception",
      Trace: "Trace",
      Metric: "Metric",
      Request: "Request",
      Dependency: "RemoteDependency",
      Availability: "Availability",
      PageView: "PageView"
    };
    exports2.QuickPulseType = {
      Event: "EventTelemetryDocument",
      Exception: "ExceptionTelemetryDocument",
      Trace: "TraceTelemetryDocument",
      Metric: "MetricTelemetryDocument",
      Request: "RequestTelemetryDocument",
      Dependency: "DependencyTelemetryDocument",
      Availability: "AvailabilityTelemetryDocument",
      PageView: "PageViewTelemetryDocument"
    };
    exports2.TelemetryTypeStringToQuickPulseType = {
      EventData: exports2.QuickPulseType.Event,
      ExceptionData: exports2.QuickPulseType.Exception,
      MessageData: exports2.QuickPulseType.Trace,
      MetricData: exports2.QuickPulseType.Metric,
      RequestData: exports2.QuickPulseType.Request,
      RemoteDependencyData: exports2.QuickPulseType.Dependency,
      AvailabilityData: exports2.QuickPulseType.Availability,
      PageViewData: exports2.QuickPulseType.PageView
    };
    exports2.TelemetryTypeStringToQuickPulseDocumentType = {
      EventData: exports2.QuickPulseDocumentType.Event,
      ExceptionData: exports2.QuickPulseDocumentType.Exception,
      MessageData: exports2.QuickPulseDocumentType.Trace,
      MetricData: exports2.QuickPulseDocumentType.Metric,
      RequestData: exports2.QuickPulseDocumentType.Request,
      RemoteDependencyData: exports2.QuickPulseDocumentType.Dependency,
      AvailabilityData: exports2.QuickPulseDocumentType.Availability,
      PageViewData: exports2.QuickPulseDocumentType.PageView
    };
    exports2.DependencyTypeName = {
      Grpc: "GRPC",
      Http: "HTTP",
      InProc: "InProc",
      Sql: "SQL",
      QueueMessage: "Queue Message"
    };
    exports2.HeartBeatMetricName = "HeartBeat";
    exports2.StatsbeatTelemetryName = "Statsbeat";
    exports2.StatsbeatResourceProvider = {
      appsvc: "appsvc",
      functions: "functions",
      vm: "vm",
      unknown: "unknown"
    };
    exports2.StatsbeatAttach = {
      codeless: "codeless",
      sdk: "sdk"
    };
    exports2.StatsbeatCounter = {
      REQUEST_SUCCESS: "Request Success Count",
      REQUEST_FAILURE: "Request Failure Count",
      REQUEST_DURATION: "Request Duration",
      RETRY_COUNT: "Retry Count",
      THROTTLE_COUNT: "Throttle Count",
      EXCEPTION_COUNT: "Exception Count",
      ATTACH: "Attach",
      FEATURE: "Feature"
    };
    var StatsbeatFeature;
    (function(StatsbeatFeature2) {
      StatsbeatFeature2[StatsbeatFeature2["NONE"] = 0] = "NONE";
      StatsbeatFeature2[StatsbeatFeature2["DISK_RETRY"] = 1] = "DISK_RETRY";
      StatsbeatFeature2[StatsbeatFeature2["AAD_HANDLING"] = 2] = "AAD_HANDLING";
      StatsbeatFeature2[StatsbeatFeature2["WEB_SNIPPET"] = 4] = "WEB_SNIPPET";
    })(StatsbeatFeature = exports2.StatsbeatFeature || (exports2.StatsbeatFeature = {}));
    var StatsbeatInstrumentation;
    (function(StatsbeatInstrumentation2) {
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["NONE"] = 0] = "NONE";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["AZURE_CORE_TRACING"] = 1] = "AZURE_CORE_TRACING";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["MONGODB"] = 2] = "MONGODB";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["MYSQL"] = 4] = "MYSQL";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["REDIS"] = 8] = "REDIS";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["POSTGRES"] = 16] = "POSTGRES";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["BUNYAN"] = 32] = "BUNYAN";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["WINSTON"] = 64] = "WINSTON";
      StatsbeatInstrumentation2[StatsbeatInstrumentation2["CONSOLE"] = 128] = "CONSOLE";
    })(StatsbeatInstrumentation = exports2.StatsbeatInstrumentation || (exports2.StatsbeatInstrumentation = {}));
    var StatsbeatFeatureType;
    (function(StatsbeatFeatureType2) {
      StatsbeatFeatureType2[StatsbeatFeatureType2["Feature"] = 0] = "Feature";
      StatsbeatFeatureType2[StatsbeatFeatureType2["Instrumentation"] = 1] = "Instrumentation";
    })(StatsbeatFeatureType = exports2.StatsbeatFeatureType || (exports2.StatsbeatFeatureType = {}));
    var StatsbeatNetworkCategory;
    (function(StatsbeatNetworkCategory2) {
      StatsbeatNetworkCategory2[StatsbeatNetworkCategory2["Breeze"] = 0] = "Breeze";
      StatsbeatNetworkCategory2[StatsbeatNetworkCategory2["Quickpulse"] = 1] = "Quickpulse";
    })(StatsbeatNetworkCategory = exports2.StatsbeatNetworkCategory || (exports2.StatsbeatNetworkCategory = {}));
    exports2.AzNamespace = "az.namespace";
    exports2.MicrosoftEventHub = "Microsoft.EventHub";
    exports2.MessageBusDestination = "message_bus.destination";
    exports2.ENQUEUED_TIME = "enqueuedTime";
    exports2.TIME_SINCE_ENQUEUED = "timeSinceEnqueued";
    exports2.WEB_INSTRUMENTATION_DEFAULT_SOURCE = "https://js.monitor.azure.com/scripts/b/ai";
    exports2.WEB_INSTRUMENTATION_DEPRECATED_SOURCE = "https://az416426.vo.msecnd.net/scripts/b/ai";
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js
var require_console_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/console.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dispose = exports2.enable = void 0;
    var Contracts_1 = require_Contracts();
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var subscriber = function(event) {
      var message = event.data.message;
      clients.forEach(function(client) {
        if (message instanceof Error) {
          client.trackException({ exception: message });
        } else {
          if (message.lastIndexOf("\n") == message.length - 1) {
            message = message.substring(0, message.length - 1);
          }
          client.trackTrace({ message, severity: event.data.stderr ? Contracts_1.SeverityLevel.Warning : Contracts_1.SeverityLevel.Information });
        }
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("console", subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.CONSOLE);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("console", subscriber);
        }
      }
    }
    exports2.enable = enable;
    function dispose2() {
      diagnostic_channel_1.channel.unsubscribe("console", subscriber);
      clients = [];
    }
    exports2.dispose = dispose2;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js
var require_bunyan_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/bunyan.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dispose = exports2.enable = void 0;
    var Contracts_1 = require_Contracts();
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var bunyanToAILevelMap = {
      10: Contracts_1.SeverityLevel.Verbose,
      20: Contracts_1.SeverityLevel.Verbose,
      30: Contracts_1.SeverityLevel.Information,
      40: Contracts_1.SeverityLevel.Warning,
      50: Contracts_1.SeverityLevel.Error,
      60: Contracts_1.SeverityLevel.Critical
    };
    var subscriber = function(event) {
      var message = event.data.result;
      clients.forEach(function(client) {
        try {
          var log = JSON.parse(message);
          if (log.err) {
            var bunyanError = new Error(log.err.message);
            bunyanError.name = log.err.name;
            bunyanError.stack = log.err.stack;
            client.trackException({ exception: bunyanError });
            return;
          }
        } catch (err) {
        }
        var AIlevel = bunyanToAILevelMap[event.data.level];
        client.trackTrace({ message, severity: AIlevel });
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("bunyan", subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.BUNYAN);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
        }
      }
    }
    exports2.enable = enable;
    function dispose2() {
      diagnostic_channel_1.channel.unsubscribe("bunyan", subscriber);
      clients = [];
    }
    exports2.dispose = dispose2;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js
var require_winston_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/winston.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dispose = exports2.enable = void 0;
    var Constants_1 = require_Constants2();
    var Contracts_1 = require_Contracts();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var winstonToAILevelMap = {
      syslog: function(og) {
        var map = {
          emerg: Contracts_1.SeverityLevel.Critical,
          alert: Contracts_1.SeverityLevel.Critical,
          crit: Contracts_1.SeverityLevel.Critical,
          error: Contracts_1.SeverityLevel.Error,
          warning: Contracts_1.SeverityLevel.Warning,
          notice: Contracts_1.SeverityLevel.Information,
          info: Contracts_1.SeverityLevel.Information,
          debug: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === void 0 ? Contracts_1.SeverityLevel.Information : map[og];
      },
      npm: function(og) {
        var map = {
          error: Contracts_1.SeverityLevel.Error,
          warn: Contracts_1.SeverityLevel.Warning,
          info: Contracts_1.SeverityLevel.Information,
          verbose: Contracts_1.SeverityLevel.Verbose,
          debug: Contracts_1.SeverityLevel.Verbose,
          silly: Contracts_1.SeverityLevel.Verbose
        };
        return map[og] === void 0 ? Contracts_1.SeverityLevel.Information : map[og];
      },
      unknown: function(og) {
        return Contracts_1.SeverityLevel.Information;
      }
    };
    var subscriber = function(event) {
      var message = event.data.message;
      clients.forEach(function(client) {
        if (message instanceof Error) {
          client.trackException({
            exception: message,
            properties: event.data.meta
          });
        } else {
          var AIlevel = winstonToAILevelMap[event.data.levelKind](event.data.level);
          client.trackTrace({
            message,
            severity: AIlevel,
            properties: event.data.meta
          });
        }
      });
    };
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("winston", subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.WINSTON);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
        }
      }
    }
    exports2.enable = enable;
    function dispose2() {
      diagnostic_channel_1.channel.unsubscribe("winston", subscriber);
      clients = [];
    }
    exports2.dispose = dispose2;
  }
});

// node_modules/applicationinsights/out/AutoCollection/Console.js
var require_Console = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/Console.js"(exports2, module2) {
    "use strict";
    var DiagChannel = require_initialization();
    var AutoCollectConsole = (
      /** @class */
      function() {
        function AutoCollectConsole2(client) {
          if (!!AutoCollectConsole2.INSTANCE) {
            throw new Error("Console logging adapter tracking should be configured from the applicationInsights object");
          }
          this._client = client;
          AutoCollectConsole2.INSTANCE = this;
        }
        AutoCollectConsole2.prototype.enable = function(isEnabled, collectConsoleLog) {
          if (DiagChannel.IsInitialized) {
            require_console_sub().enable(isEnabled && collectConsoleLog, this._client);
            require_bunyan_sub().enable(isEnabled, this._client);
            require_winston_sub().enable(isEnabled, this._client);
          }
        };
        AutoCollectConsole2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        AutoCollectConsole2.prototype.dispose = function() {
          AutoCollectConsole2.INSTANCE = null;
          this.enable(false, false);
        };
        AutoCollectConsole2._methodNames = ["debug", "info", "log", "warn", "error"];
        return AutoCollectConsole2;
      }()
    );
    module2.exports = AutoCollectConsole;
  }
});

// node_modules/applicationinsights/out/AutoCollection/Exceptions.js
var require_Exceptions = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/Exceptions.js"(exports2, module2) {
    "use strict";
    var AutoCollectExceptions = (
      /** @class */
      function() {
        function AutoCollectExceptions2(client) {
          if (!!AutoCollectExceptions2.INSTANCE) {
            throw new Error("Exception tracking should be configured from the applicationInsights object");
          }
          AutoCollectExceptions2.INSTANCE = this;
          this._client = client;
          var nodeVer = process.versions.node.split(".");
          AutoCollectExceptions2._canUseUncaughtExceptionMonitor = parseInt(nodeVer[0]) > 13 || parseInt(nodeVer[0]) === 13 && parseInt(nodeVer[1]) >= 7;
        }
        AutoCollectExceptions2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        AutoCollectExceptions2.prototype.enable = function(isEnabled) {
          var _this = this;
          if (isEnabled) {
            this._isInitialized = true;
            if (!this._exceptionListenerHandle) {
              var handle = function(reThrow, name2, error) {
                if (error === void 0) {
                  error = new Error(AutoCollectExceptions2._FALLBACK_ERROR_MESSAGE);
                }
                var exceptionTelemetry = { exception: error };
                exceptionTelemetry.contextObjects = {};
                exceptionTelemetry.contextObjects["Error"] = error;
                _this._client.trackException(exceptionTelemetry);
                _this._client.flush({ isAppCrashing: true });
                if (reThrow && name2 && process.listeners(name2).length === 1) {
                  console.error(error);
                  process.exit(1);
                }
              };
              if (AutoCollectExceptions2._canUseUncaughtExceptionMonitor) {
                this._exceptionListenerHandle = handle.bind(this, false, void 0);
                process.on(AutoCollectExceptions2.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle);
              } else {
                this._exceptionListenerHandle = handle.bind(this, true, AutoCollectExceptions2.UNCAUGHT_EXCEPTION_HANDLER_NAME);
                this._rejectionListenerHandle = handle.bind(this, false, void 0);
                process.on(AutoCollectExceptions2.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
                process.on(AutoCollectExceptions2.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
              }
            }
          } else {
            if (this._exceptionListenerHandle) {
              if (AutoCollectExceptions2._canUseUncaughtExceptionMonitor) {
                process.removeListener(AutoCollectExceptions2.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle);
              } else {
                process.removeListener(AutoCollectExceptions2.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle);
                process.removeListener(AutoCollectExceptions2.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle);
              }
              this._exceptionListenerHandle = void 0;
              this._rejectionListenerHandle = void 0;
              delete this._exceptionListenerHandle;
              delete this._rejectionListenerHandle;
            }
          }
        };
        AutoCollectExceptions2.prototype.dispose = function() {
          AutoCollectExceptions2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
        };
        AutoCollectExceptions2.INSTANCE = null;
        AutoCollectExceptions2.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = "uncaughtExceptionMonitor";
        AutoCollectExceptions2.UNCAUGHT_EXCEPTION_HANDLER_NAME = "uncaughtException";
        AutoCollectExceptions2.UNHANDLED_REJECTION_HANDLER_NAME = "unhandledRejection";
        AutoCollectExceptions2._RETHROW_EXIT_MESSAGE = "Application Insights Rethrow Exception Handler";
        AutoCollectExceptions2._FALLBACK_ERROR_MESSAGE = "A promise was rejected without providing an error. Application Insights generated this error stack for you.";
        AutoCollectExceptions2._canUseUncaughtExceptionMonitor = false;
        return AutoCollectExceptions2;
      }()
    );
    module2.exports = AutoCollectExceptions;
  }
});

// node_modules/applicationinsights/out/AutoCollection/Performance.js
var require_Performance = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/Performance.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var Constants = require_Constants2();
    var AutoCollectPerformance = (
      /** @class */
      function() {
        function AutoCollectPerformance2(client, collectionInterval, enableLiveMetricsCounters) {
          if (collectionInterval === void 0) {
            collectionInterval = 6e4;
          }
          if (enableLiveMetricsCounters === void 0) {
            enableLiveMetricsCounters = false;
          }
          this._lastIntervalRequestExecutionTime = 0;
          this._lastIntervalDependencyExecutionTime = 0;
          if (!AutoCollectPerformance2.INSTANCE) {
            AutoCollectPerformance2.INSTANCE = this;
          }
          this._lastRequests = { totalRequestCount: 0, totalFailedRequestCount: 0, time: 0 };
          this._lastDependencies = { totalDependencyCount: 0, totalFailedDependencyCount: 0, time: 0 };
          this._lastExceptions = { totalExceptionCount: 0, time: 0 };
          this._isInitialized = false;
          this._client = client;
          this._collectionInterval = collectionInterval;
          this._enableLiveMetricsCounters = enableLiveMetricsCounters;
        }
        AutoCollectPerformance2.prototype.enable = function(isEnabled, collectionInterval) {
          var _this = this;
          this._isEnabled = isEnabled;
          if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
          }
          if (isEnabled) {
            if (!this._handle) {
              this._lastCpus = os.cpus();
              this._lastRequests = {
                totalRequestCount: AutoCollectPerformance2._totalRequestCount,
                totalFailedRequestCount: AutoCollectPerformance2._totalFailedRequestCount,
                time: +/* @__PURE__ */ new Date()
              };
              this._lastDependencies = {
                totalDependencyCount: AutoCollectPerformance2._totalDependencyCount,
                totalFailedDependencyCount: AutoCollectPerformance2._totalFailedDependencyCount,
                time: +/* @__PURE__ */ new Date()
              };
              this._lastExceptions = {
                totalExceptionCount: AutoCollectPerformance2._totalExceptionCount,
                time: +/* @__PURE__ */ new Date()
              };
              if (typeof process.cpuUsage === "function") {
                this._lastAppCpuUsage = process.cpuUsage();
              }
              this._lastHrtime = process.hrtime();
              this._collectionInterval = collectionInterval || this._collectionInterval;
              this._handle = setInterval(function() {
                return _this.trackPerformance();
              }, this._collectionInterval);
              this._handle.unref();
            }
          } else {
            if (this._handle) {
              clearInterval(this._handle);
              this._handle = void 0;
            }
          }
        };
        AutoCollectPerformance2.countRequest = function(duration, success) {
          var durationMs;
          if (!AutoCollectPerformance2.isEnabled()) {
            return;
          }
          if (typeof duration === "string") {
            durationMs = +/* @__PURE__ */ new Date("1970-01-01T" + duration + "Z");
          } else if (typeof duration === "number") {
            durationMs = duration;
          } else {
            return;
          }
          AutoCollectPerformance2._intervalRequestExecutionTime += durationMs;
          if (success === false) {
            AutoCollectPerformance2._totalFailedRequestCount++;
          }
          AutoCollectPerformance2._totalRequestCount++;
        };
        AutoCollectPerformance2.countException = function() {
          AutoCollectPerformance2._totalExceptionCount++;
        };
        AutoCollectPerformance2.countDependency = function(duration, success) {
          var durationMs;
          if (!AutoCollectPerformance2.isEnabled()) {
            return;
          }
          if (typeof duration === "string") {
            durationMs = +/* @__PURE__ */ new Date("1970-01-01T" + duration + "Z");
          } else if (typeof duration === "number") {
            durationMs = duration;
          } else {
            return;
          }
          AutoCollectPerformance2._intervalDependencyExecutionTime += durationMs;
          if (success === false) {
            AutoCollectPerformance2._totalFailedDependencyCount++;
          }
          AutoCollectPerformance2._totalDependencyCount++;
        };
        AutoCollectPerformance2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        AutoCollectPerformance2.isEnabled = function() {
          return AutoCollectPerformance2.INSTANCE && AutoCollectPerformance2.INSTANCE._isEnabled;
        };
        AutoCollectPerformance2.prototype.trackPerformance = function() {
          this._trackCpu();
          this._trackMemory();
          this._trackNetwork();
          this._trackDependencyRate();
          this._trackExceptionRate();
        };
        AutoCollectPerformance2.prototype._trackCpu = function() {
          var cpus = os.cpus();
          if (cpus && cpus.length && this._lastCpus && cpus.length === this._lastCpus.length) {
            var totalUser = 0;
            var totalSys = 0;
            var totalNice = 0;
            var totalIdle = 0;
            var totalIrq = 0;
            for (var i = 0; !!cpus && i < cpus.length; i++) {
              var cpu = cpus[i];
              var lastCpu = this._lastCpus[i];
              var name2 = "% cpu(" + i + ") ";
              var model = cpu.model;
              var speed = cpu.speed;
              var times = cpu.times;
              var lastTimes = lastCpu.times;
              var user = times.user - lastTimes.user || 0;
              totalUser += user;
              var sys = times.sys - lastTimes.sys || 0;
              totalSys += sys;
              var nice = times.nice - lastTimes.nice || 0;
              totalNice += nice;
              var idle = times.idle - lastTimes.idle || 0;
              totalIdle += idle;
              var irq = times.irq - lastTimes.irq || 0;
              totalIrq += irq;
            }
            var appCpuPercent = void 0;
            if (typeof process.cpuUsage === "function") {
              var appCpuUsage = process.cpuUsage();
              var hrtime = process.hrtime();
              var totalApp = appCpuUsage.user - this._lastAppCpuUsage.user + (appCpuUsage.system - this._lastAppCpuUsage.system) || 0;
              if (typeof this._lastHrtime !== "undefined" && this._lastHrtime.length === 2) {
                var elapsedTime = (hrtime[0] - this._lastHrtime[0]) * 1e6 + (hrtime[1] - this._lastHrtime[1]) / 1e3 || 0;
                appCpuPercent = 100 * totalApp / (elapsedTime * cpus.length);
              }
              this._lastAppCpuUsage = appCpuUsage;
              this._lastHrtime = hrtime;
            }
            var combinedTotal = totalUser + totalSys + totalNice + totalIdle + totalIrq || 1;
            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESSOR_TIME, value: (combinedTotal - totalIdle) / combinedTotal * 100 });
            this._client.trackMetric({ name: Constants.PerformanceCounter.PROCESS_TIME, value: appCpuPercent || totalUser / combinedTotal * 100 });
          }
          this._lastCpus = cpus;
        };
        AutoCollectPerformance2.prototype._trackMemory = function() {
          var freeMem = os.freemem();
          var usedMem = process.memoryUsage().rss;
          var committedMemory = os.totalmem() - freeMem;
          this._client.trackMetric({ name: Constants.PerformanceCounter.PRIVATE_BYTES, value: usedMem });
          this._client.trackMetric({ name: Constants.PerformanceCounter.AVAILABLE_BYTES, value: freeMem });
          if (this._enableLiveMetricsCounters) {
            this._client.trackMetric({ name: Constants.QuickPulseCounter.COMMITTED_BYTES, value: committedMemory });
          }
        };
        AutoCollectPerformance2.prototype._trackNetwork = function() {
          var lastRequests = this._lastRequests;
          var requests = {
            totalRequestCount: AutoCollectPerformance2._totalRequestCount,
            totalFailedRequestCount: AutoCollectPerformance2._totalFailedRequestCount,
            time: +/* @__PURE__ */ new Date()
          };
          var intervalRequests = requests.totalRequestCount - lastRequests.totalRequestCount || 0;
          var intervalFailedRequests = requests.totalFailedRequestCount - lastRequests.totalFailedRequestCount || 0;
          var elapsedMs = requests.time - lastRequests.time;
          var elapsedSeconds = elapsedMs / 1e3;
          var averageRequestExecutionTime = (AutoCollectPerformance2._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / intervalRequests || 0;
          this._lastIntervalRequestExecutionTime = AutoCollectPerformance2._intervalRequestExecutionTime;
          if (elapsedMs > 0) {
            var requestsPerSec = intervalRequests / elapsedSeconds;
            var failedRequestsPerSec = intervalFailedRequests / elapsedSeconds;
            this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_RATE, value: requestsPerSec });
            if (!this._enableLiveMetricsCounters || intervalRequests > 0) {
              this._client.trackMetric({ name: Constants.PerformanceCounter.REQUEST_DURATION, value: averageRequestExecutionTime });
            }
            if (this._enableLiveMetricsCounters) {
              this._client.trackMetric({ name: Constants.QuickPulseCounter.REQUEST_FAILURE_RATE, value: failedRequestsPerSec });
            }
          }
          this._lastRequests = requests;
        };
        AutoCollectPerformance2.prototype._trackDependencyRate = function() {
          if (this._enableLiveMetricsCounters) {
            var lastDependencies = this._lastDependencies;
            var dependencies = {
              totalDependencyCount: AutoCollectPerformance2._totalDependencyCount,
              totalFailedDependencyCount: AutoCollectPerformance2._totalFailedDependencyCount,
              time: +/* @__PURE__ */ new Date()
            };
            var intervalDependencies = dependencies.totalDependencyCount - lastDependencies.totalDependencyCount || 0;
            var intervalFailedDependencies = dependencies.totalFailedDependencyCount - lastDependencies.totalFailedDependencyCount || 0;
            var elapsedMs = dependencies.time - lastDependencies.time;
            var elapsedSeconds = elapsedMs / 1e3;
            var averageDependencyExecutionTime = (AutoCollectPerformance2._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / intervalDependencies || 0;
            this._lastIntervalDependencyExecutionTime = AutoCollectPerformance2._intervalDependencyExecutionTime;
            if (elapsedMs > 0) {
              var dependenciesPerSec = intervalDependencies / elapsedSeconds;
              var failedDependenciesPerSec = intervalFailedDependencies / elapsedSeconds;
              this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_RATE, value: dependenciesPerSec });
              this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_FAILURE_RATE, value: failedDependenciesPerSec });
              if (!this._enableLiveMetricsCounters || intervalDependencies > 0) {
                this._client.trackMetric({ name: Constants.QuickPulseCounter.DEPENDENCY_DURATION, value: averageDependencyExecutionTime });
              }
            }
            this._lastDependencies = dependencies;
          }
        };
        AutoCollectPerformance2.prototype._trackExceptionRate = function() {
          if (this._enableLiveMetricsCounters) {
            var lastExceptions = this._lastExceptions;
            var exceptions = {
              totalExceptionCount: AutoCollectPerformance2._totalExceptionCount,
              time: +/* @__PURE__ */ new Date()
            };
            var intervalExceptions = exceptions.totalExceptionCount - lastExceptions.totalExceptionCount || 0;
            var elapsedMs = exceptions.time - lastExceptions.time;
            var elapsedSeconds = elapsedMs / 1e3;
            if (elapsedMs > 0) {
              var exceptionsPerSec = intervalExceptions / elapsedSeconds;
              this._client.trackMetric({ name: Constants.QuickPulseCounter.EXCEPTION_RATE, value: exceptionsPerSec });
            }
            this._lastExceptions = exceptions;
          }
        };
        AutoCollectPerformance2.prototype.dispose = function() {
          AutoCollectPerformance2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
        };
        AutoCollectPerformance2._totalRequestCount = 0;
        AutoCollectPerformance2._totalFailedRequestCount = 0;
        AutoCollectPerformance2._totalDependencyCount = 0;
        AutoCollectPerformance2._totalFailedDependencyCount = 0;
        AutoCollectPerformance2._totalExceptionCount = 0;
        AutoCollectPerformance2._intervalDependencyExecutionTime = 0;
        AutoCollectPerformance2._intervalRequestExecutionTime = 0;
        return AutoCollectPerformance2;
      }()
    );
    module2.exports = AutoCollectPerformance;
  }
});

// node_modules/applicationinsights/out/Declarations/Metrics/AggregatedMetricCounters.js
var require_AggregatedMetricCounters = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Metrics/AggregatedMetricCounters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AggregatedMetricCounter = void 0;
    var AggregatedMetricCounter = (
      /** @class */
      function() {
        function AggregatedMetricCounter2(dimensions) {
          this.dimensions = dimensions;
          this.totalCount = 0;
          this.lastTotalCount = 0;
          this.intervalExecutionTime = 0;
          this.lastTime = +/* @__PURE__ */ new Date();
          this.lastIntervalExecutionTime = 0;
        }
        return AggregatedMetricCounter2;
      }()
    );
    exports2.AggregatedMetricCounter = AggregatedMetricCounter;
  }
});

// node_modules/applicationinsights/out/Declarations/Metrics/AggregatedMetricDimensions.js
var require_AggregatedMetricDimensions = __commonJS({
  "node_modules/applicationinsights/out/Declarations/Metrics/AggregatedMetricDimensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PreaggregatedMetricPropertyNames = void 0;
    exports2.PreaggregatedMetricPropertyNames = {
      cloudRoleInstance: "cloud/roleInstance",
      cloudRoleName: "cloud/roleName",
      operationSynthetic: "operation/synthetic",
      requestSuccess: "Request.Success",
      requestResultCode: "request/resultCode",
      dependencyType: "Dependency.Type",
      dependencyTarget: "dependency/target",
      dependencySuccess: "Dependency.Success",
      dependencyResultCode: "dependency/resultCode",
      traceSeverityLevel: "trace/severityLevel"
    };
  }
});

// node_modules/applicationinsights/out/AutoCollection/PreAggregatedMetrics.js
var require_PreAggregatedMetrics = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/PreAggregatedMetrics.js"(exports2, module2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var Constants = require_Constants2();
    var AggregatedMetricCounters_1 = require_AggregatedMetricCounters();
    var AggregatedMetricDimensions_1 = require_AggregatedMetricDimensions();
    var AutoCollectPreAggregatedMetrics = (
      /** @class */
      function() {
        function AutoCollectPreAggregatedMetrics2(client, collectionInterval) {
          if (collectionInterval === void 0) {
            collectionInterval = 6e4;
          }
          if (!AutoCollectPreAggregatedMetrics2.INSTANCE) {
            AutoCollectPreAggregatedMetrics2.INSTANCE = this;
          }
          this._isInitialized = false;
          AutoCollectPreAggregatedMetrics2._dependencyCountersCollection = [];
          AutoCollectPreAggregatedMetrics2._requestCountersCollection = [];
          AutoCollectPreAggregatedMetrics2._exceptionCountersCollection = [];
          AutoCollectPreAggregatedMetrics2._traceCountersCollection = [];
          this._client = client;
          this._collectionInterval = collectionInterval;
        }
        AutoCollectPreAggregatedMetrics2.prototype.enable = function(isEnabled, collectionInterval) {
          var _this = this;
          this._isEnabled = isEnabled;
          if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
          }
          if (isEnabled) {
            if (!this._handle) {
              this._collectionInterval = collectionInterval || this._collectionInterval;
              this._handle = setInterval(function() {
                return _this.trackPreAggregatedMetrics();
              }, this._collectionInterval);
              this._handle.unref();
            }
          } else {
            if (this._handle) {
              clearInterval(this._handle);
              this._handle = void 0;
            }
          }
        };
        AutoCollectPreAggregatedMetrics2.countException = function(dimensions) {
          if (!AutoCollectPreAggregatedMetrics2.isEnabled()) {
            return;
          }
          var counter = AutoCollectPreAggregatedMetrics2._getAggregatedCounter(dimensions, this._exceptionCountersCollection);
          counter.totalCount++;
        };
        AutoCollectPreAggregatedMetrics2.countTrace = function(dimensions) {
          if (!AutoCollectPreAggregatedMetrics2.isEnabled()) {
            return;
          }
          var counter = AutoCollectPreAggregatedMetrics2._getAggregatedCounter(dimensions, this._traceCountersCollection);
          counter.totalCount++;
        };
        AutoCollectPreAggregatedMetrics2.countRequest = function(duration, dimensions) {
          if (!AutoCollectPreAggregatedMetrics2.isEnabled()) {
            return;
          }
          var durationMs;
          var counter = AutoCollectPreAggregatedMetrics2._getAggregatedCounter(dimensions, this._requestCountersCollection);
          if (typeof duration === "string") {
            durationMs = +/* @__PURE__ */ new Date("1970-01-01T" + duration + "Z");
          } else if (typeof duration === "number") {
            durationMs = duration;
          } else {
            return;
          }
          counter.intervalExecutionTime += durationMs;
          counter.totalCount++;
        };
        AutoCollectPreAggregatedMetrics2.countDependency = function(duration, dimensions) {
          if (!AutoCollectPreAggregatedMetrics2.isEnabled()) {
            return;
          }
          var counter = AutoCollectPreAggregatedMetrics2._getAggregatedCounter(dimensions, this._dependencyCountersCollection);
          var durationMs;
          if (typeof duration === "string") {
            durationMs = +/* @__PURE__ */ new Date("1970-01-01T" + duration + "Z");
          } else if (typeof duration === "number") {
            durationMs = duration;
          } else {
            return;
          }
          counter.intervalExecutionTime += durationMs;
          counter.totalCount++;
        };
        AutoCollectPreAggregatedMetrics2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        AutoCollectPreAggregatedMetrics2.isEnabled = function() {
          return AutoCollectPreAggregatedMetrics2.INSTANCE && AutoCollectPreAggregatedMetrics2.INSTANCE._isEnabled;
        };
        AutoCollectPreAggregatedMetrics2.prototype.trackPreAggregatedMetrics = function() {
          this._trackRequestMetrics();
          this._trackDependencyMetrics();
          this._trackExceptionMetrics();
          this._trackTraceMetrics();
        };
        AutoCollectPreAggregatedMetrics2._getAggregatedCounter = function(dimensions, counterCollection) {
          var notMatch = false;
          for (var i = 0; i < counterCollection.length; i++) {
            if (dimensions === counterCollection[i].dimensions) {
              return counterCollection[i];
            }
            if (Object.keys(dimensions).length !== Object.keys(counterCollection[i].dimensions).length) {
              continue;
            }
            for (var dim in dimensions) {
              if (dimensions[dim] != counterCollection[i].dimensions[dim]) {
                notMatch = true;
                break;
              }
            }
            if (!notMatch) {
              return counterCollection[i];
            }
            notMatch = false;
          }
          var newCounter = new AggregatedMetricCounters_1.AggregatedMetricCounter(dimensions);
          counterCollection.push(newCounter);
          return newCounter;
        };
        AutoCollectPreAggregatedMetrics2.prototype._trackRequestMetrics = function() {
          for (var i = 0; i < AutoCollectPreAggregatedMetrics2._requestCountersCollection.length; i++) {
            var currentCounter = AutoCollectPreAggregatedMetrics2._requestCountersCollection[i];
            currentCounter.time = +/* @__PURE__ */ new Date();
            var intervalRequests = currentCounter.totalCount - currentCounter.lastTotalCount || 0;
            var elapsedMs = currentCounter.time - currentCounter.lastTime;
            var averageRequestExecutionTime = (currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalRequests || 0;
            currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime;
            if (elapsedMs > 0 && intervalRequests > 0) {
              this._trackPreAggregatedMetric({
                name: "Server response time",
                dimensions: currentCounter.dimensions,
                value: averageRequestExecutionTime,
                count: intervalRequests,
                aggregationInterval: elapsedMs,
                metricType: Constants.MetricId.REQUESTS_DURATION
              });
            }
            currentCounter.lastTotalCount = currentCounter.totalCount;
            currentCounter.lastTime = currentCounter.time;
          }
        };
        AutoCollectPreAggregatedMetrics2.prototype._trackDependencyMetrics = function() {
          for (var i = 0; i < AutoCollectPreAggregatedMetrics2._dependencyCountersCollection.length; i++) {
            var currentCounter = AutoCollectPreAggregatedMetrics2._dependencyCountersCollection[i];
            currentCounter.time = +/* @__PURE__ */ new Date();
            var intervalDependencies = currentCounter.totalCount - currentCounter.lastTotalCount || 0;
            var elapsedMs = currentCounter.time - currentCounter.lastTime;
            var averageDependencyExecutionTime = (currentCounter.intervalExecutionTime - currentCounter.lastIntervalExecutionTime) / intervalDependencies || 0;
            currentCounter.lastIntervalExecutionTime = currentCounter.intervalExecutionTime;
            if (elapsedMs > 0 && intervalDependencies > 0) {
              this._trackPreAggregatedMetric({
                name: "Dependency duration",
                dimensions: currentCounter.dimensions,
                value: averageDependencyExecutionTime,
                count: intervalDependencies,
                aggregationInterval: elapsedMs,
                metricType: Constants.MetricId.DEPENDENCIES_DURATION
              });
            }
            currentCounter.lastTotalCount = currentCounter.totalCount;
            currentCounter.lastTime = currentCounter.time;
          }
        };
        AutoCollectPreAggregatedMetrics2.prototype._trackExceptionMetrics = function() {
          for (var i = 0; i < AutoCollectPreAggregatedMetrics2._exceptionCountersCollection.length; i++) {
            var currentCounter = AutoCollectPreAggregatedMetrics2._exceptionCountersCollection[i];
            currentCounter.time = +/* @__PURE__ */ new Date();
            var intervalExceptions = currentCounter.totalCount - currentCounter.lastTotalCount || 0;
            var elapsedMs = currentCounter.time - currentCounter.lastTime;
            if (elapsedMs > 0 && intervalExceptions > 0) {
              this._trackPreAggregatedMetric({
                name: "Exceptions",
                dimensions: currentCounter.dimensions,
                value: intervalExceptions,
                count: intervalExceptions,
                aggregationInterval: elapsedMs,
                metricType: Constants.MetricId.EXCEPTIONS_COUNT
              });
            }
            currentCounter.lastTotalCount = currentCounter.totalCount;
            currentCounter.lastTime = currentCounter.time;
          }
        };
        AutoCollectPreAggregatedMetrics2.prototype._trackTraceMetrics = function() {
          for (var i = 0; i < AutoCollectPreAggregatedMetrics2._traceCountersCollection.length; i++) {
            var currentCounter = AutoCollectPreAggregatedMetrics2._traceCountersCollection[i];
            currentCounter.time = +/* @__PURE__ */ new Date();
            var intervalTraces = currentCounter.totalCount - currentCounter.lastTotalCount || 0;
            var elapsedMs = currentCounter.time - currentCounter.lastTime;
            if (elapsedMs > 0 && intervalTraces > 0) {
              this._trackPreAggregatedMetric({
                name: "Traces",
                dimensions: currentCounter.dimensions,
                value: intervalTraces,
                count: intervalTraces,
                aggregationInterval: elapsedMs,
                metricType: Constants.MetricId.TRACES_COUNT
              });
            }
            currentCounter.lastTotalCount = currentCounter.totalCount;
            currentCounter.lastTime = currentCounter.time;
          }
        };
        AutoCollectPreAggregatedMetrics2.prototype._trackPreAggregatedMetric = function(metric) {
          var metricProperties = {};
          for (var dim in metric.dimensions) {
            metricProperties[AggregatedMetricDimensions_1.PreaggregatedMetricPropertyNames[dim]] = metric.dimensions[dim];
          }
          metricProperties = __assign2(__assign2({}, metricProperties), { "_MS.MetricId": metric.metricType, "_MS.AggregationIntervalMs": String(metric.aggregationInterval), "_MS.IsAutocollected": "True" });
          var telemetry = {
            name: metric.name,
            value: metric.value,
            count: metric.count,
            properties: metricProperties,
            kind: "Aggregation"
          };
          this._client.trackMetric(telemetry);
        };
        AutoCollectPreAggregatedMetrics2.prototype.dispose = function() {
          AutoCollectPreAggregatedMetrics2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
        };
        return AutoCollectPreAggregatedMetrics2;
      }()
    );
    module2.exports = AutoCollectPreAggregatedMetrics;
  }
});

// node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js
var require_HttpDependencyParser = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/HttpDependencyParser.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var url = require("url");
    var Contracts = require_Contracts();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var RequestParser = require_RequestParser();
    var CorrelationIdManager = require_CorrelationIdManager();
    var HttpDependencyParser = (
      /** @class */
      function(_super) {
        __extends2(HttpDependencyParser2, _super);
        function HttpDependencyParser2(requestOptions, request) {
          var _this = _super.call(this) || this;
          if (request && request.method && requestOptions) {
            _this.method = request.method;
            _this.url = HttpDependencyParser2._getUrlFromRequestOptions(requestOptions, request);
            _this.startTime = +/* @__PURE__ */ new Date();
          }
          return _this;
        }
        HttpDependencyParser2.prototype.onError = function(error) {
          this._setStatus(void 0, error);
        };
        HttpDependencyParser2.prototype.onResponse = function(response) {
          this._setStatus(response.statusCode, void 0);
          this.correlationId = Util.getCorrelationContextTarget(response, RequestResponseHeaders.requestContextTargetKey);
        };
        HttpDependencyParser2.prototype.getDependencyTelemetry = function(baseTelemetry, dependencyId) {
          var dependencyName = this.method.toUpperCase();
          var remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
          var remoteDependencyTarget = "";
          try {
            var urlObject = new url.URL(this.url);
            urlObject.search = void 0;
            urlObject.hash = void 0;
            dependencyName += " " + urlObject.pathname;
            remoteDependencyTarget = urlObject.hostname;
            if (urlObject.port) {
              remoteDependencyTarget += ":" + urlObject.port;
            }
          } catch (ex) {
          }
          if (this.correlationId) {
            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_AI;
            if (this.correlationId !== CorrelationIdManager.correlationIdPrefix) {
              remoteDependencyTarget += " | " + this.correlationId;
            }
          } else {
            remoteDependencyType = Contracts.RemoteDependencyDataConstants.TYPE_HTTP;
          }
          var dependencyTelemetry = {
            id: dependencyId,
            name: dependencyName,
            data: this.url,
            duration: this.duration,
            success: this._isSuccess(),
            resultCode: this.statusCode ? this.statusCode.toString() : null,
            properties: this.properties || {},
            dependencyTypeName: remoteDependencyType,
            target: remoteDependencyTarget
          };
          if (baseTelemetry && baseTelemetry.time) {
            dependencyTelemetry.time = baseTelemetry.time;
          } else if (this.startTime) {
            dependencyTelemetry.time = new Date(this.startTime);
          }
          if (baseTelemetry) {
            for (var key in baseTelemetry) {
              if (!dependencyTelemetry[key]) {
                dependencyTelemetry[key] = baseTelemetry[key];
              }
            }
            if (baseTelemetry.properties) {
              for (var key in baseTelemetry.properties) {
                dependencyTelemetry.properties[key] = baseTelemetry.properties[key];
              }
            }
          }
          return dependencyTelemetry;
        };
        HttpDependencyParser2._getUrlFromRequestOptions = function(options, request) {
          if (typeof options === "string") {
            if (options.indexOf("http://") === 0 || options.indexOf("https://") === 0) {
              try {
                options = new url.URL(options);
              } catch (ex) {
              }
            } else {
              try {
                var parsed = new url.URL("http://" + options);
                if (parsed.port === "443") {
                  options = new url.URL("https://" + options);
                } else {
                  options = new url.URL("http://" + options);
                }
              } catch (ex) {
              }
            }
          } else if (options && typeof url.URL === "function" && options instanceof url.URL) {
            return url.format(options);
          } else {
            var originalOptions_1 = options;
            options = {};
            if (originalOptions_1) {
              Object.keys(originalOptions_1).forEach(function(key) {
                options[key] = originalOptions_1[key];
              });
            }
          }
          if (options.path && options.host) {
            try {
              var parsedQuery = new url.URL(options.path, "http://" + options.host + options.path);
              options.pathname = parsedQuery.pathname;
              options.search = parsedQuery.search;
            } catch (ex) {
            }
          }
          if (options.path && options.hostname && !options.host) {
            try {
              var parsedQuery = new url.URL(options.path, "http://" + options.hostname + options.path);
              options.pathname = parsedQuery.pathname;
              options.search = parsedQuery.search;
            } catch (ex) {
            }
          }
          if (options.host && options.port) {
            try {
              var parsedHost = new url.URL("http://" + options.host);
              if (!parsedHost.port && options.port) {
                options.hostname = options.host;
                delete options.host;
              }
            } catch (ex) {
            }
          }
          options.protocol = options.protocol || request.agent && request.agent.protocol || request.protocol || void 0;
          options.hostname = options.hostname || "localhost";
          return url.format(options);
        };
        return HttpDependencyParser2;
      }(RequestParser)
    );
    module2.exports = HttpDependencyParser;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/Azure/EventHub.js
var require_EventHub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/Azure/EventHub.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseEventHubSpan = void 0;
    var api_1 = require_src();
    var core_1 = require_src3();
    var semantic_conventions_1 = require_src2();
    var Constants_1 = require_Constants2();
    var getTimeSinceEnqueued = function(span) {
      var countEnqueueDiffs = 0;
      var sumEnqueueDiffs = 0;
      var startTimeMs = core_1.hrTimeToMilliseconds(span.startTime);
      span.links.forEach(function(_a) {
        var attributes = _a.attributes;
        var enqueuedTime = attributes === null || attributes === void 0 ? void 0 : attributes[Constants_1.ENQUEUED_TIME];
        if (enqueuedTime) {
          countEnqueueDiffs += 1;
          sumEnqueueDiffs += startTimeMs - (parseFloat(enqueuedTime.toString()) || 0);
        }
      });
      return Math.max(sumEnqueueDiffs / (countEnqueueDiffs || 1), 0);
    };
    var parseEventHubSpan = function(span, telemetry) {
      var _a;
      var namespace = span.attributes[Constants_1.AzNamespace];
      var peerAddress = (span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME] || span.attributes["peer.address"] || "unknown").replace(/\/$/g, "");
      var messageBusDestination = span.attributes[Constants_1.MessageBusDestination] || "unknown";
      switch (span.kind) {
        case api_1.SpanKind.CLIENT:
          telemetry.dependencyTypeName = namespace;
          telemetry.target = peerAddress + "/" + messageBusDestination;
          break;
        case api_1.SpanKind.PRODUCER:
          telemetry.dependencyTypeName = Constants_1.DependencyTypeName.QueueMessage + " | " + namespace;
          telemetry.target = peerAddress + "/" + messageBusDestination;
          break;
        case api_1.SpanKind.CONSUMER:
          telemetry.source = peerAddress + "/" + messageBusDestination;
          telemetry.measurements = __assign2(__assign2({}, telemetry.measurements), (_a = {}, _a[Constants_1.TIME_SINCE_ENQUEUED] = getTimeSinceEnqueued(span), _a));
          break;
        default:
      }
    };
    exports2.parseEventHubSpan = parseEventHubSpan;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/SpanParser.js
var require_SpanParser = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/SpanParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.spanToTelemetryContract = void 0;
    var url_12 = require("url");
    var api_1 = require_src();
    var semantic_conventions_1 = require_src2();
    var Constants = require_Constants2();
    var EventHub_1 = require_EventHub();
    var Util = require_Util();
    function createPropertiesFromSpan(span) {
      var properties = {};
      for (var _i = 0, _a = Object.keys(span.attributes); _i < _a.length; _i++) {
        var key = _a[_i];
        if (!(key.startsWith("http.") || key.startsWith("rpc.") || key.startsWith("db.") || key.startsWith("peer.") || key.startsWith("net."))) {
          properties[key] = span.attributes[key];
        }
      }
      var links = span.links.map(function(link) {
        return {
          operation_Id: link.context.traceId,
          id: link.context.spanId
        };
      });
      if (links.length > 0) {
        properties["_MS.links"] = Util.stringify(links);
      }
      return properties;
    }
    function isSqlDB(dbSystem) {
      return dbSystem === semantic_conventions_1.DbSystemValues.DB2 || dbSystem === semantic_conventions_1.DbSystemValues.DERBY || dbSystem === semantic_conventions_1.DbSystemValues.MARIADB || dbSystem === semantic_conventions_1.DbSystemValues.MSSQL || dbSystem === semantic_conventions_1.DbSystemValues.ORACLE || dbSystem === semantic_conventions_1.DbSystemValues.SQLITE || dbSystem === semantic_conventions_1.DbSystemValues.OTHER_SQL || dbSystem === semantic_conventions_1.DbSystemValues.HSQLDB || dbSystem === semantic_conventions_1.DbSystemValues.H2;
    }
    function getUrl2(span) {
      var httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD];
      if (httpMethod) {
        var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
        if (httpUrl) {
          return String(httpUrl);
        } else {
          var httpScheme = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_SCHEME];
          var httpTarget = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_TARGET];
          if (httpScheme && httpTarget) {
            var httpHost = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_HOST];
            if (httpHost) {
              return httpScheme + "://" + httpHost + httpTarget;
            } else {
              var netPeerPort = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_PORT];
              if (netPeerPort) {
                var netPeerName = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME];
                if (netPeerName) {
                  return httpScheme + "://" + netPeerName + ":" + netPeerPort + httpTarget;
                } else {
                  var netPeerIp = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_IP];
                  if (netPeerIp) {
                    return httpScheme + "://" + netPeerIp + ":" + netPeerPort + httpTarget;
                  }
                }
              }
            }
          }
        }
      }
      return "";
    }
    function getDependencyTarget(span) {
      var peerService = span.attributes[semantic_conventions_1.SemanticAttributes.PEER_SERVICE];
      var httpHost = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_HOST];
      var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
      var netPeerName = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_NAME];
      var netPeerIp = span.attributes[semantic_conventions_1.SemanticAttributes.NET_PEER_IP];
      if (peerService) {
        return String(peerService);
      } else if (httpHost) {
        return String(httpHost);
      } else if (httpUrl) {
        return String(httpUrl);
      } else if (netPeerName) {
        return String(netPeerName);
      } else if (netPeerIp) {
        return String(netPeerIp);
      }
      return "";
    }
    function createDependencyData(span) {
      var remoteDependency = {
        name: span.name,
        success: span.status.code != api_1.SpanStatusCode.ERROR,
        resultCode: "0",
        duration: 0,
        data: "",
        dependencyTypeName: ""
      };
      if (span.kind === api_1.SpanKind.PRODUCER) {
        remoteDependency.dependencyTypeName = Constants.DependencyTypeName.QueueMessage;
      }
      if (span.kind === api_1.SpanKind.INTERNAL && span.parentSpanId) {
        remoteDependency.dependencyTypeName = Constants.DependencyTypeName.InProc;
      }
      var httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD];
      var dbSystem = span.attributes[semantic_conventions_1.SemanticAttributes.DB_SYSTEM];
      var rpcSystem = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_SYSTEM];
      if (httpMethod) {
        remoteDependency.dependencyTypeName = Constants.DependencyTypeName.Http;
        var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
        if (httpUrl) {
          var pathName = "";
          try {
            var dependencyUrl = new url_12.URL(String(httpUrl));
            pathName = dependencyUrl.pathname;
          } catch (ex) {
          }
          remoteDependency.name = httpMethod + " " + pathName;
        }
        remoteDependency.data = getUrl2(span);
        var httpStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE];
        if (httpStatusCode) {
          remoteDependency.resultCode = String(httpStatusCode);
        }
        var target = getDependencyTarget(span);
        if (target) {
          try {
            var portRegex = new RegExp(/(https?)(:\/\/.*)(:\d+)(\S*)/);
            var res = portRegex.exec(target);
            if (res != null) {
              var protocol = res[1];
              var port = res[3];
              if (protocol == "https" && port == ":443" || protocol == "http" && port == ":80") {
                target = res[1] + res[2] + res[4];
              }
            }
          } catch (error) {
          }
          remoteDependency.target = "" + target;
        }
      } else if (dbSystem) {
        if (String(dbSystem) === semantic_conventions_1.DbSystemValues.MYSQL) {
          remoteDependency.dependencyTypeName = "mysql";
        } else if (String(dbSystem) === semantic_conventions_1.DbSystemValues.POSTGRESQL) {
          remoteDependency.dependencyTypeName = "postgresql";
        } else if (String(dbSystem) === semantic_conventions_1.DbSystemValues.MONGODB) {
          remoteDependency.dependencyTypeName = "mongodb";
        } else if (String(dbSystem) === semantic_conventions_1.DbSystemValues.REDIS) {
          remoteDependency.dependencyTypeName = "redis";
        } else if (isSqlDB(String(dbSystem))) {
          remoteDependency.dependencyTypeName = "SQL";
        } else {
          remoteDependency.dependencyTypeName = String(dbSystem);
        }
        var dbStatement = span.attributes[semantic_conventions_1.SemanticAttributes.DB_STATEMENT];
        var dbOperation = span.attributes[semantic_conventions_1.SemanticAttributes.DB_OPERATION];
        if (dbStatement) {
          remoteDependency.data = String(dbStatement);
        } else if (dbOperation) {
          remoteDependency.data = String(dbOperation);
        }
        var target = getDependencyTarget(span);
        var dbName = span.attributes[semantic_conventions_1.SemanticAttributes.DB_NAME];
        if (target) {
          remoteDependency.target = dbName ? target + "|" + dbName : "" + target;
        } else {
          remoteDependency.target = dbName ? "" + dbName : "" + dbSystem;
        }
      } else if (rpcSystem) {
        remoteDependency.dependencyTypeName = Constants.DependencyTypeName.Grpc;
        var grpcStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_GRPC_STATUS_CODE];
        if (grpcStatusCode) {
          remoteDependency.resultCode = String(grpcStatusCode);
        }
        var target = getDependencyTarget(span);
        if (target) {
          remoteDependency.target = "" + target;
        } else if (rpcSystem) {
          remoteDependency.target = String(rpcSystem);
        }
      }
      return remoteDependency;
    }
    function createRequestData(span) {
      var requestData = {
        name: span.name,
        success: span.status.code != api_1.SpanStatusCode.ERROR,
        resultCode: "0",
        duration: 0,
        url: "",
        source: void 0
      };
      var httpMethod = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_METHOD];
      var grpcStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.RPC_GRPC_STATUS_CODE];
      if (httpMethod) {
        if (span.kind == api_1.SpanKind.SERVER) {
          var httpRoute = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_ROUTE];
          var httpUrl = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_URL];
          if (httpRoute) {
            requestData.name = httpMethod + " " + httpRoute;
          } else if (httpUrl) {
            try {
              var url = new url_12.URL(String(httpUrl));
              requestData.name = httpMethod + " " + url.pathname;
            } catch (ex) {
            }
          }
        }
        requestData.url = getUrl2(span);
        var httpStatusCode = span.attributes[semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE];
        if (httpStatusCode) {
          requestData.resultCode = String(httpStatusCode);
        }
      } else if (grpcStatusCode) {
        requestData.resultCode = String(grpcStatusCode);
      }
      return requestData;
    }
    function spanToTelemetryContract(span) {
      var telemetry;
      switch (span.kind) {
        case api_1.SpanKind.CLIENT:
        case api_1.SpanKind.PRODUCER:
        case api_1.SpanKind.INTERNAL:
          telemetry = createDependencyData(span);
          break;
        case api_1.SpanKind.SERVER:
        case api_1.SpanKind.CONSUMER:
          telemetry = createRequestData(span);
          break;
      }
      var spanContext = span.spanContext ? span.spanContext() : span.context();
      var id = "" + spanContext.spanId;
      var duration = Math.round(span.duration[0] * 1e3 + span.duration[1] / 1e6);
      telemetry.id = id;
      telemetry.duration = duration;
      telemetry.properties = createPropertiesFromSpan(span);
      if (span.attributes[Constants.AzNamespace]) {
        if (span.kind === api_1.SpanKind.INTERNAL) {
          telemetry.dependencyTypeName = Constants.DependencyTypeName.InProc + " | " + span.attributes[Constants.AzNamespace];
        }
        if (span.attributes[Constants.AzNamespace] === Constants.MicrosoftEventHub) {
          EventHub_1.parseEventHubSpan(span, telemetry);
        }
      }
      return telemetry;
    }
    exports2.spanToTelemetryContract = spanToTelemetryContract;
  }
});

// node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js
var require_AsyncHooksScopeManager = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/AsyncHooksScopeManager.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AsyncScopeManager = exports2.OpenTelemetryScopeManagerWrapper = void 0;
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var events_1 = require("events");
    var OpenTelemetryScopeManagerWrapper = (
      /** @class */
      function() {
        function OpenTelemetryScopeManagerWrapper2() {
        }
        OpenTelemetryScopeManagerWrapper2.prototype.active = function() {
          var _this = this;
          var context = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          return __assign2(__assign2({}, context), { getValue: function(key) {
            if (!_this._activeSymbol) {
              _this._activeSymbol = key;
              return context;
            }
            if (key === _this._activeSymbol) {
              return context;
            }
            return false;
          }, setValue: function() {
          } });
        };
        OpenTelemetryScopeManagerWrapper2.prototype.with = function(span, fn) {
          var parentSpanId = span.parentSpanId;
          var name2 = span.name;
          var correlationContext = OpenTelemetryScopeManagerWrapper2._spanToContext(span, parentSpanId, name2);
          return CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, fn)();
        };
        OpenTelemetryScopeManagerWrapper2.prototype.bind = function(target) {
          if (typeof target === "function") {
            return CorrelationContextManager_1.CorrelationContextManager.wrapCallback(target);
          } else if (target instanceof events_1.EventEmitter) {
            CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(target);
          }
          return target;
        };
        OpenTelemetryScopeManagerWrapper2.prototype.enable = function() {
          CorrelationContextManager_1.CorrelationContextManager.enable();
          return this;
        };
        OpenTelemetryScopeManagerWrapper2.prototype.disable = function() {
          CorrelationContextManager_1.CorrelationContextManager.disable();
          return this;
        };
        OpenTelemetryScopeManagerWrapper2._spanToContext = function(span, parentSpanId, name2) {
          var spanContext = span.spanContext ? span.spanContext() : span.context();
          var context = __assign2(__assign2({}, span.spanContext()), { traceFlags: span.spanContext().traceFlags });
          var parentId = parentSpanId ? "|" + spanContext.traceId + "." + parentSpanId + "." : spanContext.traceId;
          var aiContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          if (aiContext) {
            context.traceId = aiContext.operation.id;
            if (!parentSpanId) {
              parentId = aiContext.operation.parentId;
            }
          }
          var correlationContext = CorrelationContextManager_1.CorrelationContextManager.spanToContextObject(context, parentId, name2);
          return correlationContext;
        };
        return OpenTelemetryScopeManagerWrapper2;
      }()
    );
    exports2.OpenTelemetryScopeManagerWrapper = OpenTelemetryScopeManagerWrapper;
    exports2.AsyncScopeManager = new OpenTelemetryScopeManagerWrapper();
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/azure-coretracing.sub.js
var require_azure_coretracing_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/azure-coretracing.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.subscriber = void 0;
    var api_1 = require_src();
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var SpanParser = require_SpanParser();
    var AsyncHooksScopeManager_1 = require_AsyncHooksScopeManager();
    var clients = [];
    var subscriber = function(event) {
      try {
        var span_1 = event.data;
        var telemetry_1 = SpanParser.spanToTelemetryContract(span_1);
        AsyncHooksScopeManager_1.AsyncScopeManager.with(span_1, function() {
          clients.forEach(function(client) {
            if (span_1.kind === api_1.SpanKind.SERVER || span_1.kind === api_1.SpanKind.CONSUMER) {
              client.trackRequest(telemetry_1);
            } else if (span_1.kind === api_1.SpanKind.CLIENT || span_1.kind === api_1.SpanKind.INTERNAL || span_1.kind === api_1.SpanKind.PRODUCER) {
              client.trackDependency(telemetry_1);
            }
          });
        });
      } catch (err) {
        {
        }
      }
    };
    exports2.subscriber = subscriber;
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("azure-coretracing", exports2.subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.AZURE_CORE_TRACING);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("azure-coretracing", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js
var require_mongodb_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mongodb.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.subscriber = void 0;
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var subscriber = function(event) {
      if (event.data.event.commandName === "ismaster") {
        return;
      }
      clients.forEach(function(client) {
        var dbName = event.data.startedData && event.data.startedData.databaseName || "Unknown database";
        client.trackDependency({
          target: dbName,
          data: event.data.event.commandName,
          name: event.data.event.commandName,
          duration: event.data.event.duration,
          success: event.data.succeeded,
          /* TODO: transmit result code from mongo */
          resultCode: event.data.succeeded ? "0" : "1",
          time: event.data.startedData.time,
          dependencyTypeName: "mongodb"
        });
      });
    };
    exports2.subscriber = subscriber;
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("mongodb", exports2.subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.MONGODB);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("mongodb", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js
var require_mysql_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/mysql.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.subscriber = void 0;
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var subscriber = function(event) {
      clients.forEach(function(client) {
        var queryObj = event.data.query || {};
        var sqlString = queryObj.sql || "Unknown query";
        var success = !event.data.err;
        var connection = queryObj._connection || {};
        var connectionConfig = connection.config || {};
        var dbName = connectionConfig.socketPath ? connectionConfig.socketPath : (connectionConfig.host || "localhost") + ":" + connectionConfig.port;
        client.trackDependency({
          target: dbName,
          data: sqlString,
          name: sqlString,
          duration: event.data.duration,
          success,
          /* TODO: transmit result code from mysql */
          resultCode: success ? "0" : "1",
          time: event.data.time,
          dependencyTypeName: "mysql"
        });
      });
    };
    exports2.subscriber = subscriber;
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("mysql", exports2.subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.MYSQL);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("mysql", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js
var require_redis_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/redis.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.subscriber = void 0;
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var subscriber = function(event) {
      clients.forEach(function(client) {
        if (event.data.commandObj.command === "info") {
          return;
        }
        client.trackDependency({
          target: event.data.address,
          name: event.data.commandObj.command,
          data: event.data.commandObj.command,
          duration: event.data.duration,
          success: !event.data.err,
          /* TODO: transmit result code from redis */
          resultCode: event.data.err ? "1" : "0",
          time: event.data.time,
          dependencyTypeName: "redis"
        });
      });
    };
    exports2.subscriber = subscriber;
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("redis", exports2.subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.REDIS);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("redis", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js
var require_postgres_sub = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/diagnostic-channel/postgres.sub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enable = exports2.subscriber = void 0;
    var Constants_1 = require_Constants2();
    var diagnostic_channel_1 = require_channel();
    var clients = [];
    var subscriber = function(event) {
      clients.forEach(function(client) {
        var q = event.data.query;
        var sql = q.preparable && q.preparable.text || q.plan || q.text || "unknown query";
        var success = !event.data.error;
        var conn = event.data.database.host + ":" + event.data.database.port;
        client.trackDependency({
          target: conn,
          data: sql,
          name: sql,
          duration: event.data.duration,
          success,
          resultCode: success ? "0" : "1",
          time: event.data.time,
          dependencyTypeName: "postgres"
        });
      });
    };
    exports2.subscriber = subscriber;
    function enable(enabled, client) {
      if (enabled) {
        var clientFound = clients.find(function(c) {
          return c == client;
        });
        if (clientFound) {
          return;
        }
        if (clients.length === 0) {
          diagnostic_channel_1.channel.subscribe("postgres", exports2.subscriber, diagnostic_channel_1.trueFilter, function(module3, version) {
            var statsbeat = client.getStatsbeat();
            if (statsbeat) {
              statsbeat.addInstrumentation(Constants_1.StatsbeatInstrumentation.POSTGRES);
            }
          });
        }
        clients.push(client);
      } else {
        clients = clients.filter(function(c) {
          return c != client;
        });
        if (clients.length === 0) {
          diagnostic_channel_1.channel.unsubscribe("postgres", exports2.subscriber);
        }
      }
    }
    exports2.enable = enable;
  }
});

// node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js
var require_HttpDependencies = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/HttpDependencies.js"(exports2, module2) {
    "use strict";
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    var http = require("http");
    var https = require("https");
    var Logging = require_Logging();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var HttpDependencyParser = require_HttpDependencyParser();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var Traceparent = require_Traceparent();
    var DiagChannel = require_initialization();
    var CorrelationIdManager = require_CorrelationIdManager();
    var AutoCollectHttpDependencies = (
      /** @class */
      function() {
        function AutoCollectHttpDependencies2(client) {
          if (!!AutoCollectHttpDependencies2.INSTANCE) {
            throw new Error("Client request tracking should be configured from the applicationInsights object");
          }
          AutoCollectHttpDependencies2.INSTANCE = this;
          this._client = client;
        }
        AutoCollectHttpDependencies2.prototype.enable = function(isEnabled) {
          this._isEnabled = isEnabled;
          if (this._isEnabled && !this._isInitialized) {
            this._initialize();
          }
          if (DiagChannel.IsInitialized) {
            require_azure_coretracing_sub().enable(isEnabled, this._client);
            require_mongodb_sub().enable(isEnabled, this._client);
            require_mysql_sub().enable(isEnabled, this._client);
            require_redis_sub().enable(isEnabled, this._client);
            require_postgres_sub().enable(isEnabled, this._client);
          }
        };
        AutoCollectHttpDependencies2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        AutoCollectHttpDependencies2.prototype._initialize = function() {
          var _this = this;
          this._isInitialized = true;
          var originalRequest = http.request;
          var originalHttpsRequest = https.request;
          var clientRequestPatch = function(request, options) {
            try {
              var shouldCollect = !options[AutoCollectHttpDependencies2.disableCollectionRequestOption] && !request[AutoCollectHttpDependencies2.alreadyAutoCollectedFlag];
              var userAgentHeader = null;
              if (options.headers) {
                userAgentHeader = options.headers["User-Agent"] || options.headers["user-agent"];
                if (userAgentHeader && userAgentHeader.toString().indexOf("azsdk-js") !== -1) {
                  shouldCollect = false;
                }
              }
              if (request && options && shouldCollect) {
                CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
                if (_this._isEnabled) {
                  request[AutoCollectHttpDependencies2.alreadyAutoCollectedFlag] = true;
                  if (!CorrelationContextManager_1.CorrelationContextManager.getCurrentContext()) {
                    var operationId = null;
                    if (CorrelationIdManager.w3cEnabled) {
                      var traceparent = new Traceparent();
                      operationId = traceparent.traceId;
                    } else {
                      var requestId = CorrelationIdManager.generateRequestId(null);
                      operationId = CorrelationIdManager.getRootId(requestId);
                    }
                    var correlationContext = CorrelationContextManager_1.CorrelationContextManager.generateContextObject(operationId);
                    CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function() {
                      AutoCollectHttpDependencies2.trackRequest(_this._client, { options, request });
                    });
                  } else {
                    AutoCollectHttpDependencies2.trackRequest(_this._client, { options, request });
                  }
                }
              }
            } catch (err) {
              Logging.warn("Failed to generate dependency telemetry.", Util.dumpObj(err));
            }
          };
          http.request = function(options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              requestArgs[_i - 1] = arguments[_i];
            }
            var request = originalRequest.call.apply(originalRequest, __spreadArrays([http, options], requestArgs));
            clientRequestPatch(request, options);
            return request;
          };
          https.request = function(options) {
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              requestArgs[_i - 1] = arguments[_i];
            }
            var request = originalHttpsRequest.call.apply(originalHttpsRequest, __spreadArrays([https, options], requestArgs));
            clientRequestPatch(request, options);
            return request;
          };
          http.get = function(options) {
            var _a;
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              requestArgs[_i - 1] = arguments[_i];
            }
            var request = (_a = http.request).call.apply(_a, __spreadArrays([http, options], requestArgs));
            request.end();
            return request;
          };
          https.get = function(options) {
            var _a;
            var requestArgs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              requestArgs[_i - 1] = arguments[_i];
            }
            var request = (_a = https.request).call.apply(_a, __spreadArrays([https, options], requestArgs));
            request.end();
            return request;
          };
        };
        AutoCollectHttpDependencies2.trackRequest = function(client, telemetry) {
          if (!telemetry.options || !telemetry.request || !client) {
            Logging.info("AutoCollectHttpDependencies.trackRequest was called with invalid parameters: ", !telemetry.options, !telemetry.request, !client);
            return;
          }
          var requestParser = new HttpDependencyParser(telemetry.options, telemetry.request);
          var currentContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          var uniqueRequestId;
          var uniqueTraceparent;
          if (currentContext && currentContext.operation && currentContext.operation.traceparent && Traceparent.isValidTraceId(currentContext.operation.traceparent.traceId)) {
            currentContext.operation.traceparent.updateSpanId();
            uniqueRequestId = currentContext.operation.traceparent.getBackCompatRequestId();
          } else if (CorrelationIdManager.w3cEnabled) {
            var traceparent = new Traceparent();
            uniqueTraceparent = traceparent.toString();
            uniqueRequestId = traceparent.getBackCompatRequestId();
          } else {
            uniqueRequestId = currentContext && currentContext.operation && currentContext.operation.parentId + AutoCollectHttpDependencies2.requestNumber++ + ".";
          }
          if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl()) && telemetry.request.getHeader && telemetry.request.setHeader) {
            if (client.config && client.config.correlationId) {
              var correlationHeader = telemetry.request.getHeader(RequestResponseHeaders.requestContextHeader);
              try {
                Util.safeIncludeCorrelationHeader(client, telemetry.request, correlationHeader);
              } catch (err) {
                Logging.warn("Request-Context header could not be set. Correlation of requests may be lost", err);
              }
              if (currentContext && currentContext.operation) {
                try {
                  telemetry.request.setHeader(RequestResponseHeaders.requestIdHeader, uniqueRequestId);
                  if (!client.config.ignoreLegacyHeaders) {
                    telemetry.request.setHeader(RequestResponseHeaders.parentIdHeader, currentContext.operation.id);
                    telemetry.request.setHeader(RequestResponseHeaders.rootIdHeader, uniqueRequestId);
                  }
                  if (uniqueTraceparent || currentContext.operation.traceparent) {
                    telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, uniqueTraceparent || currentContext.operation.traceparent.toString());
                  } else if (CorrelationIdManager.w3cEnabled) {
                    var traceparent = new Traceparent().toString();
                    telemetry.request.setHeader(RequestResponseHeaders.traceparentHeader, traceparent);
                  }
                  if (currentContext.operation.tracestate) {
                    var tracestate = currentContext.operation.tracestate.toString();
                    if (tracestate) {
                      telemetry.request.setHeader(RequestResponseHeaders.traceStateHeader, tracestate);
                    }
                  }
                  var correlationContextHeader = currentContext.customProperties.serializeToHeader();
                  if (correlationContextHeader) {
                    telemetry.request.setHeader(RequestResponseHeaders.correlationContextHeader, correlationContextHeader);
                  }
                } catch (err) {
                  Logging.warn("Correlation headers could not be set. Correlation of requests may be lost.", err);
                }
              }
            }
          }
          if (telemetry.request.on) {
            telemetry.request.on("response", function(response) {
              if (telemetry.isProcessed) {
                return;
              }
              telemetry.isProcessed = true;
              requestParser.onResponse(response);
              var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
              dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
              dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
              dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
              dependencyTelemetry.contextObjects["http.ClientResponse"] = response;
              client.trackDependency(dependencyTelemetry);
            });
            telemetry.request.on("error", function(error) {
              if (telemetry.isProcessed) {
                return;
              }
              telemetry.isProcessed = true;
              requestParser.onError(error);
              var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
              dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
              dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
              dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
              dependencyTelemetry.contextObjects["Error"] = error;
              client.trackDependency(dependencyTelemetry);
            });
            telemetry.request.on("abort", function() {
              if (telemetry.isProcessed) {
                return;
              }
              telemetry.isProcessed = true;
              requestParser.onError(new Error("The request has been aborted and the network socket has closed."));
              var dependencyTelemetry = requestParser.getDependencyTelemetry(telemetry, uniqueRequestId);
              dependencyTelemetry.contextObjects = dependencyTelemetry.contextObjects || {};
              dependencyTelemetry.contextObjects["http.RequestOptions"] = telemetry.options;
              dependencyTelemetry.contextObjects["http.ClientRequest"] = telemetry.request;
              client.trackDependency(dependencyTelemetry);
            });
          }
        };
        AutoCollectHttpDependencies2.prototype.dispose = function() {
          AutoCollectHttpDependencies2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
        };
        AutoCollectHttpDependencies2.disableCollectionRequestOption = "disableAppInsightsAutoCollection";
        AutoCollectHttpDependencies2.requestNumber = 1;
        AutoCollectHttpDependencies2.alreadyAutoCollectedFlag = "_appInsightsAutoCollected";
        return AutoCollectHttpDependencies2;
      }()
    );
    module2.exports = AutoCollectHttpDependencies;
  }
});

// node_modules/applicationinsights/out/Library/AzureVirtualMachine.js
var require_AzureVirtualMachine = __commonJS({
  "node_modules/applicationinsights/out/Library/AzureVirtualMachine.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureVirtualMachine = void 0;
    var Logging = require_Logging();
    var Util = require_Util();
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var AIMS_URI = "http://169.254.169.254/metadata/instance/compute";
    var AIMS_API_VERSION = "api-version=2017-12-01";
    var AIMS_FORMAT = "format=json";
    var ConnectionErrorMessage = "UNREACH";
    var AzureVirtualMachine = (
      /** @class */
      function() {
        function AzureVirtualMachine2() {
        }
        AzureVirtualMachine2.getAzureComputeMetadata = function(config, callback) {
          var _a;
          var _this = this;
          var vmInfo = {};
          var metadataRequestUrl = AIMS_URI + "?" + AIMS_API_VERSION + "&" + AIMS_FORMAT;
          var requestOptions = (_a = {
            method: "GET"
          }, _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true, _a.headers = {
            "Metadata": "True"
          }, _a);
          var req = Util.makeRequest(config, metadataRequestUrl, requestOptions, function(res) {
            if (res.statusCode === 200) {
              vmInfo.isVM = true;
              var virtualMachineData_1 = "";
              res.on("data", function(data) {
                virtualMachineData_1 += data;
              });
              res.on("end", function() {
                try {
                  var data = JSON.parse(virtualMachineData_1);
                  vmInfo.id = data["vmId"] || "";
                  vmInfo.subscriptionId = data["subscriptionId"] || "";
                  vmInfo.osType = data["osType"] || "";
                } catch (error) {
                  Logging.info(AzureVirtualMachine2.TAG, error);
                }
                callback(vmInfo);
              });
            } else {
              callback(vmInfo);
            }
          }, false, false);
          if (req) {
            setTimeout(function() {
              _this._requestTimedOut = true;
              req.abort();
            }, AzureVirtualMachine2.HTTP_TIMEOUT);
            req.on("error", function(error) {
              if (_this._requestTimedOut) {
                if (error) {
                  error.name = "telemetry timeout";
                  error.message = "telemetry request timed out";
                }
              }
              if (error && error.message && error.message.indexOf(ConnectionErrorMessage) > -1) {
                vmInfo.isVM = false;
              } else {
                Logging.info(AzureVirtualMachine2.TAG, error);
              }
              callback(vmInfo);
            });
            req.end();
          }
        };
        AzureVirtualMachine2.HTTP_TIMEOUT = 2500;
        AzureVirtualMachine2.TAG = "AzureVirtualMachine";
        return AzureVirtualMachine2;
      }()
    );
    exports2.AzureVirtualMachine = AzureVirtualMachine;
  }
});

// node_modules/applicationinsights/out/Library/Context.js
var require_Context = __commonJS({
  "node_modules/applicationinsights/out/Library/Context.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var path2 = require("path");
    var Contracts = require_Contracts();
    var Constants_1 = require_Constants2();
    var Logging = require_Logging();
    var Context = (
      /** @class */
      function() {
        function Context2(packageJsonPath) {
          this.keys = new Contracts.ContextTagKeys();
          this.tags = {};
          this._loadApplicationContext(packageJsonPath);
          this._loadDeviceContext();
          this._loadInternalContext();
        }
        Context2.prototype._loadApplicationContext = function(packageJsonPath) {
          packageJsonPath = packageJsonPath || path2.resolve(__dirname, "../../../../package.json");
          if (!Context2.appVersion[packageJsonPath]) {
            Context2.appVersion[packageJsonPath] = "unknown";
            try {
              var packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));
              if (packageJson && typeof packageJson.version === "string") {
                Context2.appVersion[packageJsonPath] = packageJson.version;
              }
            } catch (exception) {
              Logging.info("unable to read app version: ", exception);
            }
          }
          this.tags[this.keys.applicationVersion] = Context2.appVersion[packageJsonPath];
        };
        Context2.prototype._loadDeviceContext = function() {
          this.tags[this.keys.deviceId] = "";
          this.tags[this.keys.cloudRoleInstance] = os && os.hostname();
          this.tags[this.keys.deviceOSVersion] = os && os.type() + " " + os.release();
          this.tags[this.keys.cloudRole] = Context2.DefaultRoleName;
          this.tags["ai.device.osArchitecture"] = os && os.arch();
          this.tags["ai.device.osPlatform"] = os && os.platform();
        };
        Context2.prototype._loadInternalContext = function() {
          Context2.sdkVersion = Constants_1.APPLICATION_INSIGHTS_SDK_VERSION;
          this.tags[this.keys.internalSdkVersion] = "node:" + Context2.sdkVersion;
        };
        Context2.DefaultRoleName = "Web";
        Context2.appVersion = {};
        Context2.sdkVersion = null;
        return Context2;
      }()
    );
    module2.exports = Context;
  }
});

// node_modules/applicationinsights/out/AutoCollection/HeartBeat.js
var require_HeartBeat = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/HeartBeat.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var Vm = require_AzureVirtualMachine();
    var Constants = require_Constants2();
    var Context = require_Context();
    var HeartBeat = (
      /** @class */
      function() {
        function HeartBeat2(client) {
          this._collectionInterval = 9e5;
          if (!HeartBeat2.INSTANCE) {
            HeartBeat2.INSTANCE = this;
          }
          this._isInitialized = false;
          this._client = client;
        }
        HeartBeat2.prototype.enable = function(isEnabled) {
          var _this = this;
          this._isEnabled = isEnabled;
          if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
          }
          if (isEnabled) {
            if (!this._handle) {
              this._handle = setInterval(function() {
                return _this.trackHeartBeat(_this._client.config, function() {
                });
              }, this._collectionInterval);
              this._handle.unref();
            }
          } else {
            if (this._handle) {
              clearInterval(this._handle);
              this._handle = null;
            }
          }
        };
        HeartBeat2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        HeartBeat2.isEnabled = function() {
          return HeartBeat2.INSTANCE && HeartBeat2.INSTANCE._isEnabled;
        };
        HeartBeat2.prototype.trackHeartBeat = function(config, callback) {
          var _this = this;
          var waiting = false;
          var properties = {};
          var sdkVersion = Context.sdkVersion;
          properties["sdk"] = sdkVersion;
          properties["osType"] = os.type();
          if (process.env.WEBSITE_SITE_NAME) {
            properties["appSrv_SiteName"] = process.env.WEBSITE_SITE_NAME || "";
            properties["appSrv_wsStamp"] = process.env.WEBSITE_HOME_STAMPNAME || "";
            properties["appSrv_wsHost"] = process.env.WEBSITE_HOSTNAME || "";
          } else if (process.env.FUNCTIONS_WORKER_RUNTIME) {
            properties["azfunction_appId"] = process.env.WEBSITE_HOSTNAME;
          } else if (config) {
            if (this._isVM === void 0) {
              waiting = true;
              Vm.AzureVirtualMachine.getAzureComputeMetadata(config, function(vmInfo) {
                _this._isVM = vmInfo.isVM;
                if (_this._isVM) {
                  properties["azInst_vmId"] = vmInfo.id;
                  properties["azInst_subscriptionId"] = vmInfo.subscriptionId;
                  properties["azInst_osType"] = vmInfo.osType;
                }
                _this._client.trackMetric({ name: Constants.HeartBeatMetricName, value: 0, properties });
                callback();
              });
            }
          }
          if (!waiting) {
            this._client.trackMetric({ name: Constants.HeartBeatMetricName, value: 0, properties });
            callback();
          }
        };
        HeartBeat2.prototype.dispose = function() {
          HeartBeat2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
        };
        return HeartBeat2;
      }()
    );
    module2.exports = HeartBeat;
  }
});

// node_modules/applicationinsights/out/Library/SnippetInjectionHelper.js
var require_SnippetInjectionHelper = __commonJS({
  "node_modules/applicationinsights/out/Library/SnippetInjectionHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isContentTypeHeaderHtml = exports2.insertSnippetByIndex = exports2.getContentEncodingFromHeaders = exports2.isSupportedContentEncoding = exports2.findBufferEncodingType = exports2.isBufferType = exports2.getBrotliDecompressSync = exports2.getBrotliDecompressAsync = exports2.getBrotliCompressSync = exports2.getBrotliCompressAsync = exports2.inflateAsync = exports2.deflateAsync = exports2.gunzipAsync = exports2.gzipAsync = exports2.isBrotliSupperted = exports2.bufferEncodingTypes = exports2.contentEncodingMethod = void 0;
    var zlib = require("zlib");
    var util_1 = require("util");
    var contentEncodingMethod;
    (function(contentEncodingMethod2) {
      contentEncodingMethod2["GZIP"] = "gzip";
      contentEncodingMethod2["DEFLATE"] = "deflate";
      contentEncodingMethod2["BR"] = "br";
    })(contentEncodingMethod = exports2.contentEncodingMethod || (exports2.contentEncodingMethod = {}));
    exports2.bufferEncodingTypes = ["utf8", "utf16le", "latin1", "base64", "hex", "ascii", "binary", "ucs2"];
    var isBrotliSupperted = function() {
      var majVer = process.versions.node.split(".")[0];
      return parseInt(majVer) >= 10;
    };
    exports2.isBrotliSupperted = isBrotliSupperted;
    exports2.gzipAsync = util_1.promisify(zlib.gzip);
    exports2.gunzipAsync = util_1.promisify(zlib.gunzip);
    exports2.deflateAsync = util_1.promisify(zlib.deflate);
    exports2.inflateAsync = util_1.promisify(zlib.inflate);
    var getBrotliCompressAsync = function(zlibObject) {
      var isMajorVer = exports2.isBrotliSupperted();
      if (isMajorVer && typeof zlibObject.brotliCompress === "function") {
        return util_1.promisify(zlibObject.brotliCompress);
      }
      return null;
    };
    exports2.getBrotliCompressAsync = getBrotliCompressAsync;
    var getBrotliCompressSync = function(zlibObject) {
      var isMajorVer = exports2.isBrotliSupperted();
      if (isMajorVer && typeof zlibObject.brotliCompressSync === "function") {
        return zlibObject.brotliCompressSync;
      }
      return null;
    };
    exports2.getBrotliCompressSync = getBrotliCompressSync;
    var getBrotliDecompressAsync = function(zlibObject) {
      var isMajorVer = exports2.isBrotliSupperted();
      if (isMajorVer && typeof zlibObject.brotliDecompress === "function") {
        return util_1.promisify(zlibObject.brotliDecompress);
      }
      return null;
    };
    exports2.getBrotliDecompressAsync = getBrotliDecompressAsync;
    var getBrotliDecompressSync = function(zlibObject) {
      var isMajorVer = exports2.isBrotliSupperted();
      if (isMajorVer && typeof zlibObject.brotliDecompressSync === "function") {
        return zlibObject.brotliDecompressSync;
      }
      return null;
    };
    exports2.getBrotliDecompressSync = getBrotliDecompressSync;
    var isBufferType = function(buffer, type) {
      var encodingType = type ? type : "utf8";
      var result = false;
      if (Buffer.isEncoding(encodingType)) {
        var newBuffer = Buffer.from(buffer.toString(encodingType), encodingType);
        result = newBuffer.toJSON().data.toString() === buffer.toJSON().data.toString();
      }
      return result;
    };
    exports2.isBufferType = isBufferType;
    var findBufferEncodingType = function(buffer) {
      var bufferType = null;
      for (var key in exports2.bufferEncodingTypes) {
        var type = exports2.bufferEncodingTypes[key];
        if (Buffer.isEncoding(type) && exports2.isBufferType(buffer, type)) {
          bufferType = type;
          break;
        }
      }
      return bufferType;
    };
    exports2.findBufferEncodingType = findBufferEncodingType;
    var isSupportedContentEncoding = function(encodingMethod) {
      var encodingType = null;
      switch (encodingMethod) {
        case "gzip":
          encodingType = contentEncodingMethod.GZIP;
          break;
        case "br":
          encodingType = contentEncodingMethod.BR;
          break;
        case "deflate":
          encodingType = contentEncodingMethod.DEFLATE;
          break;
        default:
      }
      return encodingType;
    };
    exports2.isSupportedContentEncoding = isSupportedContentEncoding;
    var getContentEncodingFromHeaders = function(response) {
      var headers = [];
      var contentEncodingHeaders = response.getHeader("Content-Encoding");
      if (!contentEncodingHeaders)
        return null;
      if (typeof contentEncodingHeaders === "string") {
        var supportedContentEncoding = exports2.isSupportedContentEncoding(contentEncodingHeaders);
        if (supportedContentEncoding) {
          headers.push(supportedContentEncoding);
        }
      }
      return headers;
    };
    exports2.getContentEncodingFromHeaders = getContentEncodingFromHeaders;
    var insertSnippetByIndex = function(index, html, snippet) {
      if (index < 0)
        return null;
      var newHtml = null;
      var subStart = html.substring(0, index);
      var subEnd = html.substring(index);
      newHtml = subStart + '<script type="text/javascript">' + snippet + "</script>" + subEnd;
      return newHtml;
    };
    exports2.insertSnippetByIndex = insertSnippetByIndex;
    var isContentTypeHeaderHtml = function(response) {
      var isHtml = false;
      var contentType = response.getHeader("Content-Type");
      if (contentType) {
        if (typeof contentType === "string") {
          isHtml = contentType.indexOf("html") >= 0;
        } else {
          isHtml = contentType.toString().indexOf("html") >= 0;
        }
      }
      return isHtml;
    };
    exports2.isContentTypeHeaderHtml = isContentTypeHeaderHtml;
  }
});

// node_modules/applicationinsights/out/Library/PrefixHelper.js
var require_PrefixHelper = __commonJS({
  "node_modules/applicationinsights/out/Library/PrefixHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getResourceProvider = exports2.getOsPrefix = exports2.isFunctionApp = exports2.isWebApp = exports2.isLinux = exports2.isWindows = void 0;
    var isWindows = function() {
      return process.platform === "win32";
    };
    exports2.isWindows = isWindows;
    var isLinux = function() {
      return process.platform === "linux";
    };
    exports2.isLinux = isLinux;
    var isWebApp = function() {
      return process.env.WEBSITE_SITE_NAME ? true : false;
    };
    exports2.isWebApp = isWebApp;
    var isFunctionApp = function() {
      return process.env.FUNCTIONS_WORKER_RUNTIME ? true : false;
    };
    exports2.isFunctionApp = isFunctionApp;
    var getOsPrefix = function() {
      return exports2.isWindows() ? "w" : exports2.isLinux() ? "l" : "u";
    };
    exports2.getOsPrefix = getOsPrefix;
    var getResourceProvider = function() {
      return exports2.isWebApp() ? "a" : exports2.isFunctionApp() ? "f" : "u";
    };
    exports2.getResourceProvider = getResourceProvider;
  }
});

// node_modules/applicationinsights/out/Library/ConnectionStringParser.js
var require_ConnectionStringParser = __commonJS({
  "node_modules/applicationinsights/out/Library/ConnectionStringParser.js"(exports2, module2) {
    "use strict";
    var Constants = require_Constants2();
    var ConnectionStringParser = (
      /** @class */
      function() {
        function ConnectionStringParser2() {
        }
        ConnectionStringParser2.parse = function(connectionString) {
          if (!connectionString) {
            return {};
          }
          var kvPairs = connectionString.split(ConnectionStringParser2._FIELDS_SEPARATOR);
          var result = kvPairs.reduce(function(fields, kv) {
            var kvParts = kv.split(ConnectionStringParser2._FIELD_KEY_VALUE_SEPARATOR);
            if (kvParts.length === 2) {
              var key = kvParts[0].toLowerCase();
              var value = kvParts[1];
              fields[key] = value;
            }
            return fields;
          }, {});
          if (Object.keys(result).length > 0) {
            if (result.endpointsuffix) {
              var locationPrefix = result.location ? result.location + "." : "";
              result.ingestionendpoint = result.ingestionendpoint || "https://" + locationPrefix + "dc." + result.endpointsuffix;
              result.liveendpoint = result.liveendpoint || "https://" + locationPrefix + "live." + result.endpointsuffix;
            }
            result.ingestionendpoint = result.ingestionendpoint || Constants.DEFAULT_BREEZE_ENDPOINT;
            result.liveendpoint = result.liveendpoint || Constants.DEFAULT_LIVEMETRICS_ENDPOINT;
          }
          return result;
        };
        ConnectionStringParser2.isIkeyValid = function(iKey) {
          if (!iKey || iKey == "")
            return false;
          var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
          var regexp = new RegExp(UUID_Regex);
          return regexp.test(iKey);
        };
        ConnectionStringParser2._FIELDS_SEPARATOR = ";";
        ConnectionStringParser2._FIELD_KEY_VALUE_SEPARATOR = "=";
        return ConnectionStringParser2;
      }()
    );
    module2.exports = ConnectionStringParser;
  }
});

// node_modules/@microsoft/applicationinsights-web-snippet/dist/node/applicationinsights-web-snippet.js
var require_applicationinsights_web_snippet = __commonJS({
  "node_modules/@microsoft/applicationinsights-web-snippet/dist/node/applicationinsights-web-snippet.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory((global2.Microsoft = global2.Microsoft || {}, global2.Microsoft["ApplicationInsights-Web-Snippet"] = global2.Microsoft["ApplicationInsights-Web-Snippet"] || {})));
    })(exports2, function(exports3) {
      "use strict";
      var webSnippet = `!function(T,l,y){var S=T.location,k="script",D="instrumentationKey",C="ingestionendpoint",I="disableExceptionTracking",E="ai.device.",b="toLowerCase",w="crossOrigin",N="POST",e="appInsightsSDK",t=y.name||"appInsights";(y.name||T[e])&&(T[e]=t);var n=T[t]||function(d){var g=!1,f=!1,m={initialize:!0,queue:[],sv:"5",version:2,config:d};function v(e,t){var n={},a="Browser";return n[E+"id"]=a[b](),n[E+"type"]=a,n["ai.operation.name"]=S&&S.pathname||"_unknown_",n["ai.internal.sdkVersion"]="javascript:snippet_"+(m.sv||m.version),{time:function(){var e=new Date;function t(e){var t=""+e;return 1===t.length&&(t="0"+t),t}return e.getUTCFullYear()+"-"+t(1+e.getUTCMonth())+"-"+t(e.getUTCDate())+"T"+t(e.getUTCHours())+":"+t(e.getUTCMinutes())+":"+t(e.getUTCSeconds())+"."+((e.getUTCMilliseconds()/1e3).toFixed(3)+"").slice(2,5)+"Z"}(),iKey:e,name:"Microsoft.ApplicationInsights."+e.replace(/-/g,"")+"."+t,sampleRate:100,tags:n,data:{baseData:{ver:2}}}}var h=d.url||y.src;if(h){function a(e){var t,n,a,i,r,o,s,c,u,p,l;g=!0,m.queue=[],f||(f=!0,t=h,s=function(){var e={},t=d.connectionString;if(t)for(var n=t.split(";"),a=0;a<n.length;a++){var i=n[a].split("=");2===i.length&&(e[i[0][b]()]=i[1])}if(!e[C]){var r=e.endpointsuffix,o=r?e.location:null;e[C]="https://"+(o?o+".":"")+"dc."+(r||"services.visualstudio.com")}return e}(),c=s[D]||d[D]||"",u=s[C],p=u?u+"/v2/track":d.endpointUrl,(l=[]).push((n="SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details)",a=t,i=p,(o=(r=v(c,"Exception")).data).baseType="ExceptionData",o.baseData.exceptions=[{typeName:"SDKLoadFailed",message:n.replace(/\\./g,"-"),hasFullStack:!1,stack:n+"\\nSnippet failed to load ["+a+"] -- Telemetry is disabled\\nHelp Link: https://go.microsoft.com/fwlink/?linkid=2128109\\nHost: "+(S&&S.pathname||"_unknown_")+"\\nEndpoint: "+i,parsedStack:[]}],r)),l.push(function(e,t,n,a){var i=v(c,"Message"),r=i.data;r.baseType="MessageData";var o=r.baseData;return o.message='AI (Internal): 99 message:"'+("SDK LOAD Failure: Failed to load Application Insights SDK script (See stack for details) ("+n+")").replace(/\\"/g,"")+'"',o.properties={endpoint:a},i}(0,0,t,p)),function(e,t){if(JSON){var n=T.fetch;if(n&&!y.useXhr)n(t,{method:N,body:JSON.stringify(e),mode:"cors"});else if(XMLHttpRequest){var a=new XMLHttpRequest;a.open(N,t),a.setRequestHeader("Content-type","application/json"),a.send(JSON.stringify(e))}}}(l,p))}function i(e,t){f||setTimeout(function(){!t&&m.core||a()},500)}var e=function(){var n=l.createElement(k);n.src=h;var e=y[w];return!e&&""!==e||"undefined"==n[w]||(n[w]=e),n.onload=i,n.onerror=a,n.onreadystatechange=function(e,t){"loaded"!==n.readyState&&"complete"!==n.readyState||i(0,t)},n}();y.ld<0?l.getElementsByTagName("head")[0].appendChild(e):setTimeout(function(){l.getElementsByTagName(k)[0].parentNode.appendChild(e)},y.ld||0)}try{m.cookie=l.cookie}catch(p){}function t(e){for(;e.length;)!function(t){m[t]=function(){var e=arguments;g||m.queue.push(function(){m[t].apply(m,e)})}}(e.pop())}var n="track",r="TrackPage",o="TrackEvent";t([n+"Event",n+"PageView",n+"Exception",n+"Trace",n+"DependencyData",n+"Metric",n+"PageViewPerformance","start"+r,"stop"+r,"start"+o,"stop"+o,"addTelemetryInitializer","setAuthenticatedUserContext","clearAuthenticatedUserContext","flush"]),m.SeverityLevel={Verbose:0,Information:1,Warning:2,Error:3,Critical:4};var s=(d.extensionConfig||{}).ApplicationInsightsAnalytics||{};if(!0!==d[I]&&!0!==s[I]){var c="onerror";t(["_"+c]);var u=T[c];T[c]=function(e,t,n,a,i){var r=u&&u(e,t,n,a,i);return!0!==r&&m["_"+c]({message:e,url:t,lineNumber:n,columnNumber:a,error:i}),r},d.autoExceptionInstrumented=!0}return m}(y.cfg);function a(){y.onInit&&y.onInit(n)}(T[t]=n).queue&&0===n.queue.length?(n.queue.push(a),n.trackPageView({})):a()}(window,document,{\r
src: "https://js.monitor.azure.com/scripts/b/ai.2.min.js", // The SDK URL Source\r
// name: "appInsights", // Global SDK Instance name defaults to "appInsights" when not supplied\r
// ld: 0, // Defines the load delay (in ms) before attempting to load the sdk. -1 = block page load and add to head. (default) = 0ms load after timeout,\r
// useXhr: 1, // Use XHR instead of fetch to report failures (if available),\r
// crossOrigin: "anonymous", // When supplied this will add the provided value as the cross origin attribute on the script tag\r
// onInit: null, // Once the application insights instance has loaded and initialized this callback function will be called with 1 argument -- the sdk instance (DO NOT ADD anything to the sdk.queue -- As they won't get called)\r
cfg: { // Application Insights Configuration\r
    instrumentationKey: "INSTRUMENTATION_KEY"\r
}});`;
      exports3.webSnippet = webSnippet;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/applicationinsights/out/AutoCollection/WebSnippet.js
var require_WebSnippet = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/WebSnippet.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var zlib = require("zlib");
    var Logging = require_Logging();
    var snippetInjectionHelper = require_SnippetInjectionHelper();
    var prefixHelper = require_PrefixHelper();
    var Constants = require_Constants2();
    var ConnectionStringParser = require_ConnectionStringParser();
    var applicationinsights_web_snippet_1 = require_applicationinsights_web_snippet();
    var WebSnippet = (
      /** @class */
      function() {
        function WebSnippet2(client) {
          var _a;
          this._isIkeyValid = true;
          if (!!WebSnippet2.INSTANCE) {
            throw new Error("Web snippet injection should be configured from the applicationInsights object");
          }
          WebSnippet2.INSTANCE = this;
          WebSnippet2._aiUrl = Constants.WEB_INSTRUMENTATION_DEFAULT_SOURCE;
          WebSnippet2._aiDeprecatedUrl = Constants.WEB_INSTRUMENTATION_DEPRECATED_SOURCE;
          var clientWebIkey = this._getWebSnippetIkey((_a = client.config) === null || _a === void 0 ? void 0 : _a.webInstrumentationConnectionString);
          this._webInstrumentationIkey = clientWebIkey || client.config.instrumentationKey;
          this._clientWebInstrumentationConfig = client.config.webInstrumentationConfig;
          this._clientWebInstrumentationSrc = client.config.webInstrumentationSrc;
          this._statsbeat = client.getStatsbeat();
        }
        WebSnippet2.prototype.enable = function(isEnabled, webInstrumentationConnectionString) {
          this._isEnabled = isEnabled;
          this._webInstrumentationIkey = this._getWebSnippetIkey(webInstrumentationConnectionString) || this._webInstrumentationIkey;
          WebSnippet2._snippet = this._getWebInstrumentationReplacedStr();
          if (this._isEnabled && !this._isInitialized && this._isIkeyValid) {
            if (this._statsbeat) {
              this._statsbeat.addFeature(Constants.StatsbeatFeature.WEB_SNIPPET);
            }
            this._initialize();
          } else if (!this._isEnabled) {
            if (this._statsbeat) {
              this._statsbeat.removeFeature(Constants.StatsbeatFeature.WEB_SNIPPET);
            }
          }
        };
        WebSnippet2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        WebSnippet2.prototype._getWebSnippetIkey = function(connectionString) {
          var iKey = null;
          try {
            var csCode = ConnectionStringParser.parse(connectionString);
            var iKeyCode = csCode.instrumentationkey || "";
            if (!ConnectionStringParser.isIkeyValid(iKeyCode)) {
              this._isIkeyValid = false;
              Logging.info("Invalid web Instrumentation connection string, web Instrumentation is not enabled.");
            } else {
              this._isIkeyValid = true;
              iKey = iKeyCode;
            }
          } catch (err) {
            Logging.info("get web snippet ikey error: " + err);
          }
          return iKey;
        };
        WebSnippet2.prototype._getWebInstrumentationReplacedStr = function() {
          var configStr = this._getClientWebInstrumentationConfigStr(this._clientWebInstrumentationConfig);
          var osStr = prefixHelper.getOsPrefix();
          var rpStr = prefixHelper.getResourceProvider();
          var snippetReplacedStr = this._webInstrumentationIkey + '",\r\n' + configStr + ' disableIkeyDeprecationMessage: true,\r\n sdkExtension: "' + rpStr + osStr + "d_n_";
          var replacedSnippet = applicationinsights_web_snippet_1.webSnippet.replace("INSTRUMENTATION_KEY", snippetReplacedStr);
          if (this._clientWebInstrumentationSrc) {
            return replacedSnippet.replace(Constants.WEB_INSTRUMENTATION_DEFAULT_SOURCE + ".2.min.js", this._clientWebInstrumentationSrc);
          }
          return replacedSnippet;
        };
        WebSnippet2.prototype._getClientWebInstrumentationConfigStr = function(config) {
          var configStr = "";
          try {
            if (config != void 0 && config.length > 0) {
              config.forEach(function(item) {
                var key = item.name;
                if (key === void 0)
                  return;
                var val = item.value;
                var entry = "";
                switch (typeof val) {
                  case "function":
                    break;
                  case "object":
                    break;
                  case "string":
                    entry = " " + key + ': "' + val + '",\r\n';
                    configStr += entry;
                    break;
                  default:
                    entry = " " + key + ": " + val + ",\r\n";
                    configStr += entry;
                    break;
                }
              });
            }
          } catch (e) {
            this._isEnabled = false;
            Logging.info("Parse client web instrumentation error. Web Instrumentation is disabled");
          }
          return configStr;
        };
        WebSnippet2.prototype._initialize = function() {
          this._isInitialized = true;
          var originalHttpServer = http.createServer;
          var originalHttpsServer = https.createServer;
          var isEnabled = this._isEnabled;
          http.createServer = function(requestListener) {
            var originalRequestListener = requestListener;
            if (originalRequestListener) {
              requestListener = function(request, response) {
                var originalResponseWrite = response.write;
                var isGetRequest = request.method == "GET";
                response.write = function wrap(a, b, c) {
                  try {
                    if (isEnabled && isGetRequest) {
                      var headers = snippetInjectionHelper.getContentEncodingFromHeaders(response);
                      var writeBufferType = void 0;
                      if (typeof b === "string") {
                        writeBufferType = b;
                      }
                      if (headers === null || headers === void 0) {
                        if (WebSnippet2.INSTANCE.ValidateInjection(response, a)) {
                          arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(response, a, void 0, writeBufferType);
                        }
                      } else if (headers.length) {
                        var encodeType = headers[0];
                        arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(response, a, encodeType);
                      }
                    }
                  } catch (err) {
                    Logging.warn("Inject snippet error: " + err);
                  }
                  return originalResponseWrite.apply(response, arguments);
                };
                var originalResponseEnd = response.end;
                response.end = function wrap(a, b, c) {
                  if (isEnabled && isGetRequest) {
                    try {
                      if (isEnabled && isGetRequest) {
                        var headers = snippetInjectionHelper.getContentEncodingFromHeaders(response);
                        var endBufferType = void 0;
                        if (typeof b === "string") {
                          endBufferType = b;
                        }
                        if (headers === null || headers === void 0) {
                          if (WebSnippet2.INSTANCE.ValidateInjection(response, a)) {
                            arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(response, a, void 0, endBufferType);
                          }
                        } else if (headers.length) {
                          var encodeType = headers[0];
                          arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(response, a, encodeType);
                        }
                      }
                    } catch (err) {
                      Logging.warn("Inject snipet error: " + err);
                    }
                  }
                  return originalResponseEnd.apply(response, arguments);
                };
                return originalRequestListener(request, response);
              };
            }
            return originalHttpServer(requestListener);
          };
          https.createServer = function(options, httpsRequestListener) {
            var originalHttpsRequestListener = httpsRequestListener;
            if (originalHttpsRequestListener) {
              httpsRequestListener = function(req, res) {
                var isGetHttpsRequest = req.method == "GET";
                var originalHttpsResponseWrite = res.write;
                var originalHttpsResponseEnd = res.end;
                res.write = function wrap(a, b, c) {
                  try {
                    if (isEnabled && isGetHttpsRequest) {
                      var headers = snippetInjectionHelper.getContentEncodingFromHeaders(res);
                      var writeBufferType = void 0;
                      if (typeof b === "string") {
                        writeBufferType = b;
                      }
                      if (headers === null || headers === void 0) {
                        if (WebSnippet2.INSTANCE.ValidateInjection(res, a)) {
                          arguments[0] = this.InjectWebSnippet(res, a, void 0, writeBufferType);
                        }
                      } else if (headers.length) {
                        var encodeType = headers[0];
                        arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(res, a, encodeType);
                      }
                    }
                  } catch (err) {
                    Logging.warn("Inject snippet error: " + err);
                  }
                  return originalHttpsResponseWrite.apply(res, arguments);
                };
                res.end = function wrap(a, b, c) {
                  try {
                    if (isEnabled && isGetHttpsRequest) {
                      var headers = snippetInjectionHelper.getContentEncodingFromHeaders(res);
                      var endBufferType = void 0;
                      if (typeof b === "string") {
                        endBufferType = b;
                      }
                      if (headers === null || headers === void 0) {
                        if (WebSnippet2.INSTANCE.ValidateInjection(res, a)) {
                          arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(res, a, void 0, endBufferType);
                        }
                      } else if (headers.length) {
                        var encodeType = headers[0];
                        arguments[0] = WebSnippet2.INSTANCE.InjectWebSnippet(res, a, encodeType);
                      }
                    }
                  } catch (err) {
                    Logging.warn("Inject snippet error: " + err);
                  }
                  return originalHttpsResponseEnd.apply(res, arguments);
                };
                return originalHttpsRequestListener(req, res);
              };
              return originalHttpsServer(options, httpsRequestListener);
            }
          };
        };
        WebSnippet2.prototype.ValidateInjection = function(response, input) {
          try {
            if (!response || !input || response.statusCode != 200)
              return false;
            var isContentHtml = snippetInjectionHelper.isContentTypeHeaderHtml(response);
            if (!isContentHtml)
              return false;
            var inputStr = input.slice().toString();
            if (inputStr.indexOf("<head>") >= 0 && inputStr.indexOf("</head>") >= 0) {
              if (inputStr.indexOf(WebSnippet2._aiUrl) < 0 && inputStr.indexOf(WebSnippet2._aiDeprecatedUrl) < 0) {
                return true;
              }
            }
          } catch (err) {
            Logging.info("validate injections error: " + err);
          }
          return false;
        };
        WebSnippet2.prototype.InjectWebSnippet = function(response, input, encodeType, bufferEncodeType) {
          try {
            var isCompressedBuffer = !!encodeType;
            if (!isCompressedBuffer) {
              var html = input.toString();
              var index = html.indexOf("</head>");
              if (index < 0)
                return input;
              var newHtml = snippetInjectionHelper.insertSnippetByIndex(index, html, WebSnippet2._snippet);
              if (typeof input === "string") {
                response.removeHeader("Content-Length");
                input = newHtml;
                response.setHeader("Content-Length", Buffer.byteLength(input));
              } else if (Buffer.isBuffer(input)) {
                var bufferType = bufferEncodeType ? bufferEncodeType : "utf8";
                var isValidBufferType = snippetInjectionHelper.isBufferType(input, bufferType);
                if (isValidBufferType) {
                  response.removeHeader("Content-Length");
                  var encodedString = Buffer.from(newHtml).toString(bufferType);
                  input = Buffer.from(encodedString, bufferType);
                  response.setHeader("Content-Length", input.length);
                }
              }
            } else {
              response.removeHeader("Content-Length");
              input = this._getInjectedCompressBuffer(response, input, encodeType);
              response.setHeader("Content-Length", input.length);
            }
          } catch (ex) {
            Logging.warn("Failed to inject web snippet and change content-lenght headers. Exception:" + ex);
          }
          return input;
        };
        WebSnippet2.prototype._getInjectedCompressBuffer = function(response, input, encodeType) {
          try {
            switch (encodeType) {
              case snippetInjectionHelper.contentEncodingMethod.GZIP:
                var gunzipBuffer = zlib.gunzipSync(input);
                if (this.ValidateInjection(response, gunzipBuffer)) {
                  var injectedGunzipBuffer = this.InjectWebSnippet(response, gunzipBuffer);
                  input = zlib.gzipSync(injectedGunzipBuffer);
                }
                break;
              case snippetInjectionHelper.contentEncodingMethod.DEFLATE:
                var inflateBuffer = zlib.inflateSync(input);
                if (this.ValidateInjection(response, inflateBuffer)) {
                  var injectedInflateBuffer = this.InjectWebSnippet(response, inflateBuffer);
                  input = zlib.deflateSync(injectedInflateBuffer);
                }
                break;
              case snippetInjectionHelper.contentEncodingMethod.BR:
                var BrotliDecompressSync = snippetInjectionHelper.getBrotliDecompressSync(zlib);
                var BrotliCompressSync = snippetInjectionHelper.getBrotliCompressSync(zlib);
                if (BrotliDecompressSync && BrotliCompressSync) {
                  var decompressBuffer = BrotliDecompressSync(input);
                  if (this.ValidateInjection(response, decompressBuffer)) {
                    var injectedDecompressBuffer = this.InjectWebSnippet(response, decompressBuffer);
                    input = BrotliCompressSync(injectedDecompressBuffer);
                  }
                  break;
                }
            }
          } catch (err) {
            Logging.info("get web injection compress buffer error: " + err);
          }
          return input;
        };
        WebSnippet2.prototype.dispose = function() {
          WebSnippet2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
        };
        return WebSnippet2;
      }()
    );
    module2.exports = WebSnippet;
  }
});

// node_modules/applicationinsights/out/AutoCollection/HttpRequests.js
var require_HttpRequests = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/HttpRequests.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var Logging = require_Logging();
    var Util = require_Util();
    var RequestResponseHeaders = require_RequestResponseHeaders();
    var HttpRequestParser = require_HttpRequestParser();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var AutoCollectPerformance = require_Performance();
    var AutoCollectHttpRequests = (
      /** @class */
      function() {
        function AutoCollectHttpRequests2(client) {
          if (!!AutoCollectHttpRequests2.INSTANCE) {
            throw new Error("Server request tracking should be configured from the applicationInsights object");
          }
          AutoCollectHttpRequests2.INSTANCE = this;
          this._client = client;
        }
        AutoCollectHttpRequests2.prototype.enable = function(isEnabled) {
          this._isEnabled = isEnabled;
          if ((this._isAutoCorrelating || this._isEnabled || AutoCollectPerformance.isEnabled()) && !this._isInitialized) {
            this.useAutoCorrelation(this._isAutoCorrelating);
            this._initialize();
          }
        };
        AutoCollectHttpRequests2.prototype.useAutoCorrelation = function(isEnabled, forceClsHooked) {
          if (isEnabled && !this._isAutoCorrelating) {
            CorrelationContextManager_1.CorrelationContextManager.enable(forceClsHooked);
          } else if (!isEnabled && this._isAutoCorrelating) {
            CorrelationContextManager_1.CorrelationContextManager.disable();
          }
          this._isAutoCorrelating = isEnabled;
        };
        AutoCollectHttpRequests2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        AutoCollectHttpRequests2.prototype.isAutoCorrelating = function() {
          return this._isAutoCorrelating;
        };
        AutoCollectHttpRequests2.prototype._generateCorrelationContext = function(requestParser) {
          if (!this._isAutoCorrelating) {
            return;
          }
          return CorrelationContextManager_1.CorrelationContextManager.generateContextObject(requestParser.getOperationId(this._client.context.tags), requestParser.getRequestId(), requestParser.getOperationName(this._client.context.tags), requestParser.getCorrelationContextHeader(), requestParser.getTraceparent(), requestParser.getTracestate());
        };
        AutoCollectHttpRequests2.prototype._registerRequest = function(request, response, onRequest) {
          var _this = this;
          var requestParser = new HttpRequestParser(request);
          var correlationContext = this._generateCorrelationContext(requestParser);
          CorrelationContextManager_1.CorrelationContextManager.runWithContext(correlationContext, function() {
            if (_this._isEnabled) {
              request[AutoCollectHttpRequests2.alreadyAutoCollectedFlag] = true;
              AutoCollectHttpRequests2.trackRequest(_this._client, { request, response }, requestParser);
            }
            if (typeof onRequest === "function") {
              onRequest(request, response);
            }
          });
        };
        AutoCollectHttpRequests2.prototype._initialize = function() {
          this._isInitialized = true;
          if (AutoCollectHttpRequests2.HANDLER_READY) {
            return;
          }
          AutoCollectHttpRequests2.HANDLER_READY = true;
          var wrapOnRequestHandler = function(onRequest) {
            if (!onRequest) {
              return void 0;
            }
            if (typeof onRequest !== "function") {
              throw new Error("onRequest handler must be a function");
            }
            return function(request, response) {
              var _a;
              CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(request);
              CorrelationContextManager_1.CorrelationContextManager.wrapEmitter(response);
              var shouldCollect = request && !request[AutoCollectHttpRequests2.alreadyAutoCollectedFlag];
              if (request && shouldCollect) {
                (_a = AutoCollectHttpRequests2.INSTANCE) === null || _a === void 0 ? void 0 : _a._registerRequest(request, response, onRequest);
              } else {
                if (typeof onRequest === "function") {
                  onRequest(request, response);
                }
              }
            };
          };
          var wrapServerEventHandler = function(server) {
            var originalAddListener = server.addListener.bind(server);
            server.addListener = function(eventType, eventHandler) {
              switch (eventType) {
                case "request":
                case "checkContinue":
                  return originalAddListener(eventType, wrapOnRequestHandler(eventHandler));
                default:
                  return originalAddListener(eventType, eventHandler);
              }
            };
            server.on = server.addListener;
          };
          var originalHttpServer = http.createServer;
          http.createServer = function(param1, param2) {
            if (param2 && typeof param2 === "function") {
              var server = originalHttpServer(param1, wrapOnRequestHandler(param2));
              wrapServerEventHandler(server);
              return server;
            } else {
              var server = originalHttpServer(wrapOnRequestHandler(param1));
              wrapServerEventHandler(server);
              return server;
            }
          };
          var originalHttpsServer = https.createServer;
          https.createServer = function(options, onRequest) {
            var server = originalHttpsServer(options, wrapOnRequestHandler(onRequest));
            wrapServerEventHandler(server);
            return server;
          };
        };
        AutoCollectHttpRequests2.trackRequestSync = function(client, telemetry) {
          if (!telemetry.request || !telemetry.response || !client) {
            Logging.info("AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
            return;
          }
          telemetry.isProcessed = false;
          AutoCollectHttpRequests2.addResponseCorrelationIdHeader(client, telemetry.response);
          var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          var requestParser = new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
          if (correlationContext) {
            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
            correlationContext.operation.parentId = requestParser.getRequestId() || correlationContext.operation.parentId;
            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
          }
          AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, telemetry.duration, telemetry.error);
        };
        AutoCollectHttpRequests2.trackRequest = function(client, telemetry, _requestParser) {
          if (!telemetry.request || !telemetry.response || !client) {
            Logging.info("AutoCollectHttpRequests.trackRequest was called with invalid parameters: ", !telemetry.request, !telemetry.response, !client);
            return;
          }
          telemetry.isProcessed = false;
          var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          var requestParser = _requestParser || new HttpRequestParser(telemetry.request, correlationContext && correlationContext.operation.parentId);
          if (Util.canIncludeCorrelationHeader(client, requestParser.getUrl())) {
            AutoCollectHttpRequests2.addResponseCorrelationIdHeader(client, telemetry.response);
          }
          if (correlationContext && !_requestParser) {
            correlationContext.operation.id = requestParser.getOperationId(client.context.tags) || correlationContext.operation.id;
            correlationContext.operation.name = requestParser.getOperationName(client.context.tags) || correlationContext.operation.name;
            correlationContext.operation.parentId = requestParser.getOperationParentId(client.context.tags) || correlationContext.operation.parentId;
            correlationContext.customProperties.addHeaderData(requestParser.getCorrelationContextHeader());
          }
          if (telemetry.response.once) {
            telemetry.response.once("finish", function() {
              AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, null, null);
            });
          }
          if (telemetry.request.on) {
            telemetry.request.on("error", function(error) {
              AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, null, error);
            });
          }
          if (telemetry.request.on) {
            telemetry.request.on("aborted", function() {
              var errorMessage = "The request has been aborted and the network socket has closed.";
              AutoCollectHttpRequests2.endRequest(client, requestParser, telemetry, null, errorMessage);
            });
          }
        };
        AutoCollectHttpRequests2.addResponseCorrelationIdHeader = function(client, response) {
          if (client.config && client.config.correlationId && response.getHeader && response.setHeader && !response.headersSent) {
            var correlationHeader = response.getHeader(RequestResponseHeaders.requestContextHeader);
            Util.safeIncludeCorrelationHeader(client, response, correlationHeader);
          }
        };
        AutoCollectHttpRequests2.endRequest = function(client, requestParser, telemetry, ellapsedMilliseconds, error) {
          if (telemetry.isProcessed) {
            return;
          }
          telemetry.isProcessed = true;
          if (error) {
            requestParser.onError(error, ellapsedMilliseconds);
          } else {
            requestParser.onResponse(telemetry.response, ellapsedMilliseconds);
          }
          var requestTelemetry = requestParser.getRequestTelemetry(telemetry);
          requestTelemetry.tagOverrides = requestParser.getRequestTags(client.context.tags);
          if (telemetry.tagOverrides) {
            for (var key in telemetry.tagOverrides) {
              requestTelemetry.tagOverrides[key] = telemetry.tagOverrides[key];
            }
          }
          var legacyRootId = requestParser.getLegacyRootId();
          if (legacyRootId) {
            requestTelemetry.properties["ai_legacyRootId"] = legacyRootId;
          }
          requestTelemetry.contextObjects = requestTelemetry.contextObjects || {};
          requestTelemetry.contextObjects["http.ServerRequest"] = telemetry.request;
          requestTelemetry.contextObjects["http.ServerResponse"] = telemetry.response;
          client.trackRequest(requestTelemetry);
        };
        AutoCollectHttpRequests2.prototype.dispose = function() {
          AutoCollectHttpRequests2.INSTANCE = null;
          this.enable(false);
          this._isInitialized = false;
          CorrelationContextManager_1.CorrelationContextManager.disable();
          this._isAutoCorrelating = false;
        };
        AutoCollectHttpRequests2.HANDLER_READY = false;
        AutoCollectHttpRequests2.alreadyAutoCollectedFlag = "_appInsightsAutoCollected";
        return AutoCollectHttpRequests2;
      }()
    );
    module2.exports = AutoCollectHttpRequests;
  }
});

// node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js
var require_QuickPulseEnvelopeFactory = __commonJS({
  "node_modules/applicationinsights/out/Library/QuickPulseEnvelopeFactory.js"(exports2, module2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var os = require("os");
    var Contracts = require_Contracts();
    var Constants = require_Constants2();
    var Util = require_Util();
    var Logging = require_Logging();
    var StreamId = Util.w3cTraceId();
    var QuickPulseEnvelopeFactory = (
      /** @class */
      function() {
        function QuickPulseEnvelopeFactory2() {
        }
        QuickPulseEnvelopeFactory2.createQuickPulseEnvelope = function(metrics, documents, config, context) {
          var machineName = os && typeof os.hostname === "function" && os.hostname() || "Unknown";
          var instance = context.tags && context.keys && context.keys.cloudRoleInstance && context.tags[context.keys.cloudRoleInstance] || machineName;
          var roleName = context.tags && context.keys && context.keys.cloudRole && context.tags[context.keys.cloudRole] || null;
          var envelope = {
            Documents: documents.length > 0 ? documents : null,
            InstrumentationKey: config.instrumentationKey || "",
            Metrics: metrics.length > 0 ? metrics : null,
            InvariantVersion: 1,
            Timestamp: "/Date(" + Date.now() + ")/",
            Version: context.tags[context.keys.internalSdkVersion],
            StreamId,
            MachineName: machineName,
            Instance: instance,
            RoleName: roleName
          };
          return envelope;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseMetric = function(telemetry) {
          var data;
          data = {
            Name: telemetry.name,
            Value: telemetry.value,
            Weight: telemetry.count || 1
          };
          return data;
        };
        QuickPulseEnvelopeFactory2.telemetryEnvelopeToQuickPulseDocument = function(envelope) {
          switch (envelope.data.baseType) {
            case Contracts.TelemetryTypeString.Event:
              return QuickPulseEnvelopeFactory2.createQuickPulseEventDocument(envelope);
            case Contracts.TelemetryTypeString.Exception:
              return QuickPulseEnvelopeFactory2.createQuickPulseExceptionDocument(envelope);
            case Contracts.TelemetryTypeString.Trace:
              return QuickPulseEnvelopeFactory2.createQuickPulseTraceDocument(envelope);
            case Contracts.TelemetryTypeString.Dependency:
              return QuickPulseEnvelopeFactory2.createQuickPulseDependencyDocument(envelope);
            case Contracts.TelemetryTypeString.Request:
              return QuickPulseEnvelopeFactory2.createQuickPulseRequestDocument(envelope);
          }
          return null;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseEventDocument = function(envelope) {
          var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
          var name2 = envelope.data.baseData.name;
          var eventDocument = __assign2(__assign2({}, document2), { Name: name2 });
          return eventDocument;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseTraceDocument = function(envelope) {
          var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
          var severityLevel = envelope.data.baseData.severityLevel || 0;
          var traceDocument = __assign2(__assign2({}, document2), { Message: envelope.data.baseData.message, SeverityLevel: Contracts.SeverityLevel[severityLevel] });
          return traceDocument;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseExceptionDocument = function(envelope) {
          var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
          var exceptionDetails = envelope.data.baseData.exceptions;
          var exception = "";
          var exceptionMessage = "";
          var exceptionType = "";
          if (exceptionDetails && exceptionDetails.length > 0) {
            if (exceptionDetails[0].parsedStack && exceptionDetails[0].parsedStack.length > 0) {
              exceptionDetails[0].parsedStack.forEach(function(err) {
                exception += err.assembly + "\n";
              });
            } else if (exceptionDetails[0].stack && exceptionDetails[0].stack.length > 0) {
              exception = exceptionDetails[0].stack;
            }
            exceptionMessage = exceptionDetails[0].message;
            exceptionType = exceptionDetails[0].typeName;
          }
          var exceptionDocument = __assign2(__assign2({}, document2), { Exception: exception, ExceptionMessage: exceptionMessage, ExceptionType: exceptionType });
          return exceptionDocument;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseRequestDocument = function(envelope) {
          var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
          var baseData = envelope.data.baseData;
          var requestDocument = __assign2(__assign2({}, document2), {
            Name: baseData.name,
            Success: baseData.success,
            Duration: baseData.duration,
            ResponseCode: baseData.responseCode,
            OperationName: baseData.name
            // TODO: is this correct?
          });
          return requestDocument;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseDependencyDocument = function(envelope) {
          var document2 = QuickPulseEnvelopeFactory2.createQuickPulseDocument(envelope);
          var baseData = envelope.data.baseData;
          var dependencyDocument = __assign2(__assign2({}, document2), { Name: baseData.name, Target: baseData.target, Success: baseData.success, Duration: baseData.duration, ResultCode: baseData.resultCode, CommandName: baseData.data, OperationName: document2.OperationId, DependencyTypeName: baseData.type });
          return dependencyDocument;
        };
        QuickPulseEnvelopeFactory2.createQuickPulseDocument = function(envelope) {
          var documentType;
          var __type;
          var operationId, properties;
          if (envelope.data.baseType) {
            __type = Constants.TelemetryTypeStringToQuickPulseType[envelope.data.baseType];
            documentType = Constants.TelemetryTypeStringToQuickPulseDocumentType[envelope.data.baseType];
          } else {
            Logging.warn("Document type invalid; not sending live metric document", envelope.data.baseType);
          }
          operationId = envelope.tags[QuickPulseEnvelopeFactory2.keys.operationId];
          properties = QuickPulseEnvelopeFactory2.aggregateProperties(envelope);
          var document2 = {
            DocumentType: documentType,
            __type,
            OperationId: operationId,
            Version: "1.0",
            Properties: properties
          };
          return document2;
        };
        QuickPulseEnvelopeFactory2.aggregateProperties = function(envelope) {
          var properties = [];
          var meas = envelope.data.baseData.measurements || {};
          for (var key in meas) {
            if (meas.hasOwnProperty(key)) {
              var value = meas[key];
              var property = { key, value };
              properties.push(property);
            }
          }
          var props = envelope.data.baseData.properties || {};
          for (var key in props) {
            if (props.hasOwnProperty(key)) {
              var value = props[key];
              var property = { key, value };
              properties.push(property);
            }
          }
          return properties;
        };
        QuickPulseEnvelopeFactory2.keys = new Contracts.ContextTagKeys();
        return QuickPulseEnvelopeFactory2;
      }()
    );
    module2.exports = QuickPulseEnvelopeFactory;
  }
});

// node_modules/applicationinsights/out/Library/QuickPulseUtil.js
var require_QuickPulseUtil = __commonJS({
  "node_modules/applicationinsights/out/Library/QuickPulseUtil.js"(exports2, module2) {
    "use strict";
    var getTransmissionTime = function() {
      return (Date.now() + 621355968e5) * 1e4;
    };
    module2.exports = { getTransmissionTime };
  }
});

// node_modules/applicationinsights/out/Library/QuickPulseSender.js
var require_QuickPulseSender = __commonJS({
  "node_modules/applicationinsights/out/Library/QuickPulseSender.js"(exports2, module2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var https = require("https");
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var Logging = require_Logging();
    var QuickPulseUtil = require_QuickPulseUtil();
    var Util = require_Util();
    var url = require("url");
    var QuickPulseConfig = {
      method: "POST",
      time: "x-ms-qps-transmission-time",
      pollingIntervalHint: "x-ms-qps-service-polling-interval-hint",
      endpointRedirect: "x-ms-qps-service-endpoint-redirect-v2",
      instanceName: "x-ms-qps-instance-name",
      streamId: "x-ms-qps-stream-id",
      machineName: "x-ms-qps-machine-name",
      roleName: "x-ms-qps-role-name",
      streamid: "x-ms-qps-stream-id",
      invariantVersion: "x-ms-qps-invariant-version",
      subscribed: "x-ms-qps-subscribed"
    };
    var QuickPulseSender = (
      /** @class */
      function() {
        function QuickPulseSender2(config, getAuthorizationHandler) {
          this._config = config;
          this._consecutiveErrors = 0;
          this._getAuthorizationHandler = getAuthorizationHandler;
        }
        QuickPulseSender2.prototype.ping = function(envelope, redirectedHostEndpoint, done) {
          var pingHeaders = [
            { name: QuickPulseConfig.streamId, value: envelope.StreamId },
            { name: QuickPulseConfig.machineName, value: envelope.MachineName },
            { name: QuickPulseConfig.roleName, value: envelope.RoleName },
            { name: QuickPulseConfig.instanceName, value: envelope.Instance },
            { name: QuickPulseConfig.invariantVersion, value: envelope.InvariantVersion.toString() }
          ];
          this._submitData(envelope, redirectedHostEndpoint, done, "ping", pingHeaders);
        };
        QuickPulseSender2.prototype.post = function(envelope, redirectedHostEndpoint, done) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._submitData([envelope], redirectedHostEndpoint, done, "post")];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        QuickPulseSender2.prototype._submitData = function(envelope, redirectedHostEndpoint, done, postOrPing, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function() {
            var payload, options, authHandler, authError_1, notice, req;
            var _a, _b;
            var _this = this;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  payload = Util.stringify(envelope);
                  options = (_a = {}, _a[AutoCollectHttpDependencies.disableCollectionRequestOption] = true, _a.host = redirectedHostEndpoint && redirectedHostEndpoint.length > 0 ? redirectedHostEndpoint : this._config.quickPulseHost, _a.method = QuickPulseConfig.method, _a.path = "/QuickPulseService.svc/" + postOrPing + "?ikey=" + this._config.instrumentationKey, _a.headers = (_b = {
                    "Expect": "100-continue"
                  }, _b[QuickPulseConfig.time] = QuickPulseUtil.getTransmissionTime(), _b["Content-Type"] = "application/json", _b["Content-Length"] = Buffer.byteLength(payload), _b), _a);
                  if (additionalHeaders && additionalHeaders.length > 0) {
                    additionalHeaders.forEach(function(header) {
                      return options.headers[header.name] = header.value;
                    });
                  }
                  if (!(postOrPing === "post"))
                    return [3, 4];
                  authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null;
                  if (!authHandler)
                    return [3, 4];
                  _c.label = 1;
                case 1:
                  _c.trys.push([1, 3, , 4]);
                  return [4, authHandler.addAuthorizationHeader(options)];
                case 2:
                  _c.sent();
                  return [3, 4];
                case 3:
                  authError_1 = _c.sent();
                  notice = "Failed to get AAD bearer token for the Application. Error:";
                  Logging.info(QuickPulseSender2.TAG, notice, authError_1);
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  if (this._config.httpsAgent) {
                    options.agent = this._config.httpsAgent;
                  } else {
                    options.agent = Util.tlsRestrictedAgent;
                  }
                  req = https.request(options, function(res) {
                    if (res.statusCode == 200) {
                      var shouldPOSTData = res.headers[QuickPulseConfig.subscribed] === "true";
                      var redirectHeader = null;
                      try {
                        redirectHeader = res.headers[QuickPulseConfig.endpointRedirect] ? new url.URL(res.headers[QuickPulseConfig.endpointRedirect].toString()).host : null;
                      } catch (error) {
                        _this._onError("Failed to parse redirect header from QuickPulse: " + Util.dumpObj(error));
                      }
                      var pollingIntervalHint = res.headers[QuickPulseConfig.pollingIntervalHint] ? parseInt(res.headers[QuickPulseConfig.pollingIntervalHint].toString()) : null;
                      _this._consecutiveErrors = 0;
                      done(shouldPOSTData, res, redirectHeader, pollingIntervalHint);
                    } else {
                      _this._onError("StatusCode:" + res.statusCode + " StatusMessage:" + res.statusMessage);
                      done();
                    }
                  });
                  req.on("error", function(error) {
                    _this._onError(error);
                    done();
                  });
                  req.write(payload);
                  req.end();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        QuickPulseSender2.prototype._onError = function(error) {
          this._consecutiveErrors++;
          var notice = "Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:";
          if (this._consecutiveErrors % QuickPulseSender2.MAX_QPS_FAILURES_BEFORE_WARN === 0) {
            notice = "Live Metrics endpoint could not be reached " + this._consecutiveErrors + " consecutive times. Most recent error:";
            Logging.warn(QuickPulseSender2.TAG, notice, error);
          } else {
            Logging.info(QuickPulseSender2.TAG, notice, error);
          }
        };
        QuickPulseSender2.TAG = "QuickPulseSender";
        QuickPulseSender2.MAX_QPS_FAILURES_BEFORE_WARN = 25;
        return QuickPulseSender2;
      }()
    );
    module2.exports = QuickPulseSender;
  }
});

// node_modules/applicationinsights/out/Library/QuickPulseStateManager.js
var require_QuickPulseStateManager = __commonJS({
  "node_modules/applicationinsights/out/Library/QuickPulseStateManager.js"(exports2, module2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var Logging = require_Logging();
    var QuickPulseEnvelopeFactory = require_QuickPulseEnvelopeFactory();
    var QuickPulseSender = require_QuickPulseSender();
    var Constants = require_Constants2();
    var Context = require_Context();
    var QuickPulseStateManager = (
      /** @class */
      function() {
        function QuickPulseStateManager2(config, context, getAuthorizationHandler) {
          this._isCollectingData = false;
          this._lastSuccessTime = Date.now();
          this._lastSendSucceeded = true;
          this._metrics = {};
          this._documents = [];
          this._collectors = [];
          this._redirectedHost = null;
          this._pollingIntervalHint = -1;
          this.config = config;
          this.context = context || new Context();
          this._sender = new QuickPulseSender(this.config, getAuthorizationHandler);
          this._isEnabled = false;
        }
        QuickPulseStateManager2.prototype.addCollector = function(collector) {
          this._collectors.push(collector);
        };
        QuickPulseStateManager2.prototype.trackMetric = function(telemetry) {
          this._addMetric(telemetry);
        };
        QuickPulseStateManager2.prototype.addDocument = function(envelope) {
          if (this._isCollectingData) {
            var document_1 = QuickPulseEnvelopeFactory.telemetryEnvelopeToQuickPulseDocument(envelope);
            if (document_1) {
              this._documents.push(document_1);
            }
          }
        };
        QuickPulseStateManager2.prototype.enable = function(isEnabled) {
          if (isEnabled && !this._isEnabled) {
            this._isEnabled = true;
            this._goQuickPulse();
          } else if (!isEnabled && this._isEnabled) {
            this._isEnabled = false;
            clearTimeout(this._handle);
            this._handle = void 0;
          }
        };
        QuickPulseStateManager2.prototype.enableCollectors = function(enable) {
          this._collectors.forEach(function(collector) {
            collector.enable(enable);
          });
        };
        QuickPulseStateManager2.prototype._addMetric = function(telemetry) {
          var value = telemetry.value;
          var count = telemetry.count || 1;
          var name2 = Constants.PerformanceToQuickPulseCounter[telemetry.name];
          if (name2) {
            if (this._metrics[name2]) {
              this._metrics[name2].Value = (this._metrics[name2].Value * this._metrics[name2].Weight + value * count) / (this._metrics[name2].Weight + count);
              this._metrics[name2].Weight += count;
            } else {
              this._metrics[name2] = QuickPulseEnvelopeFactory.createQuickPulseMetric(telemetry);
              this._metrics[name2].Name = name2;
              this._metrics[name2].Weight = 1;
            }
          }
        };
        QuickPulseStateManager2.prototype._resetQuickPulseBuffer = function() {
          delete this._metrics;
          this._metrics = {};
          this._documents.length = 0;
        };
        QuickPulseStateManager2.prototype._goQuickPulse = function() {
          return __awaiter(this, void 0, void 0, function() {
            var metrics, envelope, pingInterval, currentTimeout;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  metrics = Object.keys(this._metrics).map(function(k) {
                    return _this._metrics[k];
                  });
                  envelope = QuickPulseEnvelopeFactory.createQuickPulseEnvelope(metrics, this._documents.slice(), this.config, this.context);
                  this._resetQuickPulseBuffer();
                  if (!this._isCollectingData)
                    return [3, 2];
                  return [4, this._post(envelope)];
                case 1:
                  _a.sent();
                  return [3, 3];
                case 2:
                  this._ping(envelope);
                  _a.label = 3;
                case 3:
                  pingInterval = this._pollingIntervalHint > 0 ? this._pollingIntervalHint : QuickPulseStateManager2.PING_INTERVAL;
                  currentTimeout = this._isCollectingData ? QuickPulseStateManager2.POST_INTERVAL : pingInterval;
                  if (this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager2.MAX_POST_WAIT_TIME && !this._lastSendSucceeded) {
                    this._isCollectingData = false;
                    currentTimeout = QuickPulseStateManager2.FALLBACK_INTERVAL;
                  } else if (!this._isCollectingData && Date.now() - this._lastSuccessTime >= QuickPulseStateManager2.MAX_PING_WAIT_TIME && !this._lastSendSucceeded) {
                    currentTimeout = QuickPulseStateManager2.FALLBACK_INTERVAL;
                  }
                  this._lastSendSucceeded = null;
                  this._handle = setTimeout(this._goQuickPulse.bind(this), currentTimeout);
                  this._handle.unref();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        QuickPulseStateManager2.prototype._ping = function(envelope) {
          this._sender.ping(envelope, this._redirectedHost, this._quickPulseDone.bind(this));
        };
        QuickPulseStateManager2.prototype._post = function(envelope) {
          return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, this._sender.post(envelope, this._redirectedHost, this._quickPulseDone.bind(this))];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        QuickPulseStateManager2.prototype._quickPulseDone = function(shouldPOST, res, redirectedHost, pollingIntervalHint) {
          if (shouldPOST != void 0) {
            if (this._isCollectingData !== shouldPOST) {
              Logging.info("Live Metrics sending data", shouldPOST);
              this.enableCollectors(shouldPOST);
            }
            this._isCollectingData = shouldPOST;
            if (redirectedHost && redirectedHost.length > 0) {
              this._redirectedHost = redirectedHost;
              Logging.info("Redirecting endpoint to: ", redirectedHost);
            }
            if (pollingIntervalHint && pollingIntervalHint > 0) {
              this._pollingIntervalHint = pollingIntervalHint;
            }
            if (res && res.statusCode < 300 && res.statusCode >= 200) {
              this._lastSuccessTime = Date.now();
              this._lastSendSucceeded = true;
            } else {
              this._lastSendSucceeded = false;
            }
          } else {
            this._lastSendSucceeded = false;
          }
        };
        QuickPulseStateManager2.MAX_POST_WAIT_TIME = 2e4;
        QuickPulseStateManager2.MAX_PING_WAIT_TIME = 6e4;
        QuickPulseStateManager2.FALLBACK_INTERVAL = 6e4;
        QuickPulseStateManager2.PING_INTERVAL = 5e3;
        QuickPulseStateManager2.POST_INTERVAL = 1e3;
        return QuickPulseStateManager2;
      }()
    );
    module2.exports = QuickPulseStateManager;
  }
});

// node_modules/applicationinsights/out/AutoCollection/NativePerformance.js
var require_NativePerformance = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/NativePerformance.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoCollectNativePerformance = void 0;
    var Context = require_Context();
    var Logging = require_Logging();
    var AutoCollectNativePerformance = (
      /** @class */
      function() {
        function AutoCollectNativePerformance2(client) {
          this._disabledMetrics = {};
          if (AutoCollectNativePerformance2.INSTANCE) {
            AutoCollectNativePerformance2.INSTANCE.dispose();
          }
          AutoCollectNativePerformance2.INSTANCE = this;
          this._client = client;
        }
        AutoCollectNativePerformance2.prototype.enable = function(isEnabled, disabledMetrics, collectionInterval) {
          var _this = this;
          if (disabledMetrics === void 0) {
            disabledMetrics = {};
          }
          if (collectionInterval === void 0) {
            collectionInterval = 6e4;
          }
          if (AutoCollectNativePerformance2._metricsAvailable == void 0 && isEnabled && !this._isInitialized) {
            try {
              var NativeMetricsEmitters = require("applicationinsights-native-metrics");
              AutoCollectNativePerformance2._emitter = new NativeMetricsEmitters();
              AutoCollectNativePerformance2._metricsAvailable = true;
              Logging.info("Native metrics module successfully loaded!");
            } catch (err) {
              AutoCollectNativePerformance2._metricsAvailable = false;
              return;
            }
          }
          this._isEnabled = isEnabled;
          this._disabledMetrics = disabledMetrics;
          if (this._isEnabled && !this._isInitialized) {
            this._isInitialized = true;
          }
          if (this._isEnabled && AutoCollectNativePerformance2._emitter) {
            AutoCollectNativePerformance2._emitter.enable(true, collectionInterval);
            if (!this._handle) {
              this._handle = setInterval(function() {
                return _this._trackNativeMetrics();
              }, collectionInterval);
              this._handle.unref();
            }
          } else if (AutoCollectNativePerformance2._emitter) {
            AutoCollectNativePerformance2._emitter.enable(false);
            if (this._handle) {
              clearInterval(this._handle);
              this._handle = void 0;
            }
          }
        };
        AutoCollectNativePerformance2.prototype.dispose = function() {
          this.enable(false);
        };
        AutoCollectNativePerformance2.parseEnabled = function(collectExtendedMetrics, customConfig) {
          var disableAll = customConfig.disableAllExtendedMetrics;
          var individualOptOuts = customConfig.extendedMetricDisablers;
          if (disableAll) {
            return { isEnabled: false, disabledMetrics: {} };
          }
          if (individualOptOuts) {
            var optOutsArr = individualOptOuts.split(",");
            var disabledMetrics = {};
            if (optOutsArr.length > 0) {
              for (var _i = 0, optOutsArr_1 = optOutsArr; _i < optOutsArr_1.length; _i++) {
                var opt = optOutsArr_1[_i];
                disabledMetrics[opt] = true;
              }
            }
            if (typeof collectExtendedMetrics === "object") {
              return { isEnabled: true, disabledMetrics: __assign2(__assign2({}, collectExtendedMetrics), disabledMetrics) };
            }
            return { isEnabled: collectExtendedMetrics, disabledMetrics };
          }
          if (typeof collectExtendedMetrics === "boolean") {
            return { isEnabled: collectExtendedMetrics, disabledMetrics: {} };
          } else {
            return { isEnabled: true, disabledMetrics: collectExtendedMetrics };
          }
        };
        AutoCollectNativePerformance2.prototype._trackNativeMetrics = function() {
          var shouldSendAll = true;
          if (typeof this._isEnabled !== "object") {
            shouldSendAll = this._isEnabled;
          }
          if (shouldSendAll) {
            this._trackGarbageCollection();
            this._trackEventLoop();
            this._trackHeapUsage();
          }
        };
        AutoCollectNativePerformance2.prototype._trackGarbageCollection = function() {
          var _a;
          if (this._disabledMetrics.gc) {
            return;
          }
          var gcData = AutoCollectNativePerformance2._emitter.getGCData();
          for (var gc in gcData) {
            var metrics = gcData[gc].metrics;
            var name_1 = gc + " Garbage Collection Duration";
            var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
            this._client.trackMetric({
              name: name_1,
              value: metrics.total,
              count: metrics.count,
              max: metrics.max,
              min: metrics.min,
              stdDev,
              tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _a)
            });
          }
        };
        AutoCollectNativePerformance2.prototype._trackEventLoop = function() {
          var _a;
          if (this._disabledMetrics.loop) {
            return;
          }
          var loopData = AutoCollectNativePerformance2._emitter.getLoopData();
          var metrics = loopData.loopUsage;
          if (metrics.count == 0) {
            return;
          }
          var name2 = "Event Loop CPU Time";
          var stdDev = Math.sqrt(metrics.sumSquares / metrics.count - Math.pow(metrics.total / metrics.count, 2)) || 0;
          this._client.trackMetric({
            name: name2,
            value: metrics.total,
            count: metrics.count,
            min: metrics.min,
            max: metrics.max,
            stdDev,
            tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _a)
          });
        };
        AutoCollectNativePerformance2.prototype._trackHeapUsage = function() {
          var _a, _b, _c;
          if (this._disabledMetrics.heap) {
            return;
          }
          var memoryUsage = process.memoryUsage();
          var heapUsed = memoryUsage.heapUsed, heapTotal = memoryUsage.heapTotal, rss = memoryUsage.rss;
          this._client.trackMetric({
            name: "Memory Usage (Heap)",
            value: heapUsed,
            count: 1,
            tagOverrides: (_a = {}, _a[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _a)
          });
          this._client.trackMetric({
            name: "Memory Total (Heap)",
            value: heapTotal,
            count: 1,
            tagOverrides: (_b = {}, _b[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _b)
          });
          this._client.trackMetric({
            name: "Memory Usage (Non-Heap)",
            value: rss - heapTotal,
            count: 1,
            tagOverrides: (_c = {}, _c[this._client.context.keys.internalSdkVersion] = "node-nativeperf:" + Context.sdkVersion, _c)
          });
        };
        return AutoCollectNativePerformance2;
      }()
    );
    exports2.AutoCollectNativePerformance = AutoCollectNativePerformance;
  }
});

// node_modules/applicationinsights/out/AutoCollection/AzureFunctionsHook.js
var require_AzureFunctionsHook = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/AzureFunctionsHook.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AzureFunctionsHook = void 0;
    var Logging = require_Logging();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var AzureFunctionsHook = (
      /** @class */
      function() {
        function AzureFunctionsHook2(client) {
          this._client = client;
          this._autoGenerateIncomingRequests = false;
          try {
            this._functionsCoreModule = require("@azure/functions-core");
            var funcProgModel = this._functionsCoreModule.getProgrammingModel();
            if (funcProgModel.name === "@azure/functions" && funcProgModel.version.startsWith("3.")) {
              this._addPreInvocationHook();
              this._addPostInvocationHook();
            } else {
              Logging.warn('AzureFunctionsHook does not support model "' + funcProgModel.name + '" version "' + funcProgModel.version + '"');
            }
          } catch (error) {
            Logging.info("AzureFunctionsHook failed to load, not running in Azure Functions");
          }
        }
        AzureFunctionsHook2.prototype.enable = function(isEnabled) {
          this._autoGenerateIncomingRequests = isEnabled;
        };
        AzureFunctionsHook2.prototype.dispose = function() {
          this.enable(false);
          this._removeInvocationHooks();
          this._functionsCoreModule = void 0;
        };
        AzureFunctionsHook2.prototype._addPreInvocationHook = function() {
          var _this = this;
          if (!this._preInvocationHook) {
            this._preInvocationHook = this._functionsCoreModule.registerHook("preInvocation", function(preInvocationContext) {
              return __awaiter(_this, void 0, void 0, function() {
                var ctx, extractedContext;
                return __generator(this, function(_a) {
                  ctx = preInvocationContext.invocationContext;
                  try {
                    extractedContext = CorrelationContextManager_1.CorrelationContextManager.startOperation(ctx);
                    extractedContext.customProperties.setProperty("InvocationId", ctx.invocationId);
                    if (ctx.traceContext.attributes) {
                      extractedContext.customProperties.setProperty("ProcessId", ctx.traceContext.attributes["ProcessId"]);
                      extractedContext.customProperties.setProperty("LogLevel", ctx.traceContext.attributes["LogLevel"]);
                      extractedContext.customProperties.setProperty("Category", ctx.traceContext.attributes["Category"]);
                      extractedContext.customProperties.setProperty("HostInstanceId", ctx.traceContext.attributes["HostInstanceId"]);
                      extractedContext.customProperties.setProperty("AzFuncLiveLogsSessionId", ctx.traceContext.attributes["#AzFuncLiveLogsSessionId"]);
                    }
                    preInvocationContext.functionCallback = CorrelationContextManager_1.CorrelationContextManager.wrapCallback(preInvocationContext.functionCallback, extractedContext);
                    if (this._isHttpTrigger(ctx) && this._autoGenerateIncomingRequests) {
                      preInvocationContext.hookData.appInsightsExtractedContext = extractedContext;
                      preInvocationContext.hookData.appInsightsStartTime = Date.now();
                    }
                  } catch (err) {
                    Logging.warn("Failed to propagate context in Azure Functions", err);
                    return [
                      2
                      /*return*/
                    ];
                  }
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            });
          }
        };
        AzureFunctionsHook2.prototype._addPostInvocationHook = function() {
          var _this = this;
          if (!this._postInvocationHook) {
            this._postInvocationHook = this._functionsCoreModule.registerHook("postInvocation", function(postInvocationContext) {
              return __awaiter(_this, void 0, void 0, function() {
                var ctx, request_1, startTime_1, response_1, extractedContext_1;
                var _this2 = this;
                return __generator(this, function(_a) {
                  try {
                    if (this._autoGenerateIncomingRequests) {
                      ctx = postInvocationContext.invocationContext;
                      if (this._isHttpTrigger(ctx)) {
                        request_1 = postInvocationContext.inputs[0];
                        if (request_1) {
                          startTime_1 = postInvocationContext.hookData.appInsightsStartTime || Date.now();
                          response_1 = this._getAzureFunctionResponse(postInvocationContext, ctx);
                          extractedContext_1 = postInvocationContext.hookData.appInsightsExtractedContext;
                          if (!extractedContext_1) {
                            this._createIncomingRequestTelemetry(request_1, response_1, startTime_1, null);
                          } else {
                            CorrelationContextManager_1.CorrelationContextManager.runWithContext(extractedContext_1, function() {
                              _this2._createIncomingRequestTelemetry(request_1, response_1, startTime_1, extractedContext_1.operation.parentId);
                            });
                          }
                        }
                      }
                    }
                  } catch (err) {
                    Logging.warn("Error creating automatic incoming request in Azure Functions", err);
                  }
                  return [
                    2
                    /*return*/
                  ];
                });
              });
            });
          }
        };
        AzureFunctionsHook2.prototype._createIncomingRequestTelemetry = function(request, response, startTime, parentId) {
          var statusCode = 200;
          for (var _i = 0, _a = [response.statusCode, response.status]; _i < _a.length; _i++) {
            var value = _a[_i];
            if (typeof value === "number" && Number.isInteger(value)) {
              statusCode = value;
              break;
            } else if (typeof value === "string") {
              var parsedVal = parseInt(value);
              if (!isNaN(parsedVal)) {
                statusCode = parsedVal;
                break;
              }
            }
          }
          this._client.trackRequest({
            name: request.method + " " + request.url,
            resultCode: statusCode,
            success: 0 < statusCode && statusCode < 400,
            url: request.url,
            time: new Date(startTime),
            duration: Date.now() - startTime,
            id: parentId
          });
          this._client.flush();
        };
        AzureFunctionsHook2.prototype._getAzureFunctionResponse = function(postInvocationContext, ctx) {
          var httpOutputBinding = ctx.bindingDefinitions.find(function(b) {
            return b.direction === "out" && b.type.toLowerCase() === "http";
          });
          if ((httpOutputBinding === null || httpOutputBinding === void 0 ? void 0 : httpOutputBinding.name) === "$return") {
            return postInvocationContext.result;
          } else if (httpOutputBinding && ctx.bindings && ctx.bindings[httpOutputBinding.name] !== void 0) {
            return ctx.bindings[httpOutputBinding.name];
          } else {
            return ctx.res;
          }
        };
        AzureFunctionsHook2.prototype._isHttpTrigger = function(ctx) {
          return ctx.bindingDefinitions.find(function(b) {
            var _a;
            return ((_a = b.type) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === "httptrigger";
          });
        };
        AzureFunctionsHook2.prototype._removeInvocationHooks = function() {
          if (this._preInvocationHook) {
            this._preInvocationHook.dispose();
            this._preInvocationHook = void 0;
          }
          if (this._postInvocationHook) {
            this._postInvocationHook.dispose();
            this._postInvocationHook = void 0;
          }
        };
        return AzureFunctionsHook2;
      }()
    );
    exports2.AzureFunctionsHook = AzureFunctionsHook;
  }
});

// node_modules/applicationinsights/out/Library/Config.js
var require_Config = __commonJS({
  "node_modules/applicationinsights/out/Library/Config.js"(exports2, module2) {
    "use strict";
    var CorrelationIdManager = require_CorrelationIdManager();
    var ConnectionStringParser = require_ConnectionStringParser();
    var Logging = require_Logging();
    var Constants = require_Constants2();
    var url = require("url");
    var JsonConfig_1 = require_JsonConfig();
    var Config = (
      /** @class */
      function() {
        function Config2(setupString) {
          this._endpointBase = Constants.DEFAULT_BREEZE_ENDPOINT;
          this._mergeConfig();
          var connectionStringEnv = this._connectionString;
          var csCode = ConnectionStringParser.parse(setupString);
          var csEnv = ConnectionStringParser.parse(connectionStringEnv);
          var iKeyCode = !csCode.instrumentationkey && Object.keys(csCode).length > 0 ? null : setupString;
          var instrumentationKeyEnv = this._instrumentationKey;
          this.instrumentationKey = csCode.instrumentationkey || iKeyCode || csEnv.instrumentationkey || instrumentationKeyEnv;
          var endpoint = "" + (this.endpointUrl || csCode.ingestionendpoint || csEnv.ingestionendpoint || this._endpointBase);
          if (endpoint.endsWith("/")) {
            endpoint = endpoint.slice(0, -1);
          }
          this.endpointUrl = endpoint + "/v2.1/track";
          this.maxBatchSize = this.maxBatchSize || 250;
          this.maxBatchIntervalMs = this.maxBatchIntervalMs || 15e3;
          this.disableAppInsights = this.disableAppInsights || false;
          this.samplingPercentage = this.samplingPercentage || 100;
          this.correlationIdRetryIntervalMs = this.correlationIdRetryIntervalMs || 30 * 1e3;
          this.enableWebInstrumentation = this.enableWebInstrumentation || this.enableAutoWebSnippetInjection || false;
          this.webInstrumentationConfig = this.webInstrumentationConfig || null;
          this.enableAutoWebSnippetInjection = this.enableWebInstrumentation;
          this.correlationHeaderExcludedDomains = this.correlationHeaderExcludedDomains || [
            "*.core.windows.net",
            "*.core.chinacloudapi.cn",
            "*.core.cloudapi.de",
            "*.core.usgovcloudapi.net",
            "*.core.microsoft.scloud",
            "*.core.eaglex.ic.gov"
          ];
          this.ignoreLegacyHeaders = this.ignoreLegacyHeaders || false;
          this.profileQueryEndpoint = csCode.ingestionendpoint || csEnv.ingestionendpoint || process.env[Config2.ENV_profileQueryEndpoint] || this._endpointBase;
          this.quickPulseHost = this.quickPulseHost || csCode.liveendpoint || csEnv.liveendpoint || process.env[Config2.ENV_quickPulseHost] || Constants.DEFAULT_LIVEMETRICS_HOST;
          this.webInstrumentationConnectionString = this.webInstrumentationConnectionString || this._webInstrumentationConnectionString || "";
          this.webSnippetConnectionString = this.webInstrumentationConnectionString;
          if (this.quickPulseHost.match(/^https?:\/\//)) {
            this.quickPulseHost = new url.URL(this.quickPulseHost).host;
          }
        }
        Object.defineProperty(Config2.prototype, "profileQueryEndpoint", {
          get: function() {
            return this._profileQueryEndpoint;
          },
          set: function(endpoint) {
            this._profileQueryEndpoint = endpoint;
            this.correlationId = CorrelationIdManager.correlationIdPrefix;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Config2.prototype, "instrumentationKey", {
          get: function() {
            return this._instrumentationKey;
          },
          set: function(iKey) {
            if (!Config2._validateInstrumentationKey(iKey)) {
              Logging.warn("An invalid instrumentation key was provided. There may be resulting telemetry loss", this.instrumentationKey);
            }
            this._instrumentationKey = iKey;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Config2.prototype, "webSnippetConnectionString", {
          get: function() {
            return this._webInstrumentationConnectionString;
          },
          set: function(connectionString) {
            this._webInstrumentationConnectionString = connectionString;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Config2.prototype, "webInstrumentationConnectionString", {
          get: function() {
            return this._webInstrumentationConnectionString;
          },
          set: function(connectionString) {
            this._webInstrumentationConnectionString = connectionString;
          },
          enumerable: false,
          configurable: true
        });
        Config2.prototype._mergeConfig = function() {
          var jsonConfig = JsonConfig_1.JsonConfig.getInstance();
          this._connectionString = jsonConfig.connectionString;
          this._instrumentationKey = jsonConfig.instrumentationKey;
          this.correlationHeaderExcludedDomains = jsonConfig.correlationHeaderExcludedDomains;
          this.correlationIdRetryIntervalMs = jsonConfig.correlationIdRetryIntervalMs;
          this.disableAllExtendedMetrics = jsonConfig.disableAllExtendedMetrics;
          this.disableAppInsights = jsonConfig.disableAppInsights;
          this.disableStatsbeat = jsonConfig.disableStatsbeat;
          this.distributedTracingMode = jsonConfig.distributedTracingMode;
          this.enableAutoCollectConsole = jsonConfig.enableAutoCollectConsole;
          this.enableAutoCollectDependencies = jsonConfig.enableAutoCollectDependencies;
          this.enableAutoCollectIncomingRequestAzureFunctions = jsonConfig.enableAutoCollectIncomingRequestAzureFunctions;
          this.enableAutoCollectExceptions = jsonConfig.enableAutoCollectExceptions;
          this.enableAutoCollectExtendedMetrics = jsonConfig.enableAutoCollectExtendedMetrics;
          this.enableAutoCollectExternalLoggers = jsonConfig.enableAutoCollectExternalLoggers;
          this.enableAutoCollectHeartbeat = jsonConfig.enableAutoCollectHeartbeat;
          this.enableAutoCollectPerformance = jsonConfig.enableAutoCollectPerformance;
          this.enableAutoCollectPreAggregatedMetrics = jsonConfig.enableAutoCollectPreAggregatedMetrics;
          this.enableAutoCollectRequests = jsonConfig.enableAutoCollectRequests;
          this.enableAutoDependencyCorrelation = jsonConfig.enableAutoDependencyCorrelation;
          this.enableInternalDebugLogging = jsonConfig.enableInternalDebugLogging;
          this.enableInternalWarningLogging = jsonConfig.enableInternalWarningLogging;
          this.enableResendInterval = jsonConfig.enableResendInterval;
          this.enableMaxBytesOnDisk = jsonConfig.enableMaxBytesOnDisk;
          this.enableSendLiveMetrics = jsonConfig.enableSendLiveMetrics;
          this.enableUseAsyncHooks = jsonConfig.enableUseAsyncHooks;
          this.enableUseDiskRetryCaching = jsonConfig.enableUseDiskRetryCaching;
          this.endpointUrl = jsonConfig.endpointUrl;
          this.extendedMetricDisablers = jsonConfig.extendedMetricDisablers;
          this.ignoreLegacyHeaders = jsonConfig.ignoreLegacyHeaders;
          this.maxBatchIntervalMs = jsonConfig.maxBatchIntervalMs;
          this.maxBatchSize = jsonConfig.maxBatchSize;
          this.proxyHttpUrl = jsonConfig.proxyHttpUrl;
          this.proxyHttpsUrl = jsonConfig.proxyHttpsUrl;
          this.quickPulseHost = jsonConfig.quickPulseHost;
          this.samplingPercentage = jsonConfig.samplingPercentage;
          this.enableWebInstrumentation = jsonConfig.enableWebInstrumentation;
          this._webInstrumentationConnectionString = jsonConfig.webInstrumentationConnectionString;
          this.webInstrumentationConfig = jsonConfig.webInstrumentationConfig;
          this.webInstrumentationSrc = jsonConfig.webInstrumentationSrc;
        };
        Config2._validateInstrumentationKey = function(iKey) {
          var UUID_Regex = "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$";
          var regexp = new RegExp(UUID_Regex);
          return regexp.test(iKey);
        };
        Config2.ENV_azurePrefix = "APPSETTING_";
        Config2.ENV_iKey = "APPINSIGHTS_INSTRUMENTATIONKEY";
        Config2.legacy_ENV_iKey = "APPINSIGHTS_INSTRUMENTATION_KEY";
        Config2.ENV_profileQueryEndpoint = "APPINSIGHTS_PROFILE_QUERY_ENDPOINT";
        Config2.ENV_quickPulseHost = "APPINSIGHTS_QUICKPULSE_HOST";
        return Config2;
      }()
    );
    module2.exports = Config;
  }
});

// node_modules/@azure/logger/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@azure/logger/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var os = require("os");
    var util = require("util");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    function log(message, ...args) {
      process.stderr.write(`${util__default["default"].format(message, ...args)}${os.EOL}`);
    }
    var debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    var enabledString;
    var enabledNamespaces = [];
    var skippedNamespaces = [];
    var debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    var debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log
    });
    function enable(namespaces) {
      enabledString = namespaces;
      enabledNamespaces = [];
      skippedNamespaces = [];
      const wildcard = /\*/g;
      const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
      for (const ns of namespaceList) {
        if (ns.startsWith("-")) {
          skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
        } else {
          enabledNamespaces.push(new RegExp(`^${ns}$`));
        }
      }
      for (const instance of debuggers) {
        instance.enabled = enabled(instance.namespace);
      }
    }
    function enabled(namespace) {
      if (namespace.endsWith("*")) {
        return true;
      }
      for (const skipped of skippedNamespaces) {
        if (skipped.test(namespace)) {
          return false;
        }
      }
      for (const enabledNamespace of enabledNamespaces) {
        if (enabledNamespace.test(namespace)) {
          return true;
        }
      }
      return false;
    }
    function disable() {
      const result = enabledString || "";
      enable("");
      return result;
    }
    function createDebugger(namespace) {
      const newDebugger = Object.assign(debug2, {
        enabled: enabled(namespace),
        destroy,
        log: debugObj.log,
        namespace,
        extend
      });
      function debug2(...args) {
        if (!newDebugger.enabled) {
          return;
        }
        if (args.length > 0) {
          args[0] = `${namespace} ${args[0]}`;
        }
        newDebugger.log(...args);
      }
      debuggers.push(newDebugger);
      return newDebugger;
    }
    function destroy() {
      const index = debuggers.indexOf(this);
      if (index >= 0) {
        debuggers.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace) {
      const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
      newDebugger.log = this.log;
      return newDebugger;
    }
    var debug = debugObj;
    var registeredLoggers = /* @__PURE__ */ new Set();
    var logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
    var azureLogLevel;
    var AzureLogger = debug("azure");
    AzureLogger.log = (...args) => {
      debug.log(...args);
    };
    var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
      if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
      } else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
      }
    }
    function setLogLevel(level) {
      if (level && !isAzureLogLevel(level)) {
        throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
      }
      azureLogLevel = level;
      const enabledNamespaces2 = [];
      for (const logger of registeredLoggers) {
        if (shouldEnable(logger)) {
          enabledNamespaces2.push(logger.namespace);
        }
      }
      debug.enable(enabledNamespaces2.join(","));
    }
    function getLogLevel() {
      return azureLogLevel;
    }
    var levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
    function createClientLogger(namespace) {
      const clientRootLogger = AzureLogger.extend(namespace);
      patchLogMethod(AzureLogger, clientRootLogger);
      return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
      };
    }
    function patchLogMethod(parent, child) {
      child.log = (...args) => {
        parent.log(...args);
      };
    }
    function createLogger(parent, level) {
      const logger = Object.assign(parent.extend(level), {
        level
      });
      patchLogMethod(parent, logger);
      if (shouldEnable(logger)) {
        const enabledNamespaces2 = debug.disable();
        debug.enable(enabledNamespaces2 + "," + logger.namespace);
      }
      registeredLoggers.add(logger);
      return logger;
    }
    function shouldEnable(logger) {
      return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
    }
    function isAzureLogLevel(logLevel) {
      return AZURE_LOG_LEVELS.includes(logLevel);
    }
    exports2.AzureLogger = AzureLogger;
    exports2.createClientLogger = createClientLogger;
    exports2.getLogLevel = getLogLevel;
    exports2.setLogLevel = setLogLevel;
  }
});

// node_modules/@azure/abort-controller/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/@azure/abort-controller/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var listenersMap = /* @__PURE__ */ new WeakMap();
    var abortedMap = /* @__PURE__ */ new WeakMap();
    var AbortSignal = class _AbortSignal {
      constructor() {
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
      }
      /**
       * Status of whether aborted or not.
       *
       * @readonly
       */
      get aborted() {
        if (!abortedMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
      }
      /**
       * Creates a new AbortSignal instance that will never be aborted.
       *
       * @readonly
       */
      static get none() {
        return new _AbortSignal();
      }
      /**
       * Added new "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be added
       */
      addEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
      }
      /**
       * Remove "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be removed
       */
      removeEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
      /**
       * Dispatches a synthetic event to the AbortSignal.
       */
      dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
      }
    };
    function abortSignal(signal) {
      if (signal.aborted) {
        return;
      }
      if (signal.onabort) {
        signal.onabort.call(signal);
      }
      const listeners = listenersMap.get(signal);
      if (listeners) {
        listeners.slice().forEach((listener) => {
          listener.call(signal, { type: "abort" });
        });
      }
      abortedMap.set(signal, true);
    }
    var AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    var AbortController = class {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(parentSignals) {
        this._signal = new AbortSignal();
        if (!parentSignals) {
          return;
        }
        if (!Array.isArray(parentSignals)) {
          parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
          if (parentSignal.aborted) {
            this.abort();
          } else {
            parentSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
      }
      /**
       * The AbortSignal associated with this controller that will signal aborted
       * when the abort method is called on this controller.
       *
       * @readonly
       */
      get signal() {
        return this._signal;
      }
      /**
       * Signal that any operations passed this controller's associated abort signal
       * to cancel any remaining work and throw an `AbortError`.
       */
      abort() {
        abortSignal(this._signal);
      }
      /**
       * Creates a new AbortSignal instance that will abort after the provided ms.
       * @param ms - Elapsed time in milliseconds to trigger an abort.
       */
      static timeout(ms) {
        const signal = new AbortSignal();
        const timer = setTimeout(abortSignal, ms, signal);
        if (typeof timer.unref === "function") {
          timer.unref();
        }
        return signal;
      }
    };
    exports2.AbortController = AbortController;
    exports2.AbortError = AbortError;
    exports2.AbortSignal = AbortSignal;
  }
});

// node_modules/@azure/core-util/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/@azure/core-util/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var abortController = require_dist7();
    var crypto = require("crypto");
    function createAbortablePromise(buildPromise, options) {
      const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
      return new Promise((resolve, reject) => {
        function rejectOnAbort() {
          reject(new abortController.AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
        }
        function removeListeners() {
          abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener("abort", onAbort);
        }
        function onAbort() {
          cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 ? void 0 : cleanupBeforeAbort();
          removeListeners();
          rejectOnAbort();
        }
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
          return rejectOnAbort();
        }
        try {
          buildPromise((x) => {
            removeListeners();
            resolve(x);
          }, (x) => {
            removeListeners();
            reject(x);
          });
        } catch (err) {
          reject(err);
        }
        abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener("abort", onAbort);
      });
    }
    var StandardAbortMessage = "The delay was aborted.";
    function delay(timeInMs, options) {
      let token;
      const { abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
      return createAbortablePromise((resolve) => {
        token = setTimeout(resolve, timeInMs);
      }, {
        cleanupBeforeAbort: () => clearTimeout(token),
        abortSignal,
        abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
      });
    }
    function getRandomIntegerInclusive(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      const offset = Math.floor(Math.random() * (max - min + 1));
      return offset + min;
    }
    function isObject(input) {
      return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
    }
    function isError(e) {
      if (isObject(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
      }
      return false;
    }
    function getErrorMessage(e) {
      if (isError(e)) {
        return e.message;
      } else {
        let stringified;
        try {
          if (typeof e === "object" && e) {
            stringified = JSON.stringify(e);
          } else {
            stringified = String(e);
          }
        } catch (err) {
          stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
      }
    }
    async function computeSha256Hmac(key, stringToSign, encoding) {
      const decodedKey = Buffer.from(key, "base64");
      return crypto.createHmac("sha256", decodedKey).update(stringToSign).digest(encoding);
    }
    async function computeSha256Hash(content, encoding) {
      return crypto.createHash("sha256").update(content).digest(encoding);
    }
    function isDefined(thing) {
      return typeof thing !== "undefined" && thing !== null;
    }
    function isObjectWithProperties(thing, properties) {
      if (!isDefined(thing) || typeof thing !== "object") {
        return false;
      }
      for (const property of properties) {
        if (!objectHasProperty(thing, property)) {
          return false;
        }
      }
      return true;
    }
    function objectHasProperty(thing, property) {
      return isDefined(thing) && typeof thing === "object" && property in thing;
    }
    function generateUUID() {
      let uuid2 = "";
      for (let i = 0; i < 32; i++) {
        const randomNumber = Math.floor(Math.random() * 16);
        if (i === 12) {
          uuid2 += "4";
        } else if (i === 16) {
          uuid2 += randomNumber & 3 | 8;
        } else {
          uuid2 += randomNumber.toString(16);
        }
        if (i === 7 || i === 11 || i === 15 || i === 19) {
          uuid2 += "-";
        }
      }
      return uuid2;
    }
    var _a$1;
    var uuidFunction = typeof ((_a$1 = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a$1 === void 0 ? void 0 : _a$1.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : crypto.randomUUID;
    if (!uuidFunction) {
      uuidFunction = generateUUID;
    }
    function randomUUID() {
      return uuidFunction();
    }
    var _a;
    var _b;
    var _c;
    var _d;
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    var isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a = self.constructor) === null || _a === void 0 ? void 0 : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
    var isNode = typeof process !== "undefined" && Boolean(process.version) && Boolean((_d = process.versions) === null || _d === void 0 ? void 0 : _d.node);
    var isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    var isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    var isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
    function uint8ArrayToString(bytes, format) {
      switch (format) {
        case "utf-8":
          return uint8ArrayToUtf8String(bytes);
        case "base64":
          return uint8ArrayToBase64(bytes);
        case "base64url":
          return uint8ArrayToBase64Url(bytes);
      }
    }
    function stringToUint8Array(value, format) {
      switch (format) {
        case "utf-8":
          return utf8StringToUint8Array(value);
        case "base64":
          return base64ToUint8Array(value);
        case "base64url":
          return base64UrlToUint8Array(value);
      }
    }
    function uint8ArrayToBase64(bytes) {
      return Buffer.from(bytes).toString("base64");
    }
    function uint8ArrayToBase64Url(bytes) {
      return Buffer.from(bytes).toString("base64url");
    }
    function uint8ArrayToUtf8String(bytes) {
      return Buffer.from(bytes).toString("utf-8");
    }
    function utf8StringToUint8Array(value) {
      return Buffer.from(value);
    }
    function base64ToUint8Array(value) {
      return Buffer.from(value, "base64");
    }
    function base64UrlToUint8Array(value) {
      return Buffer.from(value, "base64url");
    }
    exports2.computeSha256Hash = computeSha256Hash;
    exports2.computeSha256Hmac = computeSha256Hmac;
    exports2.createAbortablePromise = createAbortablePromise;
    exports2.delay = delay;
    exports2.getErrorMessage = getErrorMessage;
    exports2.getRandomIntegerInclusive = getRandomIntegerInclusive;
    exports2.isBrowser = isBrowser;
    exports2.isBun = isBun;
    exports2.isDefined = isDefined;
    exports2.isDeno = isDeno;
    exports2.isError = isError;
    exports2.isNode = isNode;
    exports2.isObject = isObject;
    exports2.isObjectWithProperties = isObjectWithProperties;
    exports2.isReactNative = isReactNative;
    exports2.isWebWorker = isWebWorker;
    exports2.objectHasProperty = objectHasProperty;
    exports2.randomUUID = randomUUID;
    exports2.stringToUint8Array = stringToUint8Array;
    exports2.uint8ArrayToString = uint8ArrayToString;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions2, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions2[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path2 = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData;
    util.inherits(FormData, CombinedStream);
    function FormData(options) {
      if (!(this instanceof FormData)) {
        return new FormData(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData.LINE_BREAK = "\r\n";
    FormData.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
    };
    FormData.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path2.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path2.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path2.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData.LINE_BREAK;
    };
    FormData.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node5 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src7 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node5();
    }
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src8 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault2(require_src7());
    var promisify_1 = __importDefault2(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent2 extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent2;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault2(require_src7());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault2(require("net"));
    var tls_1 = __importDefault2(require("tls"));
    var url_12 = __importDefault2(require("url"));
    var assert_1 = __importDefault2(require("assert"));
    var debug_1 = __importDefault2(require_src7());
    var agent_base_1 = require_src8();
    var parse_proxy_response_1 = __importDefault2(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_12.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name2 of Object.keys(headers)) {
            payload += `${name2}: ${headers[name2]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist9 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault2(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@tootallnate/once/dist/index.js
var require_dist10 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/@tootallnate/once/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function once(emitter, name2, { signal } = {}) {
      return new Promise((resolve, reject) => {
        function cleanup() {
          signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", cleanup);
          emitter.removeListener(name2, onEvent);
          emitter.removeListener("error", onError);
        }
        function onEvent(...args) {
          cleanup();
          resolve(args);
        }
        function onError(err) {
          cleanup();
          reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", cleanup);
        emitter.on(name2, onEvent);
        emitter.on("error", onError);
      });
    }
    exports2.default = once;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault2(require("net"));
    var tls_1 = __importDefault2(require("tls"));
    var url_12 = __importDefault2(require("url"));
    var debug_1 = __importDefault2(require_src7());
    var once_1 = __importDefault2(require_dist10());
    var agent_base_1 = require_src8();
    var debug = (0, debug_1.default)("http-proxy-agent");
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    var HttpProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_12.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_12.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            parsed.port = "";
          }
          req.path = url_12.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield (0, once_1.default)(socket, "connect");
          return socket;
        });
      }
    };
    exports2.default = HttpProxyAgent;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/dist/index.js
var require_dist11 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/node_modules/http-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault2(require_agent2());
    function createHttpProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent2) {
      createHttpProxyAgent2.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent || (createHttpProxyAgent = {}));
    module2.exports = createHttpProxyAgent;
  }
});

// node_modules/@azure/core-tracing/dist/index.js
var require_dist12 = __commonJS({
  "node_modules/@azure/core-tracing/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    function createTracingContext(options = {}) {
      let context = new TracingContextImpl(options.parentContext);
      if (options.span) {
        context = context.setValue(knownContextKeys.span, options.span);
      }
      if (options.namespace) {
        context = context.setValue(knownContextKeys.namespace, options.namespace);
      }
      return context;
    }
    var TracingContextImpl = class _TracingContextImpl {
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
    function createDefaultTracingSpan() {
      return {
        end: () => {
        },
        isRecording: () => false,
        recordException: () => {
        },
        setAttribute: () => {
        },
        setStatus: () => {
        }
      };
    }
    function createDefaultInstrumenter() {
      return {
        createRequestHeaders: () => {
          return {};
        },
        parseTraceparentHeader: () => {
          return void 0;
        },
        startSpan: (_name, spanOptions) => {
          return {
            span: createDefaultTracingSpan(),
            tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
          };
        },
        withContext(_context, callback, ...callbackArgs) {
          return callback(...callbackArgs);
        }
      };
    }
    var instrumenterImplementation;
    function useInstrumenter(instrumenter) {
      instrumenterImplementation = instrumenter;
    }
    function getInstrumenter() {
      if (!instrumenterImplementation) {
        instrumenterImplementation = createDefaultInstrumenter();
      }
      return instrumenterImplementation;
    }
    function createTracingClient(options) {
      const { namespace, packageName, packageVersion } = options;
      function startSpan(name2, operationOptions, spanOptions) {
        var _a;
        const startSpanResult = getInstrumenter().startSpan(name2, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext }));
        let tracingContext = startSpanResult.tracingContext;
        const span = startSpanResult.span;
        if (!tracingContext.getValue(knownContextKeys.namespace)) {
          tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
        }
        span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
        const updatedOptions = Object.assign({}, operationOptions, {
          tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
        });
        return {
          span,
          updatedOptions
        };
      }
      async function withSpan(name2, operationOptions, callback, spanOptions) {
        const { span, updatedOptions } = startSpan(name2, operationOptions, spanOptions);
        try {
          const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
          span.setStatus({ status: "success" });
          return result;
        } catch (err) {
          span.setStatus({ status: "error", error: err });
          throw err;
        } finally {
          span.end();
        }
      }
      function withContext(context, callback, ...callbackArgs) {
        return getInstrumenter().withContext(context, callback, ...callbackArgs);
      }
      function parseTraceparentHeader(traceparentHeader) {
        return getInstrumenter().parseTraceparentHeader(traceparentHeader);
      }
      function createRequestHeaders(tracingContext) {
        return getInstrumenter().createRequestHeaders(tracingContext);
      }
      return {
        startSpan,
        withSpan,
        withContext,
        parseTraceparentHeader,
        createRequestHeaders
      };
    }
    exports2.createTracingClient = createTracingClient;
    exports2.useInstrumenter = useInstrumenter;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/index.js
var require_dist13 = __commonJS({
  "node_modules/@azure/core-rest-pipeline/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var logger$1 = require_dist6();
    var coreUtil = require_dist8();
    var os = require("os");
    var abortController = require_dist7();
    var FormData = require_form_data();
    var httpsProxyAgent = require_dist9();
    var httpProxyAgent = require_dist11();
    var coreTracing = require_dist12();
    var util = require("util");
    var http = require("http");
    var https = require("https");
    var zlib = require("zlib");
    var stream = require("stream");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var os__namespace = /* @__PURE__ */ _interopNamespace(os);
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData);
    var http__namespace = /* @__PURE__ */ _interopNamespace(http);
    var https__namespace = /* @__PURE__ */ _interopNamespace(https);
    var zlib__namespace = /* @__PURE__ */ _interopNamespace(zlib);
    var ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    var HttpPipeline = class _HttpPipeline {
      constructor(policies) {
        var _a;
        this._policies = [];
        this._policies = (_a = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a !== void 0 ? _a : [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name2) {
          return {
            name: name2,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
    function createEmptyPipeline() {
      return HttpPipeline.create();
    }
    var logger = logger$1.createClientLogger("core-rest-pipeline");
    var RedactedString = "REDACTED";
    var defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    var defaultAllowedQueryParameters = ["api-version"];
    var Sanitizer = class {
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || coreUtil.isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
    };
    var logPolicyName = "logPolicy";
    function logPolicy(options = {}) {
      var _a;
      const logger$12 = (_a = options.logger) !== null && _a !== void 0 ? _a : logger.info;
      const sanitizer = new Sanitizer({
        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
      });
      return {
        name: logPolicyName,
        async sendRequest(request, next) {
          if (!logger$12.enabled) {
            return next(request);
          }
          logger$12(`Request: ${sanitizer.sanitize(request)}`);
          const response = await next(request);
          logger$12(`Response status code: ${response.status}`);
          logger$12(`Headers: ${sanitizer.sanitize(response.headers)}`);
          return response;
        }
      };
    }
    var redirectPolicyName = "redirectPolicy";
    var allowedRedirect = ["GET", "HEAD"];
    function redirectPolicy(options = {}) {
      const { maxRetries = 20 } = options;
      return {
        name: redirectPolicyName,
        async sendRequest(request, next) {
          const response = await next(request);
          return handleRedirect(next, response, maxRetries);
        }
      };
    }
    async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
      const { request, status, headers } = response;
      const locationHeader = headers.get("location");
      if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
        const url = new URL(locationHeader, request.url);
        request.url = url.toString();
        if (status === 303) {
          request.method = "GET";
          request.headers.delete("Content-Length");
          delete request.body;
        }
        request.headers.delete("Authorization");
        const res = await next(request);
        return handleRedirect(next, res, maxRetries, currentRetries + 1);
      }
      return response;
    }
    function getHeaderName() {
      return "User-Agent";
    }
    function setPlatformSpecificData(map) {
      map.set("Node", process.version);
      map.set("OS", `(${os__namespace.arch()}-${os__namespace.type()}-${os__namespace.release()})`);
    }
    var SDK_VERSION = "1.12.0";
    var DEFAULT_RETRY_POLICY_COUNT = 3;
    function getUserAgentString(telemetryInfo) {
      const parts = [];
      for (const [key, value] of telemetryInfo) {
        const token = value ? `${key}/${value}` : key;
        parts.push(token);
      }
      return parts.join(" ");
    }
    function getUserAgentHeaderName() {
      return getHeaderName();
    }
    function getUserAgentValue(prefix) {
      const runtimeInfo = /* @__PURE__ */ new Map();
      runtimeInfo.set("core-rest-pipeline", SDK_VERSION);
      setPlatformSpecificData(runtimeInfo);
      const defaultAgent = getUserAgentString(runtimeInfo);
      const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
      return userAgentValue;
    }
    var UserAgentHeaderName = getUserAgentHeaderName();
    var userAgentPolicyName = "userAgentPolicy";
    function userAgentPolicy(options = {}) {
      const userAgentValue = getUserAgentValue(options.userAgentPrefix);
      return {
        name: userAgentPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(UserAgentHeaderName)) {
            request.headers.set(UserAgentHeaderName, userAgentValue);
          }
          return next(request);
        }
      };
    }
    var decompressResponsePolicyName = "decompressResponsePolicy";
    function decompressResponsePolicy() {
      return {
        name: decompressResponsePolicyName,
        async sendRequest(request, next) {
          if (request.method !== "HEAD") {
            request.headers.set("Accept-Encoding", "gzip,deflate");
          }
          return next(request);
        }
      };
    }
    var StandardAbortMessage = "The operation was aborted.";
    function delay(delayInMs, value, options) {
      return new Promise((resolve, reject) => {
        let timer = void 0;
        let onAborted = void 0;
        const rejectOnAbort = () => {
          return reject(new abortController.AbortError((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
        };
        const removeListeners = () => {
          if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
            options.abortSignal.removeEventListener("abort", onAborted);
          }
        };
        onAborted = () => {
          if (timer) {
            clearTimeout(timer);
          }
          removeListeners();
          return rejectOnAbort();
        };
        if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
          return rejectOnAbort();
        }
        timer = setTimeout(() => {
          removeListeners();
          resolve(value);
        }, delayInMs);
        if (options === null || options === void 0 ? void 0 : options.abortSignal) {
          options.abortSignal.addEventListener("abort", onAborted);
        }
      });
    }
    function parseHeaderValueAsNumber(response, headerName) {
      const value = response.headers.get(headerName);
      if (!value)
        return;
      const valueAsNum = Number(value);
      if (Number.isNaN(valueAsNum))
        return;
      return valueAsNum;
    }
    var RetryAfterHeader = "Retry-After";
    var AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
    function getRetryAfterInMs(response) {
      if (!(response && [429, 503].includes(response.status)))
        return void 0;
      try {
        for (const header of AllRetryAfterHeaders) {
          const retryAfterValue = parseHeaderValueAsNumber(response, header);
          if (retryAfterValue === 0 || retryAfterValue) {
            const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
            return retryAfterValue * multiplyingFactor;
          }
        }
        const retryAfterHeader = response.headers.get(RetryAfterHeader);
        if (!retryAfterHeader)
          return;
        const date = Date.parse(retryAfterHeader);
        const diff = date - Date.now();
        return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
      } catch (e) {
        return void 0;
      }
    }
    function isThrottlingRetryResponse(response) {
      return Number.isFinite(getRetryAfterInMs(response));
    }
    function throttlingRetryStrategy() {
      return {
        name: "throttlingRetryStrategy",
        retry({ response }) {
          const retryAfterInMs = getRetryAfterInMs(response);
          if (!Number.isFinite(retryAfterInMs)) {
            return { skipStrategy: true };
          }
          return {
            retryAfterInMs
          };
        }
      };
    }
    var DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
    function exponentialRetryStrategy(options = {}) {
      var _a, _b;
      const retryInterval = (_a = options.retryDelayInMs) !== null && _a !== void 0 ? _a : DEFAULT_CLIENT_RETRY_INTERVAL;
      const maxRetryInterval = (_b = options.maxRetryDelayInMs) !== null && _b !== void 0 ? _b : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
      let retryAfterInMs = retryInterval;
      return {
        name: "exponentialRetryStrategy",
        retry({ retryCount, response, responseError }) {
          const matchedSystemError = isSystemError(responseError);
          const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
          const isExponential = isExponentialRetryResponse(response);
          const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
          const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
          if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
            return { skipStrategy: true };
          }
          if (responseError && !matchedSystemError && !isExponential) {
            return { errorToThrow: responseError };
          }
          const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
          const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
          retryAfterInMs = clampedExponentialDelay / 2 + coreUtil.getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
          return { retryAfterInMs };
        }
      };
    }
    function isExponentialRetryResponse(response) {
      return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
    }
    function isSystemError(err) {
      if (!err) {
        return false;
      }
      return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT";
    }
    var retryPolicyLogger = logger$1.createClientLogger("core-rest-pipeline retryPolicy");
    var retryPolicyName = "retryPolicy";
    function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
      const logger2 = options.logger || retryPolicyLogger;
      return {
        name: retryPolicyName,
        async sendRequest(request, next) {
          var _a, _b;
          let response;
          let responseError;
          let retryCount = -1;
          retryRequest:
            while (true) {
              retryCount += 1;
              response = void 0;
              responseError = void 0;
              try {
                logger2.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
                response = await next(request);
                logger2.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
              } catch (e) {
                logger2.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
                responseError = e;
                if (!e || responseError.name !== "RestError") {
                  throw e;
                }
                response = responseError.response;
              }
              if ((_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                logger2.error(`Retry ${retryCount}: Request aborted.`);
                const abortError = new abortController.AbortError();
                throw abortError;
              }
              if (retryCount >= ((_b = options.maxRetries) !== null && _b !== void 0 ? _b : DEFAULT_RETRY_POLICY_COUNT)) {
                logger2.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
                if (responseError) {
                  throw responseError;
                } else if (response) {
                  return response;
                } else {
                  throw new Error("Maximum retries reached with no response or error to throw");
                }
              }
              logger2.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
              strategiesLoop:
                for (const strategy of strategies) {
                  const strategyLogger = strategy.logger || retryPolicyLogger;
                  strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                  const modifiers = strategy.retry({
                    retryCount,
                    response,
                    responseError
                  });
                  if (modifiers.skipStrategy) {
                    strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                    continue strategiesLoop;
                  }
                  const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                  if (errorToThrow) {
                    strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                    throw errorToThrow;
                  }
                  if (retryAfterInMs || retryAfterInMs === 0) {
                    strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                    await delay(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                    continue retryRequest;
                  }
                  if (redirectTo) {
                    strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                    request.url = redirectTo;
                    continue retryRequest;
                  }
                }
              if (responseError) {
                logger2.info(`None of the retry strategies could work with the received error. Throwing it.`);
                throw responseError;
              }
              if (response) {
                logger2.info(`None of the retry strategies could work with the received response. Returning it.`);
                return response;
              }
            }
        }
      };
    }
    var defaultRetryPolicyName = "defaultRetryPolicy";
    function defaultRetryPolicy(options = {}) {
      var _a;
      return {
        name: defaultRetryPolicyName,
        sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
          maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
    var formDataPolicyName = "formDataPolicy";
    function formDataPolicy() {
      return {
        name: formDataPolicyName,
        async sendRequest(request, next) {
          if (request.formData) {
            const contentType = request.headers.get("Content-Type");
            if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
              request.body = wwwFormUrlEncode(request.formData);
              request.formData = void 0;
            } else {
              await prepareFormData(request.formData, request);
            }
          }
          return next(request);
        }
      };
    }
    function wwwFormUrlEncode(formData) {
      const urlSearchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(formData)) {
        if (Array.isArray(value)) {
          for (const subValue of value) {
            urlSearchParams.append(key, subValue.toString());
          }
        } else {
          urlSearchParams.append(key, value.toString());
        }
      }
      return urlSearchParams.toString();
    }
    async function prepareFormData(formData, request) {
      const requestForm = new FormData__default["default"]();
      for (const formKey of Object.keys(formData)) {
        const formValue = formData[formKey];
        if (Array.isArray(formValue)) {
          for (const subValue of formValue) {
            requestForm.append(formKey, subValue);
          }
        } else {
          requestForm.append(formKey, formValue);
        }
      }
      request.body = requestForm;
      request.formData = void 0;
      const contentType = request.headers.get("Content-Type");
      if (contentType && contentType.indexOf("multipart/form-data") !== -1) {
        request.headers.set("Content-Type", `multipart/form-data; boundary=${requestForm.getBoundary()}`);
      }
      try {
        const contentLength = await new Promise((resolve, reject) => {
          requestForm.getLength((err, length) => {
            if (err) {
              reject(err);
            } else {
              resolve(length);
            }
          });
        });
        request.headers.set("Content-Length", contentLength);
      } catch (e) {
      }
    }
    var HTTPS_PROXY = "HTTPS_PROXY";
    var HTTP_PROXY = "HTTP_PROXY";
    var ALL_PROXY = "ALL_PROXY";
    var NO_PROXY = "NO_PROXY";
    var proxyPolicyName = "proxyPolicy";
    var globalNoProxyList = [];
    var noProxyListLoaded = false;
    var globalBypassedMap = /* @__PURE__ */ new Map();
    function getEnvironmentValue(name2) {
      if (process.env[name2]) {
        return process.env[name2];
      } else if (process.env[name2.toLowerCase()]) {
        return process.env[name2.toLowerCase()];
      }
      return void 0;
    }
    function loadEnvironmentProxyValue() {
      if (!process) {
        return void 0;
      }
      const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
      const allProxy = getEnvironmentValue(ALL_PROXY);
      const httpProxy = getEnvironmentValue(HTTP_PROXY);
      return httpsProxy || allProxy || httpProxy;
    }
    function isBypassed(uri, noProxyList, bypassedMap) {
      if (noProxyList.length === 0) {
        return false;
      }
      const host = new URL(uri).hostname;
      if (bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.has(host)) {
        return bypassedMap.get(host);
      }
      let isBypassedFlag = false;
      for (const pattern of noProxyList) {
        if (pattern[0] === ".") {
          if (host.endsWith(pattern)) {
            isBypassedFlag = true;
          } else {
            if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
              isBypassedFlag = true;
            }
          }
        } else {
          if (host === pattern) {
            isBypassedFlag = true;
          }
        }
      }
      bypassedMap === null || bypassedMap === void 0 ? void 0 : bypassedMap.set(host, isBypassedFlag);
      return isBypassedFlag;
    }
    function loadNoProxy() {
      const noProxy = getEnvironmentValue(NO_PROXY);
      noProxyListLoaded = true;
      if (noProxy) {
        return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
      }
      return [];
    }
    function getDefaultProxySettings(proxyUrl) {
      if (!proxyUrl) {
        proxyUrl = loadEnvironmentProxyValue();
        if (!proxyUrl) {
          return void 0;
        }
      }
      const parsedUrl = new URL(proxyUrl);
      const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
      return {
        host: schema + parsedUrl.hostname,
        port: Number.parseInt(parsedUrl.port || "80"),
        username: parsedUrl.username,
        password: parsedUrl.password
      };
    }
    function getProxyAgentOptions(proxySettings, { headers, tlsSettings }) {
      let parsedProxyUrl;
      try {
        parsedProxyUrl = new URL(proxySettings.host);
      } catch (_error) {
        throw new Error(`Expecting a valid host string in proxy settings, but found "${proxySettings.host}".`);
      }
      if (tlsSettings) {
        logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
      }
      const proxyAgentOptions = {
        hostname: parsedProxyUrl.hostname,
        port: proxySettings.port,
        protocol: parsedProxyUrl.protocol,
        headers: headers.toJSON()
      };
      if (proxySettings.username && proxySettings.password) {
        proxyAgentOptions.auth = `${proxySettings.username}:${proxySettings.password}`;
      } else if (proxySettings.username) {
        proxyAgentOptions.auth = `${proxySettings.username}`;
      }
      return proxyAgentOptions;
    }
    function setProxyAgentOnRequest(request, cachedAgents) {
      if (request.agent) {
        return;
      }
      const url = new URL(request.url);
      const isInsecure = url.protocol !== "https:";
      const proxySettings = request.proxySettings;
      if (proxySettings) {
        if (isInsecure) {
          if (!cachedAgents.httpProxyAgent) {
            const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
            cachedAgents.httpProxyAgent = new httpProxyAgent.HttpProxyAgent(proxyAgentOptions);
          }
          request.agent = cachedAgents.httpProxyAgent;
        } else {
          if (!cachedAgents.httpsProxyAgent) {
            const proxyAgentOptions = getProxyAgentOptions(proxySettings, request);
            cachedAgents.httpsProxyAgent = new httpsProxyAgent.HttpsProxyAgent(proxyAgentOptions);
          }
          request.agent = cachedAgents.httpsProxyAgent;
        }
      }
    }
    function proxyPolicy(proxySettings = getDefaultProxySettings(), options) {
      if (!noProxyListLoaded) {
        globalNoProxyList.push(...loadNoProxy());
      }
      const cachedAgents = {};
      return {
        name: proxyPolicyName,
        async sendRequest(request, next) {
          var _a;
          if (!request.proxySettings && !isBypassed(request.url, (_a = options === null || options === void 0 ? void 0 : options.customNoProxyList) !== null && _a !== void 0 ? _a : globalNoProxyList, (options === null || options === void 0 ? void 0 : options.customNoProxyList) ? void 0 : globalBypassedMap)) {
            request.proxySettings = proxySettings;
          }
          if (request.proxySettings) {
            setProxyAgentOnRequest(request, cachedAgents);
          }
          return next(request);
        }
      };
    }
    var setClientRequestIdPolicyName = "setClientRequestIdPolicy";
    function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
      return {
        name: setClientRequestIdPolicyName,
        async sendRequest(request, next) {
          if (!request.headers.has(requestIdHeaderName)) {
            request.headers.set(requestIdHeaderName, request.requestId);
          }
          return next(request);
        }
      };
    }
    var tlsPolicyName = "tlsPolicy";
    function tlsPolicy(tlsSettings) {
      return {
        name: tlsPolicyName,
        sendRequest: async (req, next) => {
          if (!req.tlsSettings) {
            req.tlsSettings = tlsSettings;
          }
          return next(req);
        }
      };
    }
    var custom = util.inspect.custom;
    var errorSanitizer = new Sanitizer();
    var RestError = class _RestError extends Error {
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, _RestError.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
      }
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
    function isRestError(e) {
      if (e instanceof RestError) {
        return true;
      }
      return coreUtil.isError(e) && e.name === "RestError";
    }
    var tracingPolicyName = "tracingPolicy";
    function tracingPolicy(options = {}) {
      const userAgent = getUserAgentValue(options.userAgentPrefix);
      const tracingClient = tryCreateTracingClient();
      return {
        name: tracingPolicyName,
        async sendRequest(request, next) {
          var _a, _b;
          if (!tracingClient || !((_a = request.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext)) {
            return next(request);
          }
          const { span, tracingContext } = (_b = tryCreateSpan(tracingClient, request, userAgent)) !== null && _b !== void 0 ? _b : {};
          if (!span || !tracingContext) {
            return next(request);
          }
          try {
            const response = await tracingClient.withContext(tracingContext, next, request);
            tryProcessResponse(span, response);
            return response;
          } catch (err) {
            tryProcessError(span, err);
            throw err;
          }
        }
      };
    }
    function tryCreateTracingClient() {
      try {
        return coreTracing.createTracingClient({
          namespace: "",
          packageName: "@azure/core-rest-pipeline",
          packageVersion: SDK_VERSION
        });
      } catch (e) {
        logger.warning(`Error when creating the TracingClient: ${coreUtil.getErrorMessage(e)}`);
        return void 0;
      }
    }
    function tryCreateSpan(tracingClient, request, userAgent) {
      try {
        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
          spanKind: "client",
          spanAttributes: {
            "http.method": request.method,
            "http.url": request.url,
            requestId: request.requestId
          }
        });
        if (!span.isRecording()) {
          span.end();
          return void 0;
        }
        if (userAgent) {
          span.setAttribute("http.user_agent", userAgent);
        }
        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
        for (const [key, value] of Object.entries(headers)) {
          request.headers.set(key, value);
        }
        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
      } catch (e) {
        logger.warning(`Skipping creating a tracing span due to an error: ${coreUtil.getErrorMessage(e)}`);
        return void 0;
      }
    }
    function tryProcessError(span, error) {
      try {
        span.setStatus({
          status: "error",
          error: coreUtil.isError(error) ? error : void 0
        });
        if (isRestError(error) && error.statusCode) {
          span.setAttribute("http.status_code", error.statusCode);
        }
        span.end();
      } catch (e) {
        logger.warning(`Skipping tracing span processing due to an error: ${coreUtil.getErrorMessage(e)}`);
      }
    }
    function tryProcessResponse(span, response) {
      try {
        span.setAttribute("http.status_code", response.status);
        const serviceRequestId = response.headers.get("x-ms-request-id");
        if (serviceRequestId) {
          span.setAttribute("serviceRequestId", serviceRequestId);
        }
        span.setStatus({
          status: "success"
        });
        span.end();
      } catch (e) {
        logger.warning(`Skipping tracing span processing due to an error: ${coreUtil.getErrorMessage(e)}`);
      }
    }
    function createPipelineFromOptions(options) {
      var _a;
      const pipeline = createEmptyPipeline();
      if (coreUtil.isNode) {
        if (options.tlsOptions) {
          pipeline.addPolicy(tlsPolicy(options.tlsOptions));
        }
        pipeline.addPolicy(proxyPolicy(options.proxyOptions));
        pipeline.addPolicy(decompressResponsePolicy());
      }
      pipeline.addPolicy(formDataPolicy());
      pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
      pipeline.addPolicy(setClientRequestIdPolicy((_a = options.telemetryOptions) === null || _a === void 0 ? void 0 : _a.clientRequestIdHeaderName));
      pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
      pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: "Retry" });
      if (coreUtil.isNode) {
        pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
      }
      pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
      return pipeline;
    }
    function normalizeName(name2) {
      return name2.toLowerCase();
    }
    function* headerIterator(map) {
      for (const entry of map.values()) {
        yield [entry.name, entry.value];
      }
    }
    var HttpHeadersImpl = class {
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name2, value) {
        this._headersMap.set(normalizeName(name2), { name: name2, value: String(value) });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name2) {
        var _a;
        return (_a = this._headersMap.get(normalizeName(name2))) === null || _a === void 0 ? void 0 : _a.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name2) {
        return this._headersMap.has(normalizeName(name2));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name2) {
        this._headersMap.delete(normalizeName(name2));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
    function createHttpHeaders(rawHeaders) {
      return new HttpHeadersImpl(rawHeaders);
    }
    var DEFAULT_TLS_SETTINGS = {};
    function isReadableStream(body) {
      return body && typeof body.pipe === "function";
    }
    function isStreamComplete(stream2) {
      return new Promise((resolve) => {
        stream2.on("close", resolve);
        stream2.on("end", resolve);
        stream2.on("error", resolve);
      });
    }
    function isArrayBuffer(body) {
      return body && typeof body.byteLength === "number";
    }
    var ReportTransform = class extends stream.Transform {
      // eslint-disable-next-line @typescript-eslint/ban-types
      _transform(chunk, _encoding, callback) {
        this.push(chunk);
        this.loadedBytes += chunk.length;
        try {
          this.progressCallback({ loadedBytes: this.loadedBytes });
          callback();
        } catch (e) {
          callback(e);
        }
      }
      constructor(progressCallback) {
        super();
        this.loadedBytes = 0;
        this.progressCallback = progressCallback;
      }
    };
    var NodeHttpClient = class {
      constructor() {
        this.cachedHttpsAgents = /* @__PURE__ */ new WeakMap();
      }
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request) {
        var _a, _b, _c;
        const abortController$1 = new abortController.AbortController();
        let abortListener;
        if (request.abortSignal) {
          if (request.abortSignal.aborted) {
            throw new abortController.AbortError("The operation was aborted.");
          }
          abortListener = (event) => {
            if (event.type === "abort") {
              abortController$1.abort();
            }
          };
          request.abortSignal.addEventListener("abort", abortListener);
        }
        if (request.timeout > 0) {
          setTimeout(() => {
            abortController$1.abort();
          }, request.timeout);
        }
        const acceptEncoding = request.headers.get("Accept-Encoding");
        const shouldDecompress = (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("gzip")) || (acceptEncoding === null || acceptEncoding === void 0 ? void 0 : acceptEncoding.includes("deflate"));
        let body = typeof request.body === "function" ? request.body() : request.body;
        if (body && !request.headers.has("Content-Length")) {
          const bodyLength = getBodyLength(body);
          if (bodyLength !== null) {
            request.headers.set("Content-Length", bodyLength);
          }
        }
        let responseStream;
        try {
          if (body && request.onUploadProgress) {
            const onUploadProgress = request.onUploadProgress;
            const uploadReportStream = new ReportTransform(onUploadProgress);
            uploadReportStream.on("error", (e) => {
              logger.error("Error in upload progress", e);
            });
            if (isReadableStream(body)) {
              body.pipe(uploadReportStream);
            } else {
              uploadReportStream.end(body);
            }
            body = uploadReportStream;
          }
          const res = await this.makeRequest(request, abortController$1, body);
          const headers = getResponseHeaders(res);
          const status = (_a = res.statusCode) !== null && _a !== void 0 ? _a : 0;
          const response = {
            status,
            headers,
            request
          };
          if (request.method === "HEAD") {
            res.resume();
            return response;
          }
          responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
          const onDownloadProgress = request.onDownloadProgress;
          if (onDownloadProgress) {
            const downloadReportStream = new ReportTransform(onDownloadProgress);
            downloadReportStream.on("error", (e) => {
              logger.error("Error in download progress", e);
            });
            responseStream.pipe(downloadReportStream);
            responseStream = downloadReportStream;
          }
          if (
            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
            ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(Number.POSITIVE_INFINITY)) || ((_c = request.streamResponseStatusCodes) === null || _c === void 0 ? void 0 : _c.has(response.status))
          ) {
            response.readableStreamBody = responseStream;
          } else {
            response.bodyAsText = await streamToText(responseStream);
          }
          return response;
        } finally {
          if (request.abortSignal && abortListener) {
            let uploadStreamDone = Promise.resolve();
            if (isReadableStream(body)) {
              uploadStreamDone = isStreamComplete(body);
            }
            let downloadStreamDone = Promise.resolve();
            if (isReadableStream(responseStream)) {
              downloadStreamDone = isStreamComplete(responseStream);
            }
            Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
              var _a2;
              if (abortListener) {
                (_a2 = request.abortSignal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", abortListener);
              }
            }).catch((e) => {
              logger.warning("Error when cleaning up abortListener on httpRequest", e);
            });
          }
        }
      }
      makeRequest(request, abortController$1, body) {
        var _a;
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        const agent = (_a = request.agent) !== null && _a !== void 0 ? _a : this.getOrCreateAgent(request, isInsecure);
        const options = {
          agent,
          hostname: url.hostname,
          path: `${url.pathname}${url.search}`,
          port: url.port,
          method: request.method,
          headers: request.headers.toJSON({ preserveCase: true })
        };
        return new Promise((resolve, reject) => {
          const req = isInsecure ? http__namespace.request(options, resolve) : https__namespace.request(options, resolve);
          req.once("error", (err) => {
            var _a2;
            reject(new RestError(err.message, { code: (_a2 = err.code) !== null && _a2 !== void 0 ? _a2 : RestError.REQUEST_SEND_ERROR, request }));
          });
          abortController$1.signal.addEventListener("abort", () => {
            const abortError = new abortController.AbortError("The operation was aborted.");
            req.destroy(abortError);
            reject(abortError);
          });
          if (body && isReadableStream(body)) {
            body.pipe(req);
          } else if (body) {
            if (typeof body === "string" || Buffer.isBuffer(body)) {
              req.end(body);
            } else if (isArrayBuffer(body)) {
              req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
            } else {
              logger.error("Unrecognized body type", body);
              reject(new RestError("Unrecognized body type"));
            }
          } else {
            req.end();
          }
        });
      }
      getOrCreateAgent(request, isInsecure) {
        var _a;
        const disableKeepAlive = request.disableKeepAlive;
        if (isInsecure) {
          if (disableKeepAlive) {
            return http__namespace.globalAgent;
          }
          if (!this.cachedHttpAgent) {
            this.cachedHttpAgent = new http__namespace.Agent({ keepAlive: true });
          }
          return this.cachedHttpAgent;
        } else {
          if (disableKeepAlive && !request.tlsSettings) {
            return https__namespace.globalAgent;
          }
          const tlsSettings = (_a = request.tlsSettings) !== null && _a !== void 0 ? _a : DEFAULT_TLS_SETTINGS;
          let agent = this.cachedHttpsAgents.get(tlsSettings);
          if (agent && agent.options.keepAlive === !disableKeepAlive) {
            return agent;
          }
          logger.info("No cached TLS Agent exist, creating a new Agent");
          agent = new https__namespace.Agent(Object.assign({
            // keepAlive is true if disableKeepAlive is false.
            keepAlive: !disableKeepAlive
          }, tlsSettings));
          this.cachedHttpsAgents.set(tlsSettings, agent);
          return agent;
        }
      }
    };
    function getResponseHeaders(res) {
      const headers = createHttpHeaders();
      for (const header of Object.keys(res.headers)) {
        const value = res.headers[header];
        if (Array.isArray(value)) {
          if (value.length > 0) {
            headers.set(header, value[0]);
          }
        } else if (value) {
          headers.set(header, value);
        }
      }
      return headers;
    }
    function getDecodedResponseStream(stream2, headers) {
      const contentEncoding = headers.get("Content-Encoding");
      if (contentEncoding === "gzip") {
        const unzip = zlib__namespace.createGunzip();
        stream2.pipe(unzip);
        return unzip;
      } else if (contentEncoding === "deflate") {
        const inflate = zlib__namespace.createInflate();
        stream2.pipe(inflate);
        return inflate;
      }
      return stream2;
    }
    function streamToText(stream2) {
      return new Promise((resolve, reject) => {
        const buffer = [];
        stream2.on("data", (chunk) => {
          if (Buffer.isBuffer(chunk)) {
            buffer.push(chunk);
          } else {
            buffer.push(Buffer.from(chunk));
          }
        });
        stream2.on("end", () => {
          resolve(Buffer.concat(buffer).toString("utf8"));
        });
        stream2.on("error", (e) => {
          if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
            reject(e);
          } else {
            reject(new RestError(`Error reading response as text: ${e.message}`, {
              code: RestError.PARSE_ERROR
            }));
          }
        });
      });
    }
    function getBodyLength(body) {
      if (!body) {
        return 0;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (isReadableStream(body)) {
        return null;
      } else if (isArrayBuffer(body)) {
        return body.byteLength;
      } else if (typeof body === "string") {
        return Buffer.from(body).length;
      } else {
        return null;
      }
    }
    function createNodeHttpClient() {
      return new NodeHttpClient();
    }
    function createDefaultHttpClient() {
      return createNodeHttpClient();
    }
    var PipelineRequestImpl = class {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a = options.headers) !== null && _a !== void 0 ? _a : createHttpHeaders();
        this.method = (_b = options.method) !== null && _b !== void 0 ? _b : "GET";
        this.timeout = (_c = options.timeout) !== null && _c !== void 0 ? _c : 0;
        this.formData = options.formData;
        this.disableKeepAlive = (_d = options.disableKeepAlive) !== null && _d !== void 0 ? _d : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || coreUtil.randomUUID();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
      }
    };
    function createPipelineRequest(options) {
      return new PipelineRequestImpl(options);
    }
    var exponentialRetryPolicyName = "exponentialRetryPolicy";
    function exponentialRetryPolicy(options = {}) {
      var _a;
      return retryPolicy([
        exponentialRetryStrategy(Object.assign(Object.assign({}, options), { ignoreSystemErrors: true }))
      ], {
        maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
      });
    }
    var systemErrorRetryPolicyName = "systemErrorRetryPolicy";
    function systemErrorRetryPolicy(options = {}) {
      var _a;
      return {
        name: systemErrorRetryPolicyName,
        sendRequest: retryPolicy([
          exponentialRetryStrategy(Object.assign(Object.assign({}, options), { ignoreHttpStatusCodes: true }))
        ], {
          maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
    var throttlingRetryPolicyName = "throttlingRetryPolicy";
    function throttlingRetryPolicy(options = {}) {
      var _a;
      return {
        name: throttlingRetryPolicyName,
        sendRequest: retryPolicy([throttlingRetryStrategy()], {
          maxRetries: (_a = options.maxRetries) !== null && _a !== void 0 ? _a : DEFAULT_RETRY_POLICY_COUNT
        }).sendRequest
      };
    }
    var DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      retryIntervalInMs: 3e3,
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
    async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
      async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
          try {
            return await getAccessToken();
          } catch (_a) {
            return null;
          }
        } else {
          const finalToken = await getAccessToken();
          if (finalToken === null) {
            throw new Error("Failed to refresh access token.");
          }
          return finalToken;
        }
      }
      let token = await tryGetAccessToken();
      while (token === null) {
        await delay(retryIntervalInMs);
        token = await tryGetAccessToken();
      }
      return token;
    }
    function createTokenCycler(credential, tokenCyclerOptions) {
      let refreshWorker = null;
      let token = null;
      let tenantId;
      const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
      const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
          return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
          var _a;
          return !cycler.isRefreshing && ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
          return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
        }
      };
      function refresh(scopes, getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
          const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
          refreshWorker = beginRefresh(
            tryGetAccessToken,
            options.retryIntervalInMs,
            // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now()
          ).then((_token) => {
            refreshWorker = null;
            token = _token;
            tenantId = getTokenOptions.tenantId;
            return token;
          }).catch((reason) => {
            refreshWorker = null;
            token = null;
            tenantId = void 0;
            throw reason;
          });
        }
        return refreshWorker;
      }
      return async (scopes, tokenOptions) => {
        const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
        if (mustRefresh)
          return refresh(scopes, tokenOptions);
        if (cycler.shouldRefresh) {
          refresh(scopes, tokenOptions);
        }
        return token;
      };
    }
    var bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
    async function defaultAuthorizeRequest(options) {
      const { scopes, getAccessToken, request } = options;
      const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions
      };
      const accessToken = await getAccessToken(scopes, getTokenOptions);
      if (accessToken) {
        options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
      }
    }
    function getChallenge(response) {
      const challenge = response.headers.get("WWW-Authenticate");
      if (response.status === 401 && challenge) {
        return challenge;
      }
      return;
    }
    function bearerTokenAuthenticationPolicy(options) {
      var _a;
      const { credential, scopes, challengeCallbacks } = options;
      const logger$12 = options.logger || logger;
      const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
      const getAccessToken = credential ? createTokenCycler(
        credential
        /* , options */
      ) : () => Promise.resolve(null);
      return {
        name: bearerTokenAuthenticationPolicyName,
        /**
         * If there's no challenge parameter:
         * - It will try to retrieve the token using the cache, or the credential's getToken.
         * - Then it will try the next policy with or without the retrieved token.
         *
         * It uses the challenge parameters to:
         * - Skip a first attempt to get the token from the credential if there's no cached token,
         *   since it expects the token to be retrievable only after the challenge.
         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
         * - Send an initial request to receive the challenge if it fails.
         * - Process a challenge if the response contains it.
         * - Retrieve a token with the challenge information, then re-send the request.
         */
        async sendRequest(request, next) {
          if (!request.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
          }
          await callbacks.authorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger: logger$12
          });
          let response;
          let error;
          try {
            response = await next(request);
          } catch (err) {
            error = err;
            response = err.response;
          }
          if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
            const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              response,
              getAccessToken,
              logger: logger$12
            });
            if (shouldSendRequest) {
              return next(request);
            }
          }
          if (error) {
            throw error;
          } else {
            return response;
          }
        }
      };
    }
    var ndJsonPolicyName = "ndJsonPolicy";
    function ndJsonPolicy() {
      return {
        name: ndJsonPolicyName,
        async sendRequest(request, next) {
          if (typeof request.body === "string" && request.body.startsWith("[")) {
            const body = JSON.parse(request.body);
            if (Array.isArray(body)) {
              request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
            }
          }
          return next(request);
        }
      };
    }
    var auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
    var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
    async function sendAuthorizeRequest(options) {
      var _a, _b;
      const { scopes, getAccessToken, request } = options;
      const getTokenOptions = {
        abortSignal: request.abortSignal,
        tracingOptions: request.tracingOptions
      };
      return (_b = (_a = await getAccessToken(scopes, getTokenOptions)) === null || _a === void 0 ? void 0 : _a.token) !== null && _b !== void 0 ? _b : "";
    }
    function auxiliaryAuthenticationHeaderPolicy(options) {
      const { credentials, scopes } = options;
      const logger$12 = options.logger || logger;
      const tokenCyclerMap = /* @__PURE__ */ new WeakMap();
      return {
        name: auxiliaryAuthenticationHeaderPolicyName,
        async sendRequest(request, next) {
          if (!request.url.toLowerCase().startsWith("https://")) {
            throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
          }
          if (!credentials || credentials.length === 0) {
            logger$12.info(`${auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
            return next(request);
          }
          const tokenPromises = [];
          for (const credential of credentials) {
            let getAccessToken = tokenCyclerMap.get(credential);
            if (!getAccessToken) {
              getAccessToken = createTokenCycler(credential);
              tokenCyclerMap.set(credential, getAccessToken);
            }
            tokenPromises.push(sendAuthorizeRequest({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              getAccessToken,
              logger: logger$12
            }));
          }
          const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
          if (auxiliaryTokens.length === 0) {
            logger$12.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
            return next(request);
          }
          request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
          return next(request);
        }
      };
    }
    exports2.RestError = RestError;
    exports2.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
    exports2.auxiliaryAuthenticationHeaderPolicyName = auxiliaryAuthenticationHeaderPolicyName;
    exports2.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
    exports2.bearerTokenAuthenticationPolicyName = bearerTokenAuthenticationPolicyName;
    exports2.createDefaultHttpClient = createDefaultHttpClient;
    exports2.createEmptyPipeline = createEmptyPipeline;
    exports2.createHttpHeaders = createHttpHeaders;
    exports2.createPipelineFromOptions = createPipelineFromOptions;
    exports2.createPipelineRequest = createPipelineRequest;
    exports2.decompressResponsePolicy = decompressResponsePolicy;
    exports2.decompressResponsePolicyName = decompressResponsePolicyName;
    exports2.defaultRetryPolicy = defaultRetryPolicy;
    exports2.exponentialRetryPolicy = exponentialRetryPolicy;
    exports2.exponentialRetryPolicyName = exponentialRetryPolicyName;
    exports2.formDataPolicy = formDataPolicy;
    exports2.formDataPolicyName = formDataPolicyName;
    exports2.getDefaultProxySettings = getDefaultProxySettings;
    exports2.isRestError = isRestError;
    exports2.logPolicy = logPolicy;
    exports2.logPolicyName = logPolicyName;
    exports2.ndJsonPolicy = ndJsonPolicy;
    exports2.ndJsonPolicyName = ndJsonPolicyName;
    exports2.proxyPolicy = proxyPolicy;
    exports2.proxyPolicyName = proxyPolicyName;
    exports2.redirectPolicy = redirectPolicy;
    exports2.redirectPolicyName = redirectPolicyName;
    exports2.retryPolicy = retryPolicy;
    exports2.setClientRequestIdPolicy = setClientRequestIdPolicy;
    exports2.setClientRequestIdPolicyName = setClientRequestIdPolicyName;
    exports2.systemErrorRetryPolicy = systemErrorRetryPolicy;
    exports2.systemErrorRetryPolicyName = systemErrorRetryPolicyName;
    exports2.throttlingRetryPolicy = throttlingRetryPolicy;
    exports2.throttlingRetryPolicyName = throttlingRetryPolicyName;
    exports2.tlsPolicy = tlsPolicy;
    exports2.tlsPolicyName = tlsPolicyName;
    exports2.tracingPolicy = tracingPolicy;
    exports2.tracingPolicyName = tracingPolicyName;
    exports2.userAgentPolicy = userAgentPolicy;
    exports2.userAgentPolicyName = userAgentPolicyName;
  }
});

// node_modules/applicationinsights/out/Library/AuthorizationHandler.js
var require_AuthorizationHandler = __commonJS({
  "node_modules/applicationinsights/out/Library/AuthorizationHandler.js"(exports2, module2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var azureCore = require_dist13();
    var applicationInsightsResource = "https://monitor.azure.com//.default";
    function emptySendRequest(_request) {
      return null;
    }
    var AuthorizationHandler = (
      /** @class */
      function() {
        function AuthorizationHandler2(credential) {
          var scopes = [applicationInsightsResource];
          this._azureTokenPolicy = azureCore.bearerTokenAuthenticationPolicy({ credential, scopes });
        }
        AuthorizationHandler2.prototype.addAuthorizationHeader = function(requestOptions) {
          return __awaiter(this, void 0, void 0, function() {
            var authHeaderName, webResource;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  authHeaderName = "authorization";
                  webResource = azureCore.createPipelineRequest({ url: "https://" });
                  return [4, this._azureTokenPolicy.sendRequest(webResource, emptySendRequest)];
                case 1:
                  _a.sent();
                  requestOptions.headers[authHeaderName] = webResource.headers.get(authHeaderName);
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return AuthorizationHandler2;
      }()
    );
    module2.exports = AuthorizationHandler;
  }
});

// node_modules/applicationinsights/out/Library/Channel.js
var require_Channel = __commonJS({
  "node_modules/applicationinsights/out/Library/Channel.js"(exports2, module2) {
    "use strict";
    var Logging = require_Logging();
    var Util = require_Util();
    var Channel = (
      /** @class */
      function() {
        function Channel2(isDisabled, getBatchSize, getBatchIntervalMs, sender) {
          this._buffer = [];
          this._lastSend = 0;
          this._isDisabled = isDisabled;
          this._getBatchSize = getBatchSize;
          this._getBatchIntervalMs = getBatchIntervalMs;
          this._sender = sender;
        }
        Channel2.prototype.setUseDiskRetryCaching = function(value, resendInterval, maxBytesOnDisk) {
          this._sender.setDiskRetryMode(value, resendInterval, maxBytesOnDisk);
        };
        Channel2.prototype.send = function(envelope) {
          var _this = this;
          if (this._isDisabled()) {
            return;
          }
          if (!envelope) {
            Logging.warn("Cannot send null/undefined telemetry");
            return;
          }
          this._buffer.push(envelope);
          if (this._buffer.length >= this._getBatchSize()) {
            this.triggerSend(false);
            return;
          }
          if (!this._timeoutHandle && this._buffer.length > 0) {
            this._timeoutHandle = setTimeout(function() {
              _this._timeoutHandle = null;
              _this.triggerSend(false);
            }, this._getBatchIntervalMs());
          }
        };
        Channel2.prototype.triggerSend = function(isNodeCrashing, callback) {
          var bufferIsEmpty = this._buffer.length < 1;
          if (!bufferIsEmpty) {
            if (isNodeCrashing || Util.isNodeExit) {
              this._sender.saveOnCrash(this._buffer);
              if (typeof callback === "function") {
                callback("data saved on crash");
              }
            } else {
              this._sender.send(this._buffer, callback);
            }
          }
          this._lastSend = +/* @__PURE__ */ new Date();
          this._buffer = [];
          clearTimeout(this._timeoutHandle);
          this._timeoutHandle = null;
          if (bufferIsEmpty && typeof callback === "function") {
            callback("no data to send");
          }
        };
        return Channel2;
      }()
    );
    module2.exports = Channel;
  }
});

// node_modules/applicationinsights/out/TelemetryProcessors/AzureRoleEnvironmentTelemetryInitializer.js
var require_AzureRoleEnvironmentTelemetryInitializer = __commonJS({
  "node_modules/applicationinsights/out/TelemetryProcessors/AzureRoleEnvironmentTelemetryInitializer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.azureRoleEnvironmentTelemetryProcessor = void 0;
    function azureRoleEnvironmentTelemetryProcessor(envelope, context) {
      if (process.env.WEBSITE_SITE_NAME) {
        envelope.tags[context.keys.cloudRole] = process.env.WEBSITE_SITE_NAME;
      }
      if (process.env.WEBSITE_INSTANCE_ID) {
        envelope.tags[context.keys.cloudRoleInstance] = process.env.WEBSITE_INSTANCE_ID;
      }
    }
    exports2.azureRoleEnvironmentTelemetryProcessor = azureRoleEnvironmentTelemetryProcessor;
  }
});

// node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js
var require_SamplingTelemetryProcessor = __commonJS({
  "node_modules/applicationinsights/out/TelemetryProcessors/SamplingTelemetryProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSamplingHashCode = exports2.samplingTelemetryProcessor = void 0;
    var Contracts = require_Contracts();
    function samplingTelemetryProcessor(envelope, contextObjects) {
      var samplingPercentage = envelope.sampleRate;
      var isSampledIn = false;
      if (samplingPercentage === null || samplingPercentage === void 0 || samplingPercentage >= 100) {
        return true;
      } else if (envelope.data && Contracts.TelemetryType.Metric === Contracts.baseTypeToTelemetryType(envelope.data.baseType)) {
        return true;
      } else if (contextObjects.correlationContext && contextObjects.correlationContext.operation) {
        isSampledIn = getSamplingHashCode(contextObjects.correlationContext.operation.id) < samplingPercentage;
      } else {
        isSampledIn = Math.random() * 100 < samplingPercentage;
      }
      return isSampledIn;
    }
    exports2.samplingTelemetryProcessor = samplingTelemetryProcessor;
    function getSamplingHashCode(input) {
      var csharpMin = -2147483648;
      var csharpMax = 2147483647;
      var hash = 5381;
      if (!input) {
        return 0;
      }
      while (input.length < 8) {
        input = input + input;
      }
      for (var i = 0; i < input.length; i++) {
        hash = ((hash << 5) + hash | 0) + input.charCodeAt(i) | 0;
      }
      hash = hash <= csharpMin ? csharpMax : Math.abs(hash);
      return hash / csharpMax * 100;
    }
    exports2.getSamplingHashCode = getSamplingHashCode;
  }
});

// node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js
var require_PerformanceMetricsTelemetryProcessor = __commonJS({
  "node_modules/applicationinsights/out/TelemetryProcessors/PerformanceMetricsTelemetryProcessor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.performanceMetricsTelemetryProcessor = void 0;
    var AutoCollectPerformance = require_Performance();
    var TelemetryType = require_Contracts();
    function performanceMetricsTelemetryProcessor(envelope, client) {
      if (client) {
        client.addDocument(envelope);
      }
      switch (envelope.data.baseType) {
        case TelemetryType.TelemetryTypeString.Exception:
          AutoCollectPerformance.countException();
          break;
        case TelemetryType.TelemetryTypeString.Request:
          var requestData = envelope.data.baseData;
          AutoCollectPerformance.countRequest(requestData.duration, requestData.success);
          break;
        case TelemetryType.TelemetryTypeString.Dependency:
          var remoteDependencyData = envelope.data.baseData;
          AutoCollectPerformance.countDependency(remoteDependencyData.duration, remoteDependencyData.success);
          break;
      }
      return true;
    }
    exports2.performanceMetricsTelemetryProcessor = performanceMetricsTelemetryProcessor;
  }
});

// node_modules/applicationinsights/out/TelemetryProcessors/PreAggregatedMetricsTelemetryProcessor.js
var require_PreAggregatedMetricsTelemetryProcessor = __commonJS({
  "node_modules/applicationinsights/out/TelemetryProcessors/PreAggregatedMetricsTelemetryProcessor.js"(exports2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.preAggregatedMetricsTelemetryProcessor = void 0;
    var Contracts = require_Contracts();
    var AutoCollecPreAggregatedMetrics = require_PreAggregatedMetrics();
    var TelemetryType = require_Contracts();
    function preAggregatedMetricsTelemetryProcessor(envelope, context) {
      if (AutoCollecPreAggregatedMetrics.isEnabled()) {
        switch (envelope.data.baseType) {
          case TelemetryType.TelemetryTypeString.Exception:
            var exceptionData = envelope.data.baseData;
            exceptionData.properties = __assign2(__assign2({}, exceptionData.properties), { "_MS.ProcessedByMetricExtractors": "(Name:'Exceptions', Ver:'1.1')" });
            var exceptionDimensions = {
              cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
              cloudRoleName: envelope.tags[context.keys.cloudRole]
            };
            AutoCollecPreAggregatedMetrics.countException(exceptionDimensions);
            break;
          case TelemetryType.TelemetryTypeString.Trace:
            var traceData = envelope.data.baseData;
            traceData.properties = __assign2(__assign2({}, traceData.properties), { "_MS.ProcessedByMetricExtractors": "(Name:'Traces', Ver:'1.1')" });
            var traceDimensions = {
              cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
              cloudRoleName: envelope.tags[context.keys.cloudRole],
              traceSeverityLevel: Contracts.SeverityLevel[traceData.severity]
            };
            AutoCollecPreAggregatedMetrics.countTrace(traceDimensions);
            break;
          case TelemetryType.TelemetryTypeString.Request:
            var requestData = envelope.data.baseData;
            requestData.properties = __assign2(__assign2({}, requestData.properties), { "_MS.ProcessedByMetricExtractors": "(Name:'Requests', Ver:'1.1')" });
            var requestDimensions = {
              cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
              cloudRoleName: envelope.tags[context.keys.cloudRole],
              operationSynthetic: envelope.tags[context.keys.operationSyntheticSource],
              requestSuccess: requestData.success,
              requestResultCode: requestData.responseCode
            };
            AutoCollecPreAggregatedMetrics.countRequest(requestData.duration, requestDimensions);
            break;
          case TelemetryType.TelemetryTypeString.Dependency:
            var remoteDependencyData = envelope.data.baseData;
            remoteDependencyData.properties = __assign2(__assign2({}, remoteDependencyData.properties), { "_MS.ProcessedByMetricExtractors": "(Name:'Dependencies', Ver:'1.1')" });
            var dependencyDimensions = {
              cloudRoleInstance: envelope.tags[context.keys.cloudRoleInstance],
              cloudRoleName: envelope.tags[context.keys.cloudRole],
              operationSynthetic: envelope.tags[context.keys.operationSyntheticSource],
              dependencySuccess: remoteDependencyData.success,
              dependencyType: remoteDependencyData.type,
              dependencyTarget: remoteDependencyData.target,
              dependencyResultCode: remoteDependencyData.resultCode
            };
            AutoCollecPreAggregatedMetrics.countDependency(remoteDependencyData.duration, dependencyDimensions);
            break;
        }
      }
      return true;
    }
    exports2.preAggregatedMetricsTelemetryProcessor = preAggregatedMetricsTelemetryProcessor;
  }
});

// node_modules/applicationinsights/out/TelemetryProcessors/index.js
var require_TelemetryProcessors = __commonJS({
  "node_modules/applicationinsights/out/TelemetryProcessors/index.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding2(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_AzureRoleEnvironmentTelemetryInitializer(), exports2);
    __exportStar(require_SamplingTelemetryProcessor(), exports2);
    __exportStar(require_PerformanceMetricsTelemetryProcessor(), exports2);
    __exportStar(require_PreAggregatedMetricsTelemetryProcessor(), exports2);
  }
});

// node_modules/applicationinsights/out/Library/EnvelopeFactory.js
var require_EnvelopeFactory = __commonJS({
  "node_modules/applicationinsights/out/Library/EnvelopeFactory.js"(exports2, module2) {
    "use strict";
    var Contracts = require_Contracts();
    var Util = require_Util();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var EnvelopeFactory = (
      /** @class */
      function() {
        function EnvelopeFactory2() {
        }
        EnvelopeFactory2.createEnvelope = function(telemetry, telemetryType, commonProperties, context, config) {
          var data = null;
          switch (telemetryType) {
            case Contracts.TelemetryType.Trace:
              data = EnvelopeFactory2.createTraceData(telemetry);
              break;
            case Contracts.TelemetryType.Dependency:
              data = EnvelopeFactory2.createDependencyData(telemetry);
              break;
            case Contracts.TelemetryType.Event:
              data = EnvelopeFactory2.createEventData(telemetry);
              break;
            case Contracts.TelemetryType.Exception:
              data = EnvelopeFactory2.createExceptionData(telemetry);
              break;
            case Contracts.TelemetryType.Request:
              data = EnvelopeFactory2.createRequestData(telemetry);
              break;
            case Contracts.TelemetryType.Metric:
              data = EnvelopeFactory2.createMetricData(telemetry);
              break;
            case Contracts.TelemetryType.Availability:
              data = EnvelopeFactory2.createAvailabilityData(telemetry);
              break;
            case Contracts.TelemetryType.PageView:
              data = EnvelopeFactory2.createPageViewData(telemetry);
              break;
          }
          if (data && data.baseData) {
            if (Contracts.domainSupportsProperties(data.baseData)) {
              if (commonProperties) {
                if (!data.baseData.properties) {
                  data.baseData.properties = commonProperties;
                } else {
                  for (var name2 in commonProperties) {
                    if (!data.baseData.properties[name2]) {
                      data.baseData.properties[name2] = commonProperties[name2];
                    }
                  }
                }
              }
              EnvelopeFactory2.addAzureFunctionsCorrelationProperties(data.baseData.properties);
              if (data.baseData.properties) {
                data.baseData.properties = Util.validateStringMap(data.baseData.properties);
              }
            }
          }
          var iKey = config ? config.instrumentationKey || "" : "";
          var envelope = new Contracts.Envelope();
          envelope.data = data;
          envelope.iKey = iKey;
          envelope.name = "Microsoft.ApplicationInsights." + iKey.replace(/-/g, "") + "." + data.baseType.substr(0, data.baseType.length - 4);
          envelope.tags = this.getTags(context, telemetry.tagOverrides);
          envelope.time = (/* @__PURE__ */ new Date()).toISOString();
          envelope.ver = 1;
          envelope.sampleRate = config ? config.samplingPercentage : 100;
          if (telemetryType === Contracts.TelemetryType.Metric) {
            envelope.sampleRate = 100;
          }
          return envelope;
        };
        EnvelopeFactory2.addAzureFunctionsCorrelationProperties = function(properties) {
          var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          if (correlationContext && correlationContext.customProperties && correlationContext.customProperties["getProperty"] instanceof Function) {
            properties = properties || {};
            var property = correlationContext.customProperties.getProperty("InvocationId");
            if (property) {
              properties["InvocationId"] = property;
            }
            property = correlationContext.customProperties.getProperty("ProcessId");
            if (property) {
              properties["ProcessId"] = property;
            }
            property = correlationContext.customProperties.getProperty("LogLevel");
            if (property) {
              properties["LogLevel"] = property;
            }
            property = correlationContext.customProperties.getProperty("Category");
            if (property) {
              properties["Category"] = property;
            }
            property = correlationContext.customProperties.getProperty("HostInstanceId");
            if (property) {
              properties["HostInstanceId"] = property;
            }
            property = correlationContext.customProperties.getProperty("AzFuncLiveLogsSessionId");
            if (property) {
              properties["AzFuncLiveLogsSessionId"] = property;
            }
          }
        };
        EnvelopeFactory2.createTraceData = function(telemetry) {
          var trace = new Contracts.MessageData();
          trace.message = telemetry.message;
          trace.properties = telemetry.properties;
          if (!isNaN(telemetry.severity)) {
            trace.severityLevel = telemetry.severity;
          } else {
            trace.severityLevel = Contracts.SeverityLevel.Information;
          }
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Trace);
          data.baseData = trace;
          return data;
        };
        EnvelopeFactory2.createDependencyData = function(telemetry) {
          var remoteDependency = new Contracts.RemoteDependencyData();
          if (typeof telemetry.name === "string") {
            remoteDependency.name = telemetry.name.length > 1024 ? telemetry.name.slice(0, 1021) + "..." : telemetry.name;
          }
          remoteDependency.data = telemetry.data;
          remoteDependency.target = telemetry.target;
          remoteDependency.duration = Util.msToTimeSpan(telemetry.duration);
          remoteDependency.success = telemetry.success;
          remoteDependency.type = telemetry.dependencyTypeName;
          remoteDependency.properties = telemetry.properties;
          remoteDependency.resultCode = telemetry.resultCode ? telemetry.resultCode.toString() : "0";
          if (telemetry.id) {
            remoteDependency.id = telemetry.id;
          } else {
            remoteDependency.id = Util.w3cTraceId();
          }
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Dependency);
          data.baseData = remoteDependency;
          return data;
        };
        EnvelopeFactory2.createEventData = function(telemetry) {
          var event = new Contracts.EventData();
          event.name = telemetry.name;
          event.properties = telemetry.properties;
          event.measurements = telemetry.measurements;
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Event);
          data.baseData = event;
          return data;
        };
        EnvelopeFactory2.createExceptionData = function(telemetry) {
          var exception = new Contracts.ExceptionData();
          exception.properties = telemetry.properties;
          if (!isNaN(telemetry.severity)) {
            exception.severityLevel = telemetry.severity;
          } else {
            exception.severityLevel = Contracts.SeverityLevel.Error;
          }
          exception.measurements = telemetry.measurements;
          exception.exceptions = [];
          var stack = telemetry.exception["stack"];
          var exceptionDetails = new Contracts.ExceptionDetails();
          exceptionDetails.message = telemetry.exception.message;
          exceptionDetails.typeName = telemetry.exception.name;
          exceptionDetails.parsedStack = this.parseStack(stack);
          exceptionDetails.hasFullStack = Util.isArray(exceptionDetails.parsedStack) && exceptionDetails.parsedStack.length > 0;
          exception.exceptions.push(exceptionDetails);
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Exception);
          data.baseData = exception;
          return data;
        };
        EnvelopeFactory2.createRequestData = function(telemetry) {
          var requestData = new Contracts.RequestData();
          if (telemetry.id) {
            requestData.id = telemetry.id;
          } else {
            requestData.id = Util.w3cTraceId();
          }
          requestData.name = telemetry.name;
          requestData.url = telemetry.url;
          requestData.source = telemetry.source;
          requestData.duration = Util.msToTimeSpan(telemetry.duration);
          requestData.responseCode = telemetry.resultCode ? telemetry.resultCode.toString() : "0";
          requestData.success = telemetry.success;
          requestData.properties = telemetry.properties;
          requestData.measurements = telemetry.measurements;
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Request);
          data.baseData = requestData;
          return data;
        };
        EnvelopeFactory2.createMetricData = function(telemetry) {
          var metrics = new Contracts.MetricData();
          metrics.metrics = [];
          var metric = new Contracts.DataPoint();
          metric.count = !isNaN(telemetry.count) ? telemetry.count : 1;
          metric.kind = Contracts.DataPointType.Aggregation;
          metric.max = !isNaN(telemetry.max) ? telemetry.max : telemetry.value;
          metric.min = !isNaN(telemetry.min) ? telemetry.min : telemetry.value;
          metric.name = telemetry.name;
          metric.stdDev = !isNaN(telemetry.stdDev) ? telemetry.stdDev : 0;
          metric.value = telemetry.value;
          metric.ns = telemetry.namespace;
          metrics.metrics.push(metric);
          metrics.properties = telemetry.properties;
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Metric);
          data.baseData = metrics;
          return data;
        };
        EnvelopeFactory2.createAvailabilityData = function(telemetry) {
          var availabilityData = new Contracts.AvailabilityData();
          if (telemetry.id) {
            availabilityData.id = telemetry.id;
          } else {
            availabilityData.id = Util.w3cTraceId();
          }
          availabilityData.name = telemetry.name;
          availabilityData.duration = Util.msToTimeSpan(telemetry.duration);
          availabilityData.success = telemetry.success;
          availabilityData.runLocation = telemetry.runLocation;
          availabilityData.message = telemetry.message;
          availabilityData.measurements = telemetry.measurements;
          availabilityData.properties = telemetry.properties;
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.Availability);
          data.baseData = availabilityData;
          return data;
        };
        EnvelopeFactory2.createPageViewData = function(telemetry) {
          var pageViewData = new Contracts.PageViewData();
          pageViewData.name = telemetry.name;
          pageViewData.duration = Util.msToTimeSpan(telemetry.duration);
          pageViewData.url = telemetry.url;
          pageViewData.measurements = telemetry.measurements;
          pageViewData.properties = telemetry.properties;
          var data = new Contracts.Data();
          data.baseType = Contracts.telemetryTypeToBaseType(Contracts.TelemetryType.PageView);
          data.baseData = pageViewData;
          return data;
        };
        EnvelopeFactory2.getTags = function(context, tagOverrides) {
          var correlationContext = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          var newTags = {};
          if (context && context.tags) {
            for (var key in context.tags) {
              newTags[key] = context.tags[key];
            }
          }
          if (tagOverrides) {
            for (var key in tagOverrides) {
              newTags[key] = tagOverrides[key];
            }
          }
          if (correlationContext) {
            newTags[context.keys.operationId] = newTags[context.keys.operationId] || correlationContext.operation.id;
            newTags[context.keys.operationName] = newTags[context.keys.operationName] || correlationContext.operation.name;
            newTags[context.keys.operationParentId] = newTags[context.keys.operationParentId] || correlationContext.operation.parentId;
          }
          return newTags;
        };
        EnvelopeFactory2.parseStack = function(stack) {
          var parsedStack = void 0;
          if (typeof stack === "string") {
            var frames = stack.split("\n");
            parsedStack = [];
            var level = 0;
            var totalSizeInBytes = 0;
            for (var i = 0; i <= frames.length; i++) {
              var frame = frames[i];
              if (_StackFrame.regex.test(frame)) {
                var parsedFrame = new _StackFrame(frames[i], level++);
                totalSizeInBytes += parsedFrame.sizeInBytes;
                parsedStack.push(parsedFrame);
              }
            }
            var exceptionParsedStackThreshold = 32 * 1024;
            if (totalSizeInBytes > exceptionParsedStackThreshold) {
              var left = 0;
              var right = parsedStack.length - 1;
              var size = 0;
              var acceptedLeft = left;
              var acceptedRight = right;
              while (left < right) {
                var lSize = parsedStack[left].sizeInBytes;
                var rSize = parsedStack[right].sizeInBytes;
                size += lSize + rSize;
                if (size > exceptionParsedStackThreshold) {
                  var howMany = acceptedRight - acceptedLeft + 1;
                  parsedStack.splice(acceptedLeft, howMany);
                  break;
                }
                acceptedLeft = left;
                acceptedRight = right;
                left++;
                right--;
              }
            }
          }
          return parsedStack;
        };
        return EnvelopeFactory2;
      }()
    );
    var _StackFrame = (
      /** @class */
      function() {
        function _StackFrame2(frame, level) {
          this.sizeInBytes = 0;
          this.level = level;
          this.method = "<no_method>";
          this.assembly = Util.trim(frame);
          var matches = frame.match(_StackFrame2.regex);
          if (matches && matches.length >= 5) {
            this.method = Util.trim(matches[2]) || this.method;
            this.fileName = Util.trim(matches[4]) || "<no_filename>";
            this.line = parseInt(matches[5]) || 0;
          }
          this.sizeInBytes += this.method.length;
          this.sizeInBytes += this.fileName.length;
          this.sizeInBytes += this.assembly.length;
          this.sizeInBytes += _StackFrame2.baseSize;
          this.sizeInBytes += this.level.toString().length;
          this.sizeInBytes += this.line.toString().length;
        }
        _StackFrame2.regex = /^(\s+at)?(.*?)(\@|\s\(|\s)([^\(\n]+):(\d+):(\d+)(\)?)$/;
        _StackFrame2.baseSize = 58;
        return _StackFrame2;
      }()
    );
    module2.exports = EnvelopeFactory;
  }
});

// node_modules/applicationinsights/out/Library/FileAccessControl.js
var require_FileAccessControl = __commonJS({
  "node_modules/applicationinsights/out/Library/FileAccessControl.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileAccessControl = void 0;
    var fs = require("fs");
    var os = require("os");
    var child_process = require("child_process");
    var Logging = require_Logging();
    var FileAccessControl = (
      /** @class */
      function() {
        function FileAccessControl2() {
        }
        FileAccessControl2.checkFileProtection = function() {
          if (!FileAccessControl2.OS_PROVIDES_FILE_PROTECTION && !FileAccessControl2.OS_FILE_PROTECTION_CHECKED) {
            FileAccessControl2.OS_FILE_PROTECTION_CHECKED = true;
            if (FileAccessControl2.USE_ICACLS) {
              try {
                FileAccessControl2.OS_PROVIDES_FILE_PROTECTION = fs.existsSync(FileAccessControl2.ICACLS_PATH);
              } catch (e) {
              }
              if (!FileAccessControl2.OS_PROVIDES_FILE_PROTECTION) {
                Logging.warn(FileAccessControl2.TAG, "Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.");
              }
            } else {
              FileAccessControl2.OS_PROVIDES_FILE_PROTECTION = true;
            }
          }
        };
        FileAccessControl2.applyACLRules = function(directory) {
          return __awaiter(this, void 0, void 0, function() {
            var identity, ex_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!FileAccessControl2.USE_ICACLS)
                    return [3, 7];
                  if (!(FileAccessControl2.ACLED_DIRECTORIES[directory] === void 0))
                    return [3, 6];
                  FileAccessControl2.ACLED_DIRECTORIES[directory] = false;
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 4, , 5]);
                  return [4, this._getACLIdentity()];
                case 2:
                  identity = _a.sent();
                  return [4, this._runICACLS(this._getACLArguments(directory, identity))];
                case 3:
                  _a.sent();
                  FileAccessControl2.ACLED_DIRECTORIES[directory] = true;
                  return [3, 5];
                case 4:
                  ex_1 = _a.sent();
                  FileAccessControl2.ACLED_DIRECTORIES[directory] = false;
                  throw ex_1;
                case 5:
                  return [3, 7];
                case 6:
                  if (!FileAccessControl2.ACLED_DIRECTORIES[directory]) {
                    throw new Error("Setting ACL restrictions did not succeed (cached result)");
                  }
                  _a.label = 7;
                case 7:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        FileAccessControl2.applyACLRulesSync = function(directory) {
          if (FileAccessControl2.USE_ICACLS) {
            if (FileAccessControl2.ACLED_DIRECTORIES[directory] === void 0) {
              this._runICACLSSync(this._getACLArguments(directory, this._getACLIdentitySync()));
              FileAccessControl2.ACLED_DIRECTORIES[directory] = true;
              return;
            } else if (!FileAccessControl2.ACLED_DIRECTORIES[directory]) {
              throw new Error("Setting ACL restrictions did not succeed (cached result)");
            }
          }
        };
        FileAccessControl2._runICACLS = function(args) {
          return new Promise(function(resolve, reject) {
            var aclProc = child_process.spawn(FileAccessControl2.ICACLS_PATH, args, { windowsHide: true });
            aclProc.on("error", function(e) {
              return reject(e);
            });
            aclProc.on("close", function(code, signal) {
              if (code === 0) {
                resolve();
              } else {
                reject(new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + code + ")"));
              }
            });
          });
        };
        FileAccessControl2._runICACLSSync = function(args) {
          if (child_process.spawnSync) {
            var aclProc = child_process.spawnSync(FileAccessControl2.ICACLS_PATH, args, { windowsHide: true });
            if (aclProc.error) {
              throw aclProc.error;
            } else if (aclProc.status !== 0) {
              throw new Error("Setting ACL restrictions did not succeed (ICACLS returned code " + aclProc.status + ")");
            }
          } else {
            throw new Error("Could not synchronously call ICACLS under current version of Node.js");
          }
        };
        FileAccessControl2._getACLIdentity = function() {
          return new Promise(function(resolve, reject) {
            if (FileAccessControl2.ACL_IDENTITY) {
              resolve(FileAccessControl2.ACL_IDENTITY);
            }
            var psProc = child_process.spawn(FileAccessControl2.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
              windowsHide: true,
              stdio: ["ignore", "pipe", "pipe"]
              // Needed to prevent hanging on Win 7
            });
            var data = "";
            psProc.stdout.on("data", function(d) {
              return data += d;
            });
            psProc.on("error", function(e) {
              return reject(e);
            });
            psProc.on("close", function(code, signal) {
              FileAccessControl2.ACL_IDENTITY = data && data.trim();
              if (code === 0) {
                resolve(FileAccessControl2.ACL_IDENTITY);
              } else {
                reject(new Error("Getting ACL identity did not succeed (PS returned code " + code + ")"));
              }
            });
          });
        };
        FileAccessControl2._getACLIdentitySync = function() {
          if (FileAccessControl2.ACL_IDENTITY) {
            return FileAccessControl2.ACL_IDENTITY;
          }
          if (child_process.spawnSync) {
            var psProc = child_process.spawnSync(FileAccessControl2.POWERSHELL_PATH, ["-Command", "[System.Security.Principal.WindowsIdentity]::GetCurrent().Name"], {
              windowsHide: true,
              stdio: ["ignore", "pipe", "pipe"]
              // Needed to prevent hanging on Win 7
            });
            if (psProc.error) {
              throw psProc.error;
            } else if (psProc.status !== 0) {
              throw new Error("Getting ACL identity did not succeed (PS returned code " + psProc.status + ")");
            }
            FileAccessControl2.ACL_IDENTITY = psProc.stdout && psProc.stdout.toString().trim();
            return FileAccessControl2.ACL_IDENTITY;
          } else {
            throw new Error("Could not synchronously get ACL identity under current version of Node.js");
          }
        };
        FileAccessControl2._getACLArguments = function(directory, identity) {
          return [
            directory,
            "/grant",
            "*S-1-5-32-544:(OI)(CI)F",
            "/grant",
            identity + ":(OI)(CI)F",
            // Full permission for current user
            "/inheritance:r"
          ];
        };
        FileAccessControl2.TAG = "FileAccessControl";
        FileAccessControl2.ICACLS_PATH = process.env.systemdrive + "/windows/system32/icacls.exe";
        FileAccessControl2.POWERSHELL_PATH = process.env.systemdrive + "/windows/system32/windowspowershell/v1.0/powershell.exe";
        FileAccessControl2.ACLED_DIRECTORIES = {};
        FileAccessControl2.ACL_IDENTITY = null;
        FileAccessControl2.OS_FILE_PROTECTION_CHECKED = false;
        FileAccessControl2.OS_PROVIDES_FILE_PROTECTION = false;
        FileAccessControl2.USE_ICACLS = os.type() === "Windows_NT";
        return FileAccessControl2;
      }()
    );
    exports2.FileAccessControl = FileAccessControl;
  }
});

// node_modules/applicationinsights/out/Library/Sender.js
var require_Sender = __commonJS({
  "node_modules/applicationinsights/out/Library/Sender.js"(exports2, module2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var fs = require("fs");
    var os = require("os");
    var path2 = require("path");
    var zlib = require("zlib");
    var Constants = require_Constants2();
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var FileSystemHelper = require_FileSystemHelper();
    var Util = require_Util();
    var url_12 = require("url");
    var Logging = require_Logging();
    var FileAccessControl_1 = require_FileAccessControl();
    var legacyThrottleStatusCode = 439;
    var throttleStatusCode = 402;
    var RESPONSE_CODES_INDICATING_REACHED_BREEZE = [200, 206, 402, 408, 429, 439, 500];
    var Sender = (
      /** @class */
      function() {
        function Sender2(config, getAuthorizationHandler, onSuccess, onError, statsbeat, isStatsbeatSender, shutdownStatsbeat) {
          this._redirectedHost = null;
          this._config = config;
          this._onSuccess = onSuccess;
          this._onError = onError;
          this._statsbeat = statsbeat;
          this._enableDiskRetryMode = false;
          this._resendInterval = Sender2.WAIT_BETWEEN_RESEND;
          this._maxBytesOnDisk = Sender2.MAX_BYTES_ON_DISK;
          this._numConsecutiveFailures = 0;
          this._numConsecutiveRedirects = 0;
          this._resendTimer = null;
          this._getAuthorizationHandler = getAuthorizationHandler;
          this._fileCleanupTimer = null;
          this._tempDir = path2.join(os.tmpdir(), Sender2.TEMPDIR_PREFIX + this._config.instrumentationKey);
          this._isStatsbeatSender = isStatsbeatSender || false;
          this._shutdownStatsbeat = shutdownStatsbeat;
          this._failedToIngestCounter = 0;
          this._statsbeatHasReachedIngestionAtLeastOnce = false;
        }
        Sender2.prototype.setDiskRetryMode = function(value, resendInterval, maxBytesOnDisk) {
          var _this = this;
          if (value) {
            FileAccessControl_1.FileAccessControl.checkFileProtection();
          }
          this._enableDiskRetryMode = FileAccessControl_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION && value;
          if (typeof resendInterval === "number" && resendInterval >= 0) {
            this._resendInterval = Math.floor(resendInterval);
          }
          if (typeof maxBytesOnDisk === "number" && maxBytesOnDisk >= 0) {
            this._maxBytesOnDisk = Math.floor(maxBytesOnDisk);
          }
          if (value && !FileAccessControl_1.FileAccessControl.OS_PROVIDES_FILE_PROTECTION) {
            this._enableDiskRetryMode = false;
            this._logWarn("Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.");
          }
          if (this._enableDiskRetryMode) {
            if (this._statsbeat) {
              this._statsbeat.addFeature(Constants.StatsbeatFeature.DISK_RETRY);
            }
            if (!this._fileCleanupTimer) {
              this._fileCleanupTimer = setTimeout(function() {
                _this._fileCleanupTask();
              }, Sender2.CLEANUP_TIMEOUT);
              this._fileCleanupTimer.unref();
            }
          } else {
            if (this._statsbeat) {
              this._statsbeat.removeFeature(Constants.StatsbeatFeature.DISK_RETRY);
            }
            if (this._fileCleanupTimer) {
              clearTimeout(this._fileCleanupTimer);
            }
          }
        };
        Sender2.prototype.send = function(envelopes, callback) {
          return __awaiter(this, void 0, void 0, function() {
            var endpointUrl, endpointHost, options, authHandler, authError_1, errorMsg, batch_1, payload_1;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!envelopes)
                    return [3, 5];
                  endpointUrl = this._redirectedHost || this._config.endpointUrl;
                  endpointHost = new url_12.URL(endpointUrl).hostname;
                  options = {
                    method: "POST",
                    withCredentials: false,
                    headers: {
                      "Content-Type": "application/x-json-stream"
                    }
                  };
                  authHandler = this._getAuthorizationHandler ? this._getAuthorizationHandler(this._config) : null;
                  if (!authHandler)
                    return [3, 4];
                  if (this._statsbeat) {
                    this._statsbeat.addFeature(Constants.StatsbeatFeature.AAD_HANDLING);
                  }
                  _a.label = 1;
                case 1:
                  _a.trys.push([1, 3, , 4]);
                  return [4, authHandler.addAuthorizationHeader(options)];
                case 2:
                  _a.sent();
                  return [3, 4];
                case 3:
                  authError_1 = _a.sent();
                  errorMsg = "Failed to get AAD bearer token for the Application.";
                  if (this._enableDiskRetryMode) {
                    errorMsg += "This batch of telemetry items will be retried. ";
                    this._storeToDisk(envelopes);
                  }
                  errorMsg += "Error:" + authError_1.toString();
                  this._logWarn(errorMsg);
                  if (typeof callback === "function") {
                    callback(errorMsg);
                  }
                  return [
                    2
                    /*return*/
                  ];
                case 4:
                  batch_1 = "";
                  envelopes.forEach(function(envelope) {
                    var payload = Util.stringify(envelope);
                    if (typeof payload !== "string") {
                      return;
                    }
                    batch_1 += payload + "\n";
                  });
                  if (batch_1.length > 0) {
                    batch_1 = batch_1.substring(0, batch_1.length - 1);
                  }
                  payload_1 = Buffer.from ? Buffer.from(batch_1) : new Buffer(batch_1);
                  zlib.gzip(payload_1, function(err, buffer) {
                    var dataToSend = buffer;
                    if (err) {
                      _this._logWarn(Util.dumpObj(err));
                      dataToSend = payload_1;
                      options.headers["Content-Length"] = payload_1.length.toString();
                    } else {
                      options.headers["Content-Encoding"] = "gzip";
                      options.headers["Content-Length"] = buffer.length.toString();
                    }
                    _this._logInfo(Util.dumpObj(options));
                    options[AutoCollectHttpDependencies.disableCollectionRequestOption] = true;
                    var startTime = +/* @__PURE__ */ new Date();
                    var requestCallback = function(res) {
                      res.setEncoding("utf-8");
                      var responseString = "";
                      res.on("data", function(data) {
                        responseString += data;
                      });
                      res.on("end", function() {
                        var endTime = +/* @__PURE__ */ new Date();
                        var duration = endTime - startTime;
                        _this._numConsecutiveFailures = 0;
                        if (_this._isStatsbeatSender && !_this._statsbeatHasReachedIngestionAtLeastOnce) {
                          if (RESPONSE_CODES_INDICATING_REACHED_BREEZE.includes(res.statusCode)) {
                            _this._statsbeatHasReachedIngestionAtLeastOnce = true;
                          } else {
                            _this._statsbeatFailedToIngest();
                          }
                        }
                        if (_this._statsbeat) {
                          if (res.statusCode == throttleStatusCode || res.statusCode == legacyThrottleStatusCode) {
                            _this._statsbeat.countThrottle(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);
                          } else {
                            _this._statsbeat.countRequest(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, duration, res.statusCode === 200, res.statusCode);
                          }
                        }
                        if (_this._enableDiskRetryMode) {
                          if (res.statusCode === 200) {
                            if (!_this._resendTimer) {
                              _this._resendTimer = setTimeout(function() {
                                _this._resendTimer = null;
                                _this._sendFirstFileOnDisk();
                              }, _this._resendInterval);
                              _this._resendTimer.unref();
                            }
                          } else if (_this._isRetriable(res.statusCode)) {
                            try {
                              if (_this._statsbeat) {
                                _this._statsbeat.countRetry(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, res.statusCode);
                              }
                              var breezeResponse = JSON.parse(responseString);
                              var filteredEnvelopes_1 = [];
                              if (breezeResponse.errors) {
                                breezeResponse.errors.forEach(function(error) {
                                  if (error.statusCode == 429 || error.statusCode == 500 || error.statusCode == 503) {
                                    filteredEnvelopes_1.push(envelopes[error.index]);
                                  }
                                });
                                if (filteredEnvelopes_1.length > 0) {
                                  _this._storeToDisk(filteredEnvelopes_1);
                                }
                              }
                            } catch (ex) {
                              _this._storeToDisk(envelopes);
                            }
                          }
                        }
                        if (res.statusCode === 307 || // Temporary Redirect
                        res.statusCode === 308) {
                          _this._numConsecutiveRedirects++;
                          if (_this._numConsecutiveRedirects < 10) {
                            var locationHeader = res.headers["location"] ? res.headers["location"].toString() : null;
                            if (locationHeader) {
                              _this._redirectedHost = locationHeader;
                              _this.send(envelopes, callback);
                            }
                          } else {
                            var circularRedirectError = { name: "Circular Redirect", message: "Error sending telemetry because of circular redirects." };
                            if (_this._statsbeat) {
                              _this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, circularRedirectError);
                            }
                            if (typeof callback === "function") {
                              callback("Error sending telemetry because of circular redirects.");
                            }
                          }
                        } else {
                          _this._numConsecutiveRedirects = 0;
                          if (typeof callback === "function") {
                            callback(responseString);
                          }
                          _this._logInfo(responseString);
                          if (typeof _this._onSuccess === "function") {
                            _this._onSuccess(responseString);
                          }
                        }
                      });
                    };
                    var req = Util.makeRequest(_this._config, endpointUrl, options, requestCallback);
                    req.setTimeout(Sender2.HTTP_TIMEOUT, function() {
                      _this._requestTimedOut = true;
                      req.abort();
                    });
                    req.on("error", function(error) {
                      if (_this._isStatsbeatSender && !_this._statsbeatHasReachedIngestionAtLeastOnce) {
                        _this._statsbeatFailedToIngest();
                      }
                      _this._numConsecutiveFailures++;
                      if (_this._statsbeat) {
                        _this._statsbeat.countException(Constants.StatsbeatNetworkCategory.Breeze, endpointHost, error);
                      }
                      if (!_this._enableDiskRetryMode || _this._numConsecutiveFailures > 0 && _this._numConsecutiveFailures % Sender2.MAX_CONNECTION_FAILURES_BEFORE_WARN === 0) {
                        var notice = "Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:";
                        if (_this._enableDiskRetryMode) {
                          notice = "Ingestion endpoint could not be reached " + _this._numConsecutiveFailures + " consecutive times. There may be resulting telemetry loss. Most recent error:";
                        }
                        _this._logWarn(notice, Util.dumpObj(error));
                      } else {
                        var notice = "Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:";
                        _this._logInfo(notice, Util.dumpObj(error));
                      }
                      _this._onErrorHelper(error);
                      if (typeof callback === "function") {
                        if (error) {
                          if (_this._requestTimedOut) {
                            error.name = "telemetry timeout";
                            error.message = "telemetry request timed out";
                          }
                          callback(Util.dumpObj(error));
                        } else {
                          callback("Error sending telemetry");
                        }
                      }
                      if (_this._enableDiskRetryMode) {
                        _this._storeToDisk(envelopes);
                      }
                    });
                    req.write(dataToSend);
                    req.end();
                  });
                  _a.label = 5;
                case 5:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Sender2.prototype.saveOnCrash = function(envelopes) {
          if (this._enableDiskRetryMode) {
            this._storeToDiskSync(Util.stringify(envelopes));
          }
        };
        Sender2.prototype._isRetriable = function(statusCode) {
          return statusCode === 206 || // Partial Accept
          statusCode === 401 || // Unauthorized
          statusCode === 403 || // Forbidden
          statusCode === 408 || // Timeout
          statusCode === 429 || // Too many requests
          statusCode === 500 || // Server Error
          statusCode === 502 || // Bad Gateway
          statusCode === 503 || // Server Unavailable
          statusCode === 504;
        };
        Sender2.prototype._logInfo = function(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          if (!this._isStatsbeatSender) {
            Logging.info(Sender2.TAG, message, optionalParams);
          }
        };
        Sender2.prototype._logWarn = function(message) {
          var optionalParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            optionalParams[_i - 1] = arguments[_i];
          }
          if (!this._isStatsbeatSender) {
            Logging.warn(Sender2.TAG, message, optionalParams);
          }
        };
        Sender2.prototype._statsbeatFailedToIngest = function() {
          if (this._shutdownStatsbeat) {
            this._failedToIngestCounter++;
            if (this._failedToIngestCounter >= 3) {
              this._shutdownStatsbeat();
            }
          }
        };
        Sender2.prototype._storeToDisk = function(envelopes) {
          return __awaiter(this, void 0, void 0, function() {
            var ex_1, ex_2, size, ex_3, fileName, fileFullPath, ex_4;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 2, , 3]);
                  this._logInfo("Checking existence of data storage directory: " + this._tempDir);
                  return [4, FileSystemHelper.confirmDirExists(this._tempDir)];
                case 1:
                  _a.sent();
                  return [3, 3];
                case 2:
                  ex_1 = _a.sent();
                  this._logWarn("Failed to create folder to put telemetry: " + Util.dumpObj(ex_1));
                  this._onErrorHelper(ex_1);
                  return [
                    2
                    /*return*/
                  ];
                case 3:
                  _a.trys.push([3, 5, , 6]);
                  return [4, FileAccessControl_1.FileAccessControl.applyACLRules(this._tempDir)];
                case 4:
                  _a.sent();
                  return [3, 6];
                case 5:
                  ex_2 = _a.sent();
                  this._logWarn("Failed to apply file access control to folder: " + Util.dumpObj(ex_2));
                  this._onErrorHelper(ex_2);
                  return [
                    2
                    /*return*/
                  ];
                case 6:
                  _a.trys.push([6, 8, , 9]);
                  return [4, FileSystemHelper.getShallowDirectorySize(this._tempDir)];
                case 7:
                  size = _a.sent();
                  if (size > this._maxBytesOnDisk) {
                    this._logWarn("Not saving data due to max size limit being met. Directory size in bytes is: " + size);
                    return [
                      2
                      /*return*/
                    ];
                  }
                  return [3, 9];
                case 8:
                  ex_3 = _a.sent();
                  this._logWarn("Failed to read directory for retriable telemetry: " + Util.dumpObj(ex_3));
                  this._onErrorHelper(ex_3);
                  return [
                    2
                    /*return*/
                  ];
                case 9:
                  _a.trys.push([9, 11, , 12]);
                  fileName = (/* @__PURE__ */ new Date()).getTime() + ".ai.json";
                  fileFullPath = path2.join(this._tempDir, fileName);
                  this._logInfo("saving data to disk at: " + fileFullPath);
                  return [4, FileSystemHelper.writeFileAsync(fileFullPath, Util.stringify(envelopes), { mode: 384 })];
                case 10:
                  _a.sent();
                  return [3, 12];
                case 11:
                  ex_4 = _a.sent();
                  this._logWarn("Failed to persist telemetry to disk: " + Util.dumpObj(ex_4));
                  this._onErrorHelper(ex_4);
                  return [
                    2
                    /*return*/
                  ];
                case 12:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Sender2.prototype._storeToDiskSync = function(payload) {
          try {
            this._logInfo("Checking existence of data storage directory: " + this._tempDir);
            if (!fs.existsSync(this._tempDir)) {
              fs.mkdirSync(this._tempDir);
            }
            FileAccessControl_1.FileAccessControl.applyACLRulesSync(this._tempDir);
            var dirSize = FileSystemHelper.getShallowDirectorySizeSync(this._tempDir);
            if (dirSize > this._maxBytesOnDisk) {
              this._logInfo("Not saving data due to max size limit being met. Directory size in bytes is: " + dirSize);
              return;
            }
            var fileName = (/* @__PURE__ */ new Date()).getTime() + ".ai.json";
            var fileFullPath = path2.join(this._tempDir, fileName);
            this._logInfo("saving data before crash to disk at: " + fileFullPath);
            fs.writeFileSync(fileFullPath, payload, { mode: 384 });
          } catch (error) {
            this._logWarn("Error while saving data to disk: " + Util.dumpObj(error));
            this._onErrorHelper(error);
          }
        };
        Sender2.prototype._sendFirstFileOnDisk = function() {
          return __awaiter(this, void 0, void 0, function() {
            var files, firstFile, filePath, buffer, envelopes, err_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 6, , 7]);
                  return [4, FileSystemHelper.readdirAsync(this._tempDir)];
                case 1:
                  files = _a.sent();
                  files = files.filter(function(f) {
                    return path2.basename(f).indexOf(".ai.json") > -1;
                  });
                  if (!(files.length > 0))
                    return [3, 5];
                  firstFile = files[0];
                  filePath = path2.join(this._tempDir, firstFile);
                  return [4, FileSystemHelper.readFileAsync(filePath)];
                case 2:
                  buffer = _a.sent();
                  return [4, FileSystemHelper.unlinkAsync(filePath)];
                case 3:
                  _a.sent();
                  envelopes = JSON.parse(buffer.toString());
                  return [4, this.send(envelopes)];
                case 4:
                  _a.sent();
                  _a.label = 5;
                case 5:
                  return [3, 7];
                case 6:
                  err_1 = _a.sent();
                  this._onErrorHelper(err_1);
                  return [3, 7];
                case 7:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Sender2.prototype._onErrorHelper = function(error) {
          if (typeof this._onError === "function") {
            this._onError(error);
          }
        };
        Sender2.prototype._fileCleanupTask = function() {
          return __awaiter(this, void 0, void 0, function() {
            var files, i, fileCreationDate, expired, filePath, err_2;
            var _this = this;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 6, , 7]);
                  return [4, FileSystemHelper.readdirAsync(this._tempDir)];
                case 1:
                  files = _a.sent();
                  files = files.filter(function(f) {
                    return path2.basename(f).indexOf(".ai.json") > -1;
                  });
                  if (!(files.length > 0))
                    return [3, 5];
                  i = 0;
                  _a.label = 2;
                case 2:
                  if (!(i < files.length))
                    return [3, 5];
                  fileCreationDate = new Date(parseInt(files[i].split(".ai.json")[0]));
                  expired = new Date(+/* @__PURE__ */ new Date() - Sender2.FILE_RETEMPTION_PERIOD) > fileCreationDate;
                  if (!expired)
                    return [3, 4];
                  filePath = path2.join(this._tempDir, files[i]);
                  return [4, FileSystemHelper.unlinkAsync(filePath).catch(function(err) {
                    _this._onErrorHelper(err);
                  })];
                case 3:
                  _a.sent();
                  _a.label = 4;
                case 4:
                  i++;
                  return [3, 2];
                case 5:
                  return [3, 7];
                case 6:
                  err_2 = _a.sent();
                  if (err_2.code != "ENOENT") {
                    this._onErrorHelper(err_2);
                  }
                  return [3, 7];
                case 7:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Sender2.TAG = "Sender";
        Sender2.WAIT_BETWEEN_RESEND = 60 * 1e3;
        Sender2.MAX_BYTES_ON_DISK = 50 * 1024 * 1024;
        Sender2.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;
        Sender2.CLEANUP_TIMEOUT = 60 * 60 * 1e3;
        Sender2.FILE_RETEMPTION_PERIOD = 7 * 24 * 60 * 60 * 1e3;
        Sender2.TEMPDIR_PREFIX = "appInsights-node";
        Sender2.HTTP_TIMEOUT = 2e4;
        return Sender2;
      }()
    );
    module2.exports = Sender;
  }
});

// node_modules/applicationinsights/out/AutoCollection/NetworkStatsbeat.js
var require_NetworkStatsbeat = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/NetworkStatsbeat.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NetworkStatsbeat = void 0;
    var NetworkStatsbeat = (
      /** @class */
      function() {
        function NetworkStatsbeat2(endpoint, host) {
          this.endpoint = endpoint;
          this.host = host;
          this.totalRequestCount = 0;
          this.totalSuccesfulRequestCount = 0;
          this.totalFailedRequestCount = [];
          this.retryCount = [];
          this.exceptionCount = [];
          this.throttleCount = [];
          this.intervalRequestExecutionTime = 0;
          this.lastIntervalRequestExecutionTime = 0;
          this.lastTime = +/* @__PURE__ */ new Date();
          this.lastRequestCount = 0;
        }
        return NetworkStatsbeat2;
      }()
    );
    exports2.NetworkStatsbeat = NetworkStatsbeat;
  }
});

// node_modules/applicationinsights/out/AutoCollection/Statsbeat.js
var require_Statsbeat = __commonJS({
  "node_modules/applicationinsights/out/AutoCollection/Statsbeat.js"(exports2, module2) {
    "use strict";
    var __assign2 = exports2 && exports2.__assign || function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var os = require("os");
    var EnvelopeFactory = require_EnvelopeFactory();
    var Logging = require_Logging();
    var Sender = require_Sender();
    var Constants = require_Constants2();
    var Contracts = require_Contracts();
    var Vm = require_AzureVirtualMachine();
    var Config = require_Config();
    var Context = require_Context();
    var Network = require_NetworkStatsbeat();
    var Util = require_Util();
    var STATSBEAT_LANGUAGE = "node";
    var Statsbeat = (
      /** @class */
      function() {
        function Statsbeat2(config, context) {
          this._attach = Constants.StatsbeatAttach.sdk;
          this._feature = Constants.StatsbeatFeature.NONE;
          this._instrumentation = Constants.StatsbeatInstrumentation.NONE;
          this._isInitialized = false;
          this._statbeatMetrics = [];
          this._networkStatsbeatCollection = [];
          this._config = config;
          this._context = context || new Context();
          var statsbeatConnectionString = this._getConnectionString(config);
          this._statsbeatConfig = new Config(statsbeatConnectionString);
          this._statsbeatConfig.samplingPercentage = 100;
          this._sender = new Sender(this._statsbeatConfig, null, null, null, null, true, this._shutdownStatsbeat.bind(this));
        }
        Statsbeat2.prototype.enable = function(isEnabled) {
          var _this = this;
          this._isEnabled = isEnabled;
          if (this._isEnabled && !this._isInitialized) {
            this._getCustomProperties();
            this._isInitialized = true;
          }
          if (isEnabled) {
            if (!this._handle) {
              this._handle = setInterval(function() {
                _this.trackShortIntervalStatsbeats();
              }, Statsbeat2.STATS_COLLECTION_SHORT_INTERVAL);
              this._handle.unref();
            }
            if (!this._longHandle) {
              this.trackLongIntervalStatsbeats();
              this._longHandle = setInterval(function() {
                _this.trackLongIntervalStatsbeats();
              }, Statsbeat2.STATS_COLLECTION_LONG_INTERVAL);
              this._longHandle.unref();
            }
          } else {
            if (this._handle) {
              clearInterval(this._handle);
              this._handle = null;
            }
            if (this._longHandle) {
              clearInterval(this._longHandle);
              this._longHandle = null;
            }
          }
        };
        Statsbeat2.prototype.isInitialized = function() {
          return this._isInitialized;
        };
        Statsbeat2.prototype.isEnabled = function() {
          return this._isEnabled;
        };
        Statsbeat2.prototype.setCodelessAttach = function() {
          this._attach = Constants.StatsbeatAttach.codeless;
        };
        Statsbeat2.prototype.addFeature = function(feature) {
          this._feature |= feature;
        };
        Statsbeat2.prototype.removeFeature = function(feature) {
          this._feature &= ~feature;
        };
        Statsbeat2.prototype.addInstrumentation = function(instrumentation) {
          this._instrumentation |= instrumentation;
        };
        Statsbeat2.prototype.removeInstrumentation = function(instrumentation) {
          this._instrumentation &= ~instrumentation;
        };
        Statsbeat2.prototype.countRequest = function(endpoint, host, duration, success, statusCode) {
          if (!this.isEnabled()) {
            return;
          }
          var counter = this._getNetworkStatsbeatCounter(endpoint, host);
          counter.totalRequestCount++;
          counter.intervalRequestExecutionTime += duration;
          if (success === false) {
            if (!statusCode) {
              return;
            }
            var currentStatusCounter = counter.totalFailedRequestCount.find(function(statusCounter) {
              return statusCode === statusCounter.statusCode;
            });
            if (currentStatusCounter) {
              currentStatusCounter.count++;
            } else {
              counter.totalFailedRequestCount.push({ statusCode, count: 1 });
            }
          } else {
            counter.totalSuccesfulRequestCount++;
          }
        };
        Statsbeat2.prototype.countException = function(endpoint, host, exceptionType) {
          if (!this.isEnabled()) {
            return;
          }
          var counter = this._getNetworkStatsbeatCounter(endpoint, host);
          var currentErrorCounter = counter.exceptionCount.find(function(exceptionCounter) {
            return exceptionType.name === exceptionCounter.exceptionType;
          });
          if (currentErrorCounter) {
            currentErrorCounter.count++;
          } else {
            counter.exceptionCount.push({ exceptionType: exceptionType.name, count: 1 });
          }
        };
        Statsbeat2.prototype.countThrottle = function(endpoint, host, statusCode) {
          if (!this.isEnabled()) {
            return;
          }
          var counter = this._getNetworkStatsbeatCounter(endpoint, host);
          var currentStatusCounter = counter.throttleCount.find(function(statusCounter) {
            return statusCode === statusCounter.statusCode;
          });
          if (currentStatusCounter) {
            currentStatusCounter.count++;
          } else {
            counter.throttleCount.push({ statusCode, count: 1 });
          }
        };
        Statsbeat2.prototype.countRetry = function(endpoint, host, statusCode) {
          if (!this.isEnabled()) {
            return;
          }
          var counter = this._getNetworkStatsbeatCounter(endpoint, host);
          var currentStatusCounter = counter.retryCount.find(function(statusCounter) {
            return statusCode === statusCounter.statusCode;
          });
          if (currentStatusCounter) {
            currentStatusCounter.count++;
          } else {
            counter.retryCount.push({ statusCode, count: 1 });
          }
        };
        Statsbeat2.prototype.trackShortIntervalStatsbeats = function() {
          return __awaiter(this, void 0, void 0, function() {
            var networkProperties, error_1;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 3, , 4]);
                  return [4, this._getResourceProvider()];
                case 1:
                  _a.sent();
                  networkProperties = {
                    "os": this._os,
                    "rp": this._resourceProvider,
                    "cikey": this._cikey,
                    "runtimeVersion": this._runtimeVersion,
                    "language": this._language,
                    "version": this._sdkVersion,
                    "attach": this._attach
                  };
                  this._trackRequestDuration(networkProperties);
                  this._trackRequestsCount(networkProperties);
                  return [4, this._sendStatsbeats()];
                case 2:
                  _a.sent();
                  return [3, 4];
                case 3:
                  error_1 = _a.sent();
                  Logging.info(Statsbeat2.TAG, "Failed to send Statsbeat metrics: " + Util.dumpObj(error_1));
                  return [3, 4];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Statsbeat2.prototype.trackLongIntervalStatsbeats = function() {
          return __awaiter(this, void 0, void 0, function() {
            var commonProperties, attachProperties, instrumentationProperties, featureProperties, error_2;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  _a.trys.push([0, 3, , 4]);
                  return [4, this._getResourceProvider()];
                case 1:
                  _a.sent();
                  commonProperties = {
                    "os": this._os,
                    "rp": this._resourceProvider,
                    "cikey": this._cikey,
                    "runtimeVersion": this._runtimeVersion,
                    "language": this._language,
                    "version": this._sdkVersion,
                    "attach": this._attach
                  };
                  attachProperties = Object.assign({
                    "rpId": this._resourceIdentifier
                  }, commonProperties);
                  this._statbeatMetrics.push({ name: Constants.StatsbeatCounter.ATTACH, value: 1, properties: attachProperties });
                  if (this._instrumentation != Constants.StatsbeatInstrumentation.NONE) {
                    instrumentationProperties = Object.assign({ "feature": this._instrumentation, "type": Constants.StatsbeatFeatureType.Instrumentation }, commonProperties);
                    this._statbeatMetrics.push({ name: Constants.StatsbeatCounter.FEATURE, value: 1, properties: instrumentationProperties });
                  }
                  if (this._feature != Constants.StatsbeatFeature.NONE) {
                    featureProperties = Object.assign({ "feature": this._feature, "type": Constants.StatsbeatFeatureType.Feature }, commonProperties);
                    this._statbeatMetrics.push({ name: Constants.StatsbeatCounter.FEATURE, value: 1, properties: featureProperties });
                  }
                  return [4, this._sendStatsbeats()];
                case 2:
                  _a.sent();
                  return [3, 4];
                case 3:
                  error_2 = _a.sent();
                  Logging.info(Statsbeat2.TAG, "Failed to send Statsbeat metrics: " + Util.dumpObj(error_2));
                  return [3, 4];
                case 4:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Statsbeat2.prototype._getNetworkStatsbeatCounter = function(endpoint, host) {
          var shortHost = this._getShortHost(host);
          for (var i = 0; i < this._networkStatsbeatCollection.length; i++) {
            if (endpoint === this._networkStatsbeatCollection[i].endpoint && shortHost === this._networkStatsbeatCollection[i].host) {
              return this._networkStatsbeatCollection[i];
            }
          }
          var newCounter = new Network.NetworkStatsbeat(endpoint, shortHost);
          this._networkStatsbeatCollection.push(newCounter);
          return newCounter;
        };
        Statsbeat2.prototype._trackRequestDuration = function(commonProperties) {
          for (var i = 0; i < this._networkStatsbeatCollection.length; i++) {
            var currentCounter = this._networkStatsbeatCollection[i];
            currentCounter.time = +/* @__PURE__ */ new Date();
            var intervalRequests = currentCounter.totalRequestCount - currentCounter.lastRequestCount || 0;
            var totalRequestExecutionTime = currentCounter.intervalRequestExecutionTime - currentCounter.lastIntervalRequestExecutionTime;
            var averageRequestExecutionTime = totalRequestExecutionTime > 0 ? totalRequestExecutionTime / intervalRequests || 0 : 0;
            currentCounter.lastIntervalRequestExecutionTime = currentCounter.intervalRequestExecutionTime;
            if (intervalRequests > 0) {
              var properties = Object.assign({
                "endpoint": this._networkStatsbeatCollection[i].endpoint,
                "host": this._networkStatsbeatCollection[i].host
              }, commonProperties);
              this._statbeatMetrics.push({
                name: Constants.StatsbeatCounter.REQUEST_DURATION,
                value: averageRequestExecutionTime,
                properties
              });
            }
            currentCounter.lastRequestCount = currentCounter.totalRequestCount;
            currentCounter.lastTime = currentCounter.time;
          }
        };
        Statsbeat2.prototype._getShortHost = function(originalHost) {
          var shortHost = originalHost;
          try {
            var hostRegex = new RegExp(/^https?:\/\/(?:www\.)?([^\/.-]+)/);
            var res = hostRegex.exec(originalHost);
            if (res != null && res.length > 1) {
              shortHost = res[1];
            }
            shortHost = shortHost.replace(".in.applicationinsights.azure.com", "");
          } catch (error) {
          }
          return shortHost;
        };
        Statsbeat2.prototype._trackRequestsCount = function(commonProperties) {
          var _this = this;
          var _loop_1 = function(i2) {
            currentCounter = this_1._networkStatsbeatCollection[i2];
            var properties = Object.assign({ "endpoint": currentCounter.endpoint, "host": currentCounter.host }, commonProperties);
            if (currentCounter.totalSuccesfulRequestCount > 0) {
              this_1._statbeatMetrics.push({
                name: Constants.StatsbeatCounter.REQUEST_SUCCESS,
                value: currentCounter.totalSuccesfulRequestCount,
                properties
              });
              currentCounter.totalSuccesfulRequestCount = 0;
            }
            if (currentCounter.totalFailedRequestCount.length > 0) {
              currentCounter.totalFailedRequestCount.forEach(function(currentCounter2) {
                properties = Object.assign(__assign2(__assign2({}, properties), { "statusCode": currentCounter2.statusCode }));
                _this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.REQUEST_FAILURE,
                  value: currentCounter2.count,
                  properties
                });
              });
              currentCounter.totalFailedRequestCount = [];
            }
            if (currentCounter.retryCount.length > 0) {
              currentCounter.retryCount.forEach(function(currentCounter2) {
                properties = Object.assign(__assign2(__assign2({}, properties), { "statusCode": currentCounter2.statusCode }));
                _this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.RETRY_COUNT,
                  value: currentCounter2.count,
                  properties
                });
              });
              currentCounter.retryCount = [];
            }
            if (currentCounter.throttleCount.length > 0) {
              currentCounter.throttleCount.forEach(function(currentCounter2) {
                properties = Object.assign(__assign2(__assign2({}, properties), { "statusCode": currentCounter2.statusCode }));
                _this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.THROTTLE_COUNT,
                  value: currentCounter2.count,
                  properties
                });
              });
              currentCounter.throttleCount = [];
            }
            if (currentCounter.exceptionCount.length > 0) {
              currentCounter.exceptionCount.forEach(function(currentCounter2) {
                properties = Object.assign(__assign2(__assign2({}, properties), { "exceptionType": currentCounter2.exceptionType }));
                _this._statbeatMetrics.push({
                  name: Constants.StatsbeatCounter.EXCEPTION_COUNT,
                  value: currentCounter2.count,
                  properties
                });
              });
              currentCounter.exceptionCount = [];
            }
          };
          var this_1 = this, currentCounter;
          for (var i = 0; i < this._networkStatsbeatCollection.length; i++) {
            _loop_1(i);
          }
        };
        Statsbeat2.prototype._sendStatsbeats = function() {
          return __awaiter(this, void 0, void 0, function() {
            var envelopes, i, statsbeat, envelope;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  envelopes = [];
                  for (i = 0; i < this._statbeatMetrics.length; i++) {
                    statsbeat = {
                      name: this._statbeatMetrics[i].name,
                      value: this._statbeatMetrics[i].value,
                      properties: this._statbeatMetrics[i].properties
                    };
                    envelope = EnvelopeFactory.createEnvelope(statsbeat, Contracts.TelemetryType.Metric, null, this._context, this._statsbeatConfig);
                    envelope.name = Constants.StatsbeatTelemetryName;
                    envelopes.push(envelope);
                  }
                  this._statbeatMetrics = [];
                  return [4, this._sender.send(envelopes)];
                case 1:
                  _a.sent();
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Statsbeat2.prototype._getCustomProperties = function() {
          this._language = STATSBEAT_LANGUAGE;
          this._cikey = this._config.instrumentationKey;
          this._sdkVersion = Context.sdkVersion;
          this._os = os.type();
          this._runtimeVersion = process.version;
        };
        Statsbeat2.prototype._getResourceProvider = function() {
          var _this = this;
          return new Promise(function(resolve, reject) {
            var waiting = false;
            _this._resourceProvider = Constants.StatsbeatResourceProvider.unknown;
            _this._resourceIdentifier = Constants.StatsbeatResourceProvider.unknown;
            if (process.env.WEBSITE_SITE_NAME) {
              _this._resourceProvider = Constants.StatsbeatResourceProvider.appsvc;
              _this._resourceIdentifier = process.env.WEBSITE_SITE_NAME;
              if (process.env.WEBSITE_HOME_STAMPNAME) {
                _this._resourceIdentifier += "/" + process.env.WEBSITE_HOME_STAMPNAME;
              }
            } else if (process.env.FUNCTIONS_WORKER_RUNTIME) {
              _this._resourceProvider = Constants.StatsbeatResourceProvider.functions;
              if (process.env.WEBSITE_HOSTNAME) {
                _this._resourceIdentifier = process.env.WEBSITE_HOSTNAME;
              }
            } else if (_this._config) {
              if (_this._isVM === void 0 || _this._isVM == true) {
                waiting = true;
                Vm.AzureVirtualMachine.getAzureComputeMetadata(_this._config, function(vmInfo) {
                  _this._isVM = vmInfo.isVM;
                  if (_this._isVM) {
                    _this._resourceProvider = Constants.StatsbeatResourceProvider.vm;
                    _this._resourceIdentifier = vmInfo.id + "/" + vmInfo.subscriptionId;
                    if (vmInfo.osType) {
                      _this._os = vmInfo.osType;
                    }
                  }
                  resolve();
                });
              } else {
                _this._resourceProvider = Constants.StatsbeatResourceProvider.unknown;
              }
            }
            if (!waiting) {
              resolve();
            }
          });
        };
        Statsbeat2.prototype._shutdownStatsbeat = function() {
          this.enable(false);
        };
        Statsbeat2.prototype._getConnectionString = function(config) {
          var currentEndpoint = config.endpointUrl;
          var euEndpoints = [
            "westeurope",
            "northeurope",
            "francecentral",
            "francesouth",
            "germanywestcentral",
            "norwayeast",
            "norwaywest",
            "swedencentral",
            "switzerlandnorth",
            "switzerlandwest",
            "uksouth",
            "ukwest"
          ];
          for (var i = 0; i < euEndpoints.length; i++) {
            if (currentEndpoint.indexOf(euEndpoints[i]) > -1) {
              return Statsbeat2.EU_CONNECTION_STRING;
            }
          }
          return Statsbeat2.NON_EU_CONNECTION_STRING;
        };
        Statsbeat2.NON_EU_CONNECTION_STRING = "InstrumentationKey=c4a29126-a7cb-47e5-b348-11414998b11e;IngestionEndpoint=https://westus-0.in.applicationinsights.azure.com";
        Statsbeat2.EU_CONNECTION_STRING = "InstrumentationKey=7dc56bab-3c0c-4e9f-9ebb-d1acadee8d0f;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com";
        Statsbeat2.STATS_COLLECTION_SHORT_INTERVAL = 9e5;
        Statsbeat2.STATS_COLLECTION_LONG_INTERVAL = 864e5;
        Statsbeat2.TAG = "Statsbeat";
        return Statsbeat2;
      }()
    );
    module2.exports = Statsbeat;
  }
});

// node_modules/applicationinsights/out/Library/TelemetryClient.js
var require_TelemetryClient = __commonJS({
  "node_modules/applicationinsights/out/Library/TelemetryClient.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var Config = require_Config();
    var AuthorizationHandler = require_AuthorizationHandler();
    var Context = require_Context();
    var Contracts = require_Contracts();
    var Channel = require_Channel();
    var TelemetryProcessors = require_TelemetryProcessors();
    var CorrelationContextManager_1 = require_CorrelationContextManager();
    var Statsbeat = require_Statsbeat();
    var Sender = require_Sender();
    var Util = require_Util();
    var Logging = require_Logging();
    var EnvelopeFactory = require_EnvelopeFactory();
    var TelemetryClient = (
      /** @class */
      function() {
        function TelemetryClient2(setupString) {
          this._telemetryProcessors = [];
          this._enableAzureProperties = false;
          var config = new Config(setupString);
          this.config = config;
          if (!this.config.instrumentationKey || this.config.instrumentationKey == "") {
            throw new Error("Instrumentation key not found, please provide a connection string before starting Application Insights SDK.");
          }
          this.context = new Context();
          this.commonProperties = {};
          this.authorizationHandler = null;
          if (!this.config.disableStatsbeat) {
            this._statsbeat = new Statsbeat(this.config, this.context);
            this._statsbeat.enable(true);
          }
          var sender = new Sender(this.config, this.getAuthorizationHandler, null, null, this._statsbeat);
          this.channel = new Channel(function() {
            return config.disableAppInsights;
          }, function() {
            return config.maxBatchSize;
          }, function() {
            return config.maxBatchIntervalMs;
          }, sender);
        }
        TelemetryClient2.prototype.trackAvailability = function(telemetry) {
          this.track(telemetry, Contracts.TelemetryType.Availability);
        };
        TelemetryClient2.prototype.trackPageView = function(telemetry) {
          this.track(telemetry, Contracts.TelemetryType.PageView);
        };
        TelemetryClient2.prototype.trackTrace = function(telemetry) {
          this.track(telemetry, Contracts.TelemetryType.Trace);
        };
        TelemetryClient2.prototype.trackMetric = function(telemetry) {
          this.track(telemetry, Contracts.TelemetryType.Metric);
        };
        TelemetryClient2.prototype.trackException = function(telemetry) {
          if (telemetry && telemetry.exception && !Util.isError(telemetry.exception)) {
            telemetry.exception = new Error(telemetry.exception.toString());
          }
          this.track(telemetry, Contracts.TelemetryType.Exception);
        };
        TelemetryClient2.prototype.trackEvent = function(telemetry) {
          this.track(telemetry, Contracts.TelemetryType.Event);
        };
        TelemetryClient2.prototype.trackRequest = function(telemetry) {
          this.track(telemetry, Contracts.TelemetryType.Request);
        };
        TelemetryClient2.prototype.trackDependency = function(telemetry) {
          if (telemetry && !telemetry.target && telemetry.data) {
            try {
              telemetry.target = new url.URL(telemetry.data).host;
            } catch (error) {
              telemetry.target = null;
              Logging.warn(TelemetryClient2.TAG, "The URL object is failed to create.", error);
            }
          }
          this.track(telemetry, Contracts.TelemetryType.Dependency);
        };
        TelemetryClient2.prototype.flush = function(options) {
          this.channel.triggerSend(options ? !!options.isAppCrashing : false, options ? options.callback : void 0);
        };
        TelemetryClient2.prototype.track = function(telemetry, telemetryType) {
          if (telemetry && Contracts.telemetryTypeToBaseType(telemetryType)) {
            var envelope = EnvelopeFactory.createEnvelope(telemetry, telemetryType, this.commonProperties, this.context, this.config);
            if (telemetry.time) {
              envelope.time = telemetry.time.toISOString();
            }
            if (this._enableAzureProperties) {
              TelemetryProcessors.azureRoleEnvironmentTelemetryProcessor(envelope, this.context);
            }
            var accepted = this.runTelemetryProcessors(envelope, telemetry.contextObjects);
            accepted = accepted && TelemetryProcessors.samplingTelemetryProcessor(envelope, { correlationContext: CorrelationContextManager_1.CorrelationContextManager.getCurrentContext() });
            TelemetryProcessors.preAggregatedMetricsTelemetryProcessor(envelope, this.context);
            if (accepted) {
              TelemetryProcessors.performanceMetricsTelemetryProcessor(envelope, this.quickPulseClient);
              this.channel.send(envelope);
            }
          } else {
            Logging.warn(TelemetryClient2.TAG, "track() requires telemetry object and telemetryType to be specified.");
          }
        };
        TelemetryClient2.prototype.setAutoPopulateAzureProperties = function(value) {
          this._enableAzureProperties = value;
        };
        TelemetryClient2.prototype.getAuthorizationHandler = function(config) {
          if (config && config.aadTokenCredential) {
            if (!this.authorizationHandler) {
              Logging.info(TelemetryClient2.TAG, "Adding authorization handler");
              this.authorizationHandler = new AuthorizationHandler(config.aadTokenCredential);
            }
            return this.authorizationHandler;
          }
          return null;
        };
        TelemetryClient2.prototype.addTelemetryProcessor = function(telemetryProcessor) {
          this._telemetryProcessors.push(telemetryProcessor);
        };
        TelemetryClient2.prototype.clearTelemetryProcessors = function() {
          this._telemetryProcessors = [];
        };
        TelemetryClient2.prototype.runTelemetryProcessors = function(envelope, contextObjects) {
          var accepted = true;
          var telemetryProcessorsCount = this._telemetryProcessors.length;
          if (telemetryProcessorsCount === 0) {
            return accepted;
          }
          contextObjects = contextObjects || {};
          contextObjects["correlationContext"] = CorrelationContextManager_1.CorrelationContextManager.getCurrentContext();
          for (var i = 0; i < telemetryProcessorsCount; ++i) {
            try {
              var processor = this._telemetryProcessors[i];
              if (processor) {
                if (processor.apply(null, [envelope, contextObjects]) === false) {
                  accepted = false;
                  break;
                }
              }
            } catch (error) {
              accepted = true;
              Logging.warn(TelemetryClient2.TAG, "One of telemetry processors failed, telemetry item will be sent.", error, envelope);
            }
          }
          if (accepted) {
            if (envelope && envelope.tags) {
              envelope.tags = Util.validateStringMap(envelope.tags);
            }
            if (envelope && envelope.data && envelope.data.baseData && envelope.data.baseData.properties) {
              envelope.data.baseData.properties = Util.validateStringMap(envelope.data.baseData.properties);
            }
          }
          return accepted;
        };
        TelemetryClient2.prototype.getStatsbeat = function() {
          return this._statsbeat;
        };
        TelemetryClient2.TAG = "TelemetryClient";
        return TelemetryClient2;
      }()
    );
    module2.exports = TelemetryClient;
  }
});

// node_modules/applicationinsights/out/Library/NodeClient.js
var require_NodeClient = __commonJS({
  "node_modules/applicationinsights/out/Library/NodeClient.js"(exports2, module2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var TelemetryClient = require_TelemetryClient();
    var ServerRequestTracking = require_HttpRequests();
    var ClientRequestTracking = require_HttpDependencies();
    var Logging = require_Logging();
    var NodeClient = (
      /** @class */
      function(_super) {
        __extends2(NodeClient2, _super);
        function NodeClient2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        NodeClient2.prototype.trackNodeHttpRequestSync = function(telemetry) {
          if (telemetry && telemetry.request && telemetry.response && telemetry.duration) {
            ServerRequestTracking.trackRequestSync(this, telemetry);
          } else {
            Logging.warn("trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.");
          }
        };
        NodeClient2.prototype.trackNodeHttpRequest = function(telemetry) {
          if (telemetry.duration || telemetry.error) {
            Logging.warn("trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.");
          }
          if (telemetry && telemetry.request && telemetry.response) {
            ServerRequestTracking.trackRequest(this, telemetry);
          } else {
            Logging.warn("trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.");
          }
        };
        NodeClient2.prototype.trackNodeHttpDependency = function(telemetry) {
          if (telemetry && telemetry.request) {
            ClientRequestTracking.trackRequest(this, telemetry);
          } else {
            Logging.warn("trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.");
          }
        };
        return NodeClient2;
      }(TelemetryClient)
    );
    module2.exports = NodeClient;
  }
});

// node_modules/applicationinsights/out/Library/Functions.js
var require_Functions = __commonJS({
  "node_modules/applicationinsights/out/Library/Functions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/applicationinsights/out/applicationinsights.js
var require_applicationinsights = __commonJS({
  "node_modules/applicationinsights/out/applicationinsights.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.dispose = exports2.Configuration = exports2.wrapWithCorrelationContext = exports2.startOperation = exports2.getCorrelationContext = exports2.start = exports2.setup = exports2.liveMetricsClient = exports2.defaultClient = exports2.DistributedTracingModes = void 0;
    var CorrelationContextManager = require_CorrelationContextManager();
    var AutoCollectConsole = require_Console();
    var AutoCollectExceptions = require_Exceptions();
    var AutoCollectPerformance = require_Performance();
    var AutoCollecPreAggregatedMetrics = require_PreAggregatedMetrics();
    var HeartBeat = require_HeartBeat();
    var WebSnippet = require_WebSnippet();
    var AutoCollectHttpDependencies = require_HttpDependencies();
    var AutoCollectHttpRequests = require_HttpRequests();
    var CorrelationIdManager = require_CorrelationIdManager();
    var Logging = require_Logging();
    var QuickPulseClient = require_QuickPulseStateManager();
    var NativePerformance_1 = require_NativePerformance();
    var AzureFunctionsHook_1 = require_AzureFunctionsHook();
    exports2.TelemetryClient = require_NodeClient();
    exports2.Contracts = require_Contracts();
    exports2.azureFunctionsTypes = require_Functions();
    var DistributedTracingModes;
    (function(DistributedTracingModes2) {
      DistributedTracingModes2[DistributedTracingModes2["AI"] = 0] = "AI";
      DistributedTracingModes2[DistributedTracingModes2["AI_AND_W3C"] = 1] = "AI_AND_W3C";
    })(DistributedTracingModes = exports2.DistributedTracingModes || (exports2.DistributedTracingModes = {}));
    var defaultConfig = _getDefaultAutoCollectConfig();
    var _isConsole = defaultConfig.isConsole();
    var _isConsoleLog = defaultConfig.isConsoleLog();
    var _isExceptions = defaultConfig.isExceptions();
    var _isPerformance = defaultConfig.isPerformance();
    var _isPreAggregatedMetrics = defaultConfig.isPreAggregatedMetrics();
    var _isHeartBeat = defaultConfig.isHeartBeat();
    var _isRequests = defaultConfig.isRequests();
    var _isDependencies = defaultConfig.isDependencies();
    var _isDiskRetry = defaultConfig.isDiskRetry();
    var _isCorrelating = defaultConfig.isCorrelating();
    var _forceClsHooked;
    var _isSendingLiveMetrics = defaultConfig.isSendingLiveMetrics();
    var _isNativePerformance = defaultConfig.isNativePerformance();
    var _disabledExtendedMetrics;
    var _isSnippetInjection = defaultConfig.isSnippetInjection();
    var _isAzureFunctions = defaultConfig.isAzureFunctions();
    function _getDefaultAutoCollectConfig() {
      return {
        isConsole: function() {
          return true;
        },
        isConsoleLog: function() {
          return false;
        },
        isExceptions: function() {
          return true;
        },
        isPerformance: function() {
          return true;
        },
        isPreAggregatedMetrics: function() {
          return true;
        },
        isHeartBeat: function() {
          return false;
        },
        isRequests: function() {
          return true;
        },
        isDependencies: function() {
          return true;
        },
        isDiskRetry: function() {
          return true;
        },
        isCorrelating: function() {
          return true;
        },
        isSendingLiveMetrics: function() {
          return false;
        },
        isNativePerformance: function() {
          return true;
        },
        isSnippetInjection: function() {
          return false;
        },
        isAzureFunctions: function() {
          return false;
        }
      };
    }
    var _diskRetryInterval = void 0;
    var _diskRetryMaxBytes = void 0;
    var _webSnippetConnectionString = void 0;
    var _console;
    var _exceptions;
    var _performance;
    var _preAggregatedMetrics;
    var _heartbeat;
    var _webSnippet;
    var _nativePerformance;
    var _serverRequests;
    var _clientRequests;
    var _azureFunctions;
    var _isStarted = false;
    var _performanceLiveMetrics;
    function setup(setupString) {
      if (!exports2.defaultClient) {
        exports2.defaultClient = new exports2.TelemetryClient(setupString);
        _initializeConfig();
        _console = new AutoCollectConsole(exports2.defaultClient);
        _exceptions = new AutoCollectExceptions(exports2.defaultClient);
        _performance = new AutoCollectPerformance(exports2.defaultClient);
        _preAggregatedMetrics = new AutoCollecPreAggregatedMetrics(exports2.defaultClient);
        _heartbeat = new HeartBeat(exports2.defaultClient);
        _webSnippet = new WebSnippet(exports2.defaultClient);
        _serverRequests = new AutoCollectHttpRequests(exports2.defaultClient);
        _clientRequests = new AutoCollectHttpDependencies(exports2.defaultClient);
        if (!_nativePerformance) {
          _nativePerformance = new NativePerformance_1.AutoCollectNativePerformance(exports2.defaultClient);
        }
        _azureFunctions = new AzureFunctionsHook_1.AzureFunctionsHook(exports2.defaultClient);
      } else {
        Logging.info("The default client is already setup");
      }
      if (exports2.defaultClient && exports2.defaultClient.channel) {
        exports2.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);
      }
      return Configuration;
    }
    exports2.setup = setup;
    function start() {
      if (!!exports2.defaultClient) {
        _isStarted = true;
        _console.enable(_isConsole, _isConsoleLog);
        _exceptions.enable(_isExceptions);
        _performance.enable(_isPerformance);
        _preAggregatedMetrics.enable(_isPreAggregatedMetrics);
        _heartbeat.enable(_isHeartBeat);
        _nativePerformance.enable(_isNativePerformance, _disabledExtendedMetrics);
        _serverRequests.useAutoCorrelation(_isCorrelating, _forceClsHooked);
        _serverRequests.enable(_isRequests);
        _clientRequests.enable(_isDependencies);
        _webSnippet.enable(_isSnippetInjection, _webSnippetConnectionString);
        if (exports2.liveMetricsClient && _isSendingLiveMetrics) {
          exports2.liveMetricsClient.enable(_isSendingLiveMetrics);
        }
        _azureFunctions.enable(_isAzureFunctions);
      } else {
        Logging.warn("Start cannot be called before setup");
      }
      return Configuration;
    }
    exports2.start = start;
    function _initializeConfig() {
      _isConsole = exports2.defaultClient.config.enableAutoCollectExternalLoggers !== void 0 ? exports2.defaultClient.config.enableAutoCollectExternalLoggers : _isConsole;
      _isConsoleLog = exports2.defaultClient.config.enableAutoCollectConsole !== void 0 ? exports2.defaultClient.config.enableAutoCollectConsole : _isConsoleLog;
      _isExceptions = exports2.defaultClient.config.enableAutoCollectExceptions !== void 0 ? exports2.defaultClient.config.enableAutoCollectExceptions : _isExceptions;
      _isPerformance = exports2.defaultClient.config.enableAutoCollectPerformance !== void 0 ? exports2.defaultClient.config.enableAutoCollectPerformance : _isPerformance;
      _isPreAggregatedMetrics = exports2.defaultClient.config.enableAutoCollectPreAggregatedMetrics !== void 0 ? exports2.defaultClient.config.enableAutoCollectPreAggregatedMetrics : _isPreAggregatedMetrics;
      _isHeartBeat = exports2.defaultClient.config.enableAutoCollectHeartbeat !== void 0 ? exports2.defaultClient.config.enableAutoCollectHeartbeat : _isHeartBeat;
      _isRequests = exports2.defaultClient.config.enableAutoCollectRequests !== void 0 ? exports2.defaultClient.config.enableAutoCollectRequests : _isRequests;
      _isDependencies = exports2.defaultClient.config.enableAutoDependencyCorrelation !== void 0 ? exports2.defaultClient.config.enableAutoDependencyCorrelation : _isDependencies;
      _isCorrelating = exports2.defaultClient.config.enableAutoDependencyCorrelation !== void 0 ? exports2.defaultClient.config.enableAutoDependencyCorrelation : _isCorrelating;
      _forceClsHooked = exports2.defaultClient.config.enableUseAsyncHooks !== void 0 ? exports2.defaultClient.config.enableUseAsyncHooks : _forceClsHooked;
      _isSnippetInjection = exports2.defaultClient.config.enableWebInstrumentation !== void 0 ? exports2.defaultClient.config.enableWebInstrumentation : _isSnippetInjection;
      _isSnippetInjection = exports2.defaultClient.config.enableAutoWebSnippetInjection === true ? true : _isSnippetInjection;
      _isAzureFunctions = exports2.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions !== void 0 ? exports2.defaultClient.config.enableAutoCollectIncomingRequestAzureFunctions : _isAzureFunctions;
      var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(exports2.defaultClient.config.enableAutoCollectExtendedMetrics, exports2.defaultClient.config);
      _isNativePerformance = extendedMetricsConfig.isEnabled;
      _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
    }
    function getCorrelationContext() {
      if (_isCorrelating) {
        return CorrelationContextManager.CorrelationContextManager.getCurrentContext();
      }
      return null;
    }
    exports2.getCorrelationContext = getCorrelationContext;
    function startOperation(context, request) {
      return CorrelationContextManager.CorrelationContextManager.startOperation(context, request);
    }
    exports2.startOperation = startOperation;
    function wrapWithCorrelationContext(fn, context) {
      return CorrelationContextManager.CorrelationContextManager.wrapCallback(fn, context);
    }
    exports2.wrapWithCorrelationContext = wrapWithCorrelationContext;
    var Configuration = (
      /** @class */
      function() {
        function Configuration2() {
        }
        Configuration2.setDistributedTracingMode = function(value) {
          CorrelationIdManager.w3cEnabled = value === DistributedTracingModes.AI_AND_W3C;
          return Configuration2;
        };
        Configuration2.setAutoCollectConsole = function(value, collectConsoleLog) {
          if (collectConsoleLog === void 0) {
            collectConsoleLog = false;
          }
          _isConsole = value;
          _isConsoleLog = collectConsoleLog;
          if (_isStarted) {
            _console.enable(value, collectConsoleLog);
          }
          return Configuration2;
        };
        Configuration2.setAutoCollectExceptions = function(value) {
          _isExceptions = value;
          if (_isStarted) {
            _exceptions.enable(value);
          }
          return Configuration2;
        };
        Configuration2.setAutoCollectPerformance = function(value, collectExtendedMetrics) {
          if (collectExtendedMetrics === void 0) {
            collectExtendedMetrics = true;
          }
          _isPerformance = value;
          var extendedMetricsConfig = NativePerformance_1.AutoCollectNativePerformance.parseEnabled(collectExtendedMetrics, exports2.defaultClient.config);
          _isNativePerformance = extendedMetricsConfig.isEnabled;
          _disabledExtendedMetrics = extendedMetricsConfig.disabledMetrics;
          if (_isStarted) {
            _performance.enable(value);
            _nativePerformance.enable(extendedMetricsConfig.isEnabled, extendedMetricsConfig.disabledMetrics);
          }
          return Configuration2;
        };
        Configuration2.setAutoCollectPreAggregatedMetrics = function(value) {
          _isPreAggregatedMetrics = value;
          if (_isStarted) {
            _preAggregatedMetrics.enable(value);
          }
          return Configuration2;
        };
        Configuration2.setAutoCollectHeartbeat = function(value) {
          _isHeartBeat = value;
          if (_isStarted) {
            _heartbeat.enable(value);
          }
          return Configuration2;
        };
        Configuration2.enableAutoWebSnippetInjection = function(value, WebSnippetConnectionString) {
          _isSnippetInjection = value;
          _webSnippetConnectionString = WebSnippetConnectionString;
          if (_isStarted) {
            _webSnippet.enable(value, _webSnippetConnectionString);
          }
          return Configuration2;
        };
        Configuration2.enableWebInstrumentation = function(value, WebSnippetConnectionString) {
          _isSnippetInjection = value;
          _webSnippetConnectionString = WebSnippetConnectionString;
          if (_isStarted) {
            _webSnippet.enable(value, _webSnippetConnectionString);
          }
          return Configuration2;
        };
        Configuration2.setAutoCollectRequests = function(value) {
          _isRequests = value;
          if (_isStarted) {
            _serverRequests.enable(value);
          }
          return Configuration2;
        };
        Configuration2.setAutoCollectDependencies = function(value) {
          _isDependencies = value;
          if (_isStarted) {
            _clientRequests.enable(value);
          }
          return Configuration2;
        };
        Configuration2.setAutoDependencyCorrelation = function(value, useAsyncHooks) {
          _isCorrelating = value;
          _forceClsHooked = useAsyncHooks;
          if (_isStarted) {
            _serverRequests.useAutoCorrelation(value, useAsyncHooks);
          }
          return Configuration2;
        };
        Configuration2.setUseDiskRetryCaching = function(value, resendInterval, maxBytesOnDisk) {
          _isDiskRetry = value;
          _diskRetryInterval = resendInterval;
          _diskRetryMaxBytes = maxBytesOnDisk;
          if (exports2.defaultClient && exports2.defaultClient.channel) {
            exports2.defaultClient.channel.setUseDiskRetryCaching(_isDiskRetry, _diskRetryInterval, _diskRetryMaxBytes);
          }
          return Configuration2;
        };
        Configuration2.setInternalLogging = function(enableDebugLogging, enableWarningLogging) {
          if (enableDebugLogging === void 0) {
            enableDebugLogging = false;
          }
          if (enableWarningLogging === void 0) {
            enableWarningLogging = true;
          }
          Logging.enableDebug = enableDebugLogging;
          Logging.disableWarnings = !enableWarningLogging;
          return Configuration2;
        };
        Configuration2.setAutoCollectIncomingRequestAzureFunctions = function(value) {
          _isAzureFunctions = value;
          if (_isStarted) {
            _azureFunctions.enable(value);
          }
          return Configuration2;
        };
        Configuration2.setSendLiveMetrics = function(enable) {
          if (enable === void 0) {
            enable = false;
          }
          if (!exports2.defaultClient) {
            Logging.warn("Live metrics client cannot be setup without the default client");
            return Configuration2;
          }
          if (!exports2.liveMetricsClient && enable) {
            exports2.liveMetricsClient = new QuickPulseClient(exports2.defaultClient.config, exports2.defaultClient.context, exports2.defaultClient.getAuthorizationHandler);
            _performanceLiveMetrics = new AutoCollectPerformance(exports2.liveMetricsClient, 1e3, true);
            exports2.liveMetricsClient.addCollector(_performanceLiveMetrics);
            exports2.defaultClient.quickPulseClient = exports2.liveMetricsClient;
          } else if (exports2.liveMetricsClient) {
            exports2.liveMetricsClient.enable(enable);
          }
          _isSendingLiveMetrics = enable;
          return Configuration2;
        };
        Configuration2.start = start;
        return Configuration2;
      }()
    );
    exports2.Configuration = Configuration;
    function dispose2() {
      CorrelationIdManager.w3cEnabled = true;
      exports2.defaultClient = null;
      _isStarted = false;
      if (_console) {
        _console.dispose();
      }
      if (_exceptions) {
        _exceptions.dispose();
      }
      if (_performance) {
        _performance.dispose();
      }
      if (_preAggregatedMetrics) {
        _preAggregatedMetrics.dispose();
      }
      if (_heartbeat) {
        _heartbeat.dispose();
      }
      if (_webSnippet) {
        _webSnippet.dispose();
      }
      if (_nativePerformance) {
        _nativePerformance.dispose();
      }
      if (_serverRequests) {
        _serverRequests.dispose();
      }
      if (_clientRequests) {
        _clientRequests.dispose();
      }
      if (exports2.liveMetricsClient) {
        exports2.liveMetricsClient.enable(false);
        _isSendingLiveMetrics = false;
        exports2.liveMetricsClient = void 0;
      }
      if (_azureFunctions) {
        _azureFunctions.dispose();
      }
    }
    exports2.dispose = dispose2;
  }
});

// node_modules/@vscode/extension-telemetry/dist/node/node/telemetryReporter.js
var require_telemetryReporter = __commonJS({
  "node_modules/@vscode/extension-telemetry/dist/node/node/telemetryReporter.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding2(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var os = __importStar(require("os"));
    var vscode = __importStar(require("vscode"));
    var https = __importStar(require("https"));
    var baseTelemetryReporter_1 = require_baseTelemetryReporter();
    var baseTelemetrySender_1 = require_baseTelemetrySender();
    var util_1 = require_util();
    var _1dsClientFactory_1 = require_dsClientFactory();
    var appInsightsClientFactory = async (key, replacementOptions) => {
      let appInsightsClient;
      try {
        process.env["APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL"] = "1";
        const appInsights = await Promise.resolve().then(() => __importStar(require_applicationinsights()));
        if (appInsights.defaultClient) {
          appInsightsClient = new appInsights.TelemetryClient(key);
          appInsightsClient.channel.setUseDiskRetryCaching(true);
        } else {
          appInsights.setup(key).setAutoCollectRequests(false).setAutoCollectPerformance(false).setAutoCollectExceptions(false).setAutoCollectDependencies(false).setAutoDependencyCorrelation(false).setAutoCollectConsole(false).setAutoCollectHeartbeat(false).setUseDiskRetryCaching(true).start();
          appInsightsClient = appInsights.defaultClient;
        }
        if (vscode && vscode.env) {
          appInsightsClient.context.tags[appInsightsClient.context.keys.userId] = vscode.env.machineId;
          appInsightsClient.context.tags[appInsightsClient.context.keys.sessionId] = vscode.env.sessionId;
          appInsightsClient.context.tags[appInsightsClient.context.keys.cloudRole] = vscode.env.appName;
          appInsightsClient.context.tags[appInsightsClient.context.keys.cloudRoleInstance] = vscode.env.appName;
        }
      } catch (e) {
        return Promise.reject("Failed to initialize app insights!\n" + e.message);
      }
      if (replacementOptions?.length) {
        addReplacementOptions(appInsightsClient, replacementOptions);
      }
      const telemetryClient = {
        logEvent: (eventName, data) => {
          try {
            appInsightsClient?.trackEvent({
              name: eventName,
              properties: data?.properties,
              measurements: data?.measurements
            });
          } catch (e) {
            throw new Error("Failed to log event to app insights!\n" + e.message);
          }
        },
        flush: async () => {
          try {
            appInsightsClient?.flush();
          } catch (e) {
            throw new Error("Failed to flush app insights!\n" + e.message);
          }
        }
      };
      return telemetryClient;
    };
    function addReplacementOptions(appInsightsClient, replacementOptions) {
      appInsightsClient.addTelemetryProcessor((event) => {
        if (Array.isArray(event.tags)) {
          event.tags.forEach((tag) => util_1.TelemetryUtil.applyReplacements(tag, replacementOptions));
        } else if (event.tags) {
          util_1.TelemetryUtil.applyReplacements(event.tags, replacementOptions);
        }
        if (event.data.baseData) {
          util_1.TelemetryUtil.applyReplacements(event.data.baseData, replacementOptions);
        }
        return true;
      });
    }
    function getXHROverride() {
      const customHttpXHROverride = {
        sendPOST: (payload, oncomplete) => {
          const options = {
            method: "POST",
            headers: {
              ...payload.headers,
              "Content-Type": "application/json",
              "Content-Length": Buffer.byteLength(payload.data)
            }
          };
          try {
            const req = https.request(payload.urlString, options, (res) => {
              res.on("data", function(responseData) {
                oncomplete(res.statusCode ?? 200, res.headers, responseData.toString());
              });
              res.on("error", function() {
                oncomplete(0, {});
              });
            });
            req.write(payload.data);
            req.end();
          } catch {
            oncomplete(0, {});
          }
        }
      };
      return customHttpXHROverride;
    }
    var TelemetryReporter2 = class extends baseTelemetryReporter_1.BaseTelemetryReporter {
      constructor(key, replacementOptions) {
        let clientFactory = (key2) => appInsightsClientFactory(key2, replacementOptions);
        if (util_1.TelemetryUtil.shouldUseOneDataSystemSDK(key)) {
          clientFactory = (key2) => (0, _1dsClientFactory_1.oneDataSystemClientFactory)(key2, vscode, getXHROverride());
        }
        const osShim = {
          release: os.release(),
          platform: os.platform(),
          architecture: os.arch()
        };
        const sender = new baseTelemetrySender_1.BaseTelemetrySender(key, clientFactory);
        if (key && key.indexOf("AIF-") === 0) {
          throw new Error("AIF keys are no longer supported. Please switch to 1DS keys for 1st party extensions");
        }
        super(sender, vscode, { additionalCommonProperties: util_1.TelemetryUtil.getAdditionalCommonProperties(osShim) });
      }
    };
    exports2.default = TelemetryReporter2;
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
    "use strict";
    var conversions = {};
    module2.exports = conversions;
    function sign(x) {
      return x < 0 ? -1 : 1;
    }
    function evenRound(x) {
      if (x % 1 === 0.5 && (x & 1) === 0) {
        return Math.floor(x);
      } else {
        return Math.round(x);
      }
    }
    function createNumberConversion(bitLength, typeOpts) {
      if (!typeOpts.unsigned) {
        --bitLength;
      }
      const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
      const upperBound = Math.pow(2, bitLength) - 1;
      const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
      const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
      return function(V, opts) {
        if (!opts)
          opts = {};
        let x = +V;
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite number");
          }
          x = sign(x) * Math.floor(Math.abs(x));
          if (x < lowerBound || x > upperBound) {
            throw new TypeError("Argument is not in byte range");
          }
          return x;
        }
        if (!isNaN(x) && opts.clamp) {
          x = evenRound(x);
          if (x < lowerBound)
            x = lowerBound;
          if (x > upperBound)
            x = upperBound;
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = sign(x) * Math.floor(Math.abs(x));
        x = x % moduloVal;
        if (!typeOpts.unsigned && x >= moduloBound) {
          return x - moduloVal;
        } else if (typeOpts.unsigned) {
          if (x < 0) {
            x += moduloVal;
          } else if (x === -0) {
            return 0;
          }
        }
        return x;
      };
    }
    conversions["void"] = function() {
      return void 0;
    };
    conversions["boolean"] = function(val) {
      return !!val;
    };
    conversions["byte"] = createNumberConversion(8, { unsigned: false });
    conversions["octet"] = createNumberConversion(8, { unsigned: true });
    conversions["short"] = createNumberConversion(16, { unsigned: false });
    conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
    conversions["long"] = createNumberConversion(32, { unsigned: false });
    conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
    conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
    conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
    conversions["double"] = function(V) {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError("Argument is not a finite floating-point value");
      }
      return x;
    };
    conversions["unrestricted double"] = function(V) {
      const x = +V;
      if (isNaN(x)) {
        throw new TypeError("Argument is NaN");
      }
      return x;
    };
    conversions["float"] = conversions["double"];
    conversions["unrestricted float"] = conversions["unrestricted double"];
    conversions["DOMString"] = function(V, opts) {
      if (!opts)
        opts = {};
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      return String(V);
    };
    conversions["ByteString"] = function(V, opts) {
      const x = String(V);
      let c = void 0;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError("Argument is not a valid bytestring");
        }
      }
      return x;
    };
    conversions["USVString"] = function(V) {
      const S = String(V);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else {
          if (i === n - 1) {
            U.push(String.fromCodePoint(65533));
          } else {
            const d = S.charCodeAt(i + 1);
            if (56320 <= d && d <= 57343) {
              const a = c & 1023;
              const b = d & 1023;
              U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
              ++i;
            } else {
              U.push(String.fromCodePoint(65533));
            }
          }
        }
      }
      return U.join("");
    };
    conversions["Date"] = function(V, opts) {
      if (!(V instanceof Date)) {
        throw new TypeError("Argument is not a Date object");
      }
      if (isNaN(V)) {
        return void 0;
      }
      return V;
    };
    conversions["RegExp"] = function(V, opts) {
      if (!(V instanceof RegExp)) {
        V = new RegExp(V);
      }
      return V;
    };
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils6 = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
    "use strict";
    module2.exports.mixin = function mixin(target, source) {
      const keys = Object.getOwnPropertyNames(source);
      for (let i = 0; i < keys.length; ++i) {
        Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
      }
    };
    module2.exports.wrapperSymbol = Symbol("wrapper");
    module2.exports.implSymbol = Symbol("impl");
    module2.exports.wrapperForImpl = function(impl) {
      return impl[module2.exports.wrapperSymbol];
    };
    module2.exports.implForWrapper = function(wrapper) {
      return wrapper[module2.exports.implSymbol];
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
    module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var mappingTable = require_mappingTable();
    var PROCESSING_OPTIONS = {
      TRANSITIONAL: 0,
      NONTRANSITIONAL: 1
    };
    function normalize(str) {
      return str.split("\0").map(function(s) {
        return s.normalize("NFC");
      }).join("\0");
    }
    function findStatus(val) {
      var start = 0;
      var end = mappingTable.length - 1;
      while (start <= end) {
        var mid = Math.floor((start + end) / 2);
        var target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          return target;
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(string) {
      return string.replace(regexAstralSymbols, "_").length;
    }
    function mapChars(domain_name, useSTD3, processing_option) {
      var hasError = false;
      var processed = "";
      var len = countSymbols(domain_name);
      for (var i = 0; i < len; ++i) {
        var codePoint = domain_name.codePointAt(i);
        var status = findStatus(codePoint);
        switch (status[1]) {
          case "disallowed":
            hasError = true;
            processed += String.fromCodePoint(codePoint);
            break;
          case "ignored":
            break;
          case "mapped":
            processed += String.fromCodePoint.apply(String, status[2]);
            break;
          case "deviation":
            if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
              processed += String.fromCodePoint.apply(String, status[2]);
            } else {
              processed += String.fromCodePoint(codePoint);
            }
            break;
          case "valid":
            processed += String.fromCodePoint(codePoint);
            break;
          case "disallowed_STD3_mapped":
            if (useSTD3) {
              hasError = true;
              processed += String.fromCodePoint(codePoint);
            } else {
              processed += String.fromCodePoint.apply(String, status[2]);
            }
            break;
          case "disallowed_STD3_valid":
            if (useSTD3) {
              hasError = true;
            }
            processed += String.fromCodePoint(codePoint);
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
    function validateLabel(label, processing_option) {
      if (label.substr(0, 4) === "xn--") {
        label = punycode.toUnicode(label);
        processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
      }
      var error = false;
      if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
        error = true;
      }
      var len = countSymbols(label);
      for (var i = 0; i < len; ++i) {
        var status = findStatus(label.codePointAt(i));
        if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
          error = true;
          break;
        }
      }
      return {
        label,
        error
      };
    }
    function processing(domain_name, useSTD3, processing_option) {
      var result = mapChars(domain_name, useSTD3, processing_option);
      result.string = normalize(result.string);
      var labels = result.string.split(".");
      for (var i = 0; i < labels.length; ++i) {
        try {
          var validation = validateLabel(labels[i]);
          labels[i] = validation.label;
          result.error = result.error || validation.error;
        } catch (e) {
          result.error = true;
        }
      }
      return {
        string: labels.join("."),
        error: result.error
      };
    }
    module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
      var result = processing(domain_name, useSTD3, processing_option);
      var labels = result.string.split(".");
      labels = labels.map(function(l) {
        try {
          return punycode.toASCII(l);
        } catch (e) {
          result.error = true;
          return l;
        }
      });
      if (verifyDnsLength) {
        var total = labels.slice(0, labels.length - 1).join(".").length;
        if (total.length > 253 || total.length === 0) {
          result.error = true;
        }
        for (var i = 0; i < labels.length; ++i) {
          if (labels.length > 63 || labels.length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error)
        return null;
      return labels.join(".");
    };
    module2.exports.toUnicode = function(domain_name, useSTD3) {
      var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
      return {
        domain: result.string,
        error: result.error
      };
    };
    module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
    "use strict";
    var punycode = require("punycode");
    var tr46 = require_tr46();
    var specialSchemes = {
      ftp: 21,
      file: null,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string) {
      return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
    }
    function containsForbiddenHostCodePoint(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string) {
      return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function utf8PercentEncode(c) {
      const buf = new Buffer(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function utf8PercentDecode(str) {
      const input = new Buffer(str);
      const output = [];
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37) {
          output.push(input[i]);
        } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
          output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
          i += 2;
        } else {
          output.push(input[i]);
        }
      }
      return new Buffer(output).toString();
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
    function isPathPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output = String(n % 256) + output;
        if (i !== 4) {
          output = "." + output;
        }
        n = Math.floor(n / 256);
      }
      return output;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (isASCIIDigit(input[pointer])) {
              const number = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output += separator;
          ignore0 = true;
          continue;
        }
        output += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output += ":";
        }
      }
      return output;
    }
    function parseHost(input, isSpecialArg) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (!isSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = utf8PercentDecode(input);
      const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
      if (asciiDomain === null) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const path2 = url.path;
      if (path2.length === 0) {
        return;
      }
      if (url.scheme === "file" && path2.length === 1 && isNormalizedWindowsDriveLetter(path2[0])) {
        return;
      }
      path2.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string) {
      return /^[A-Za-z]:$/.test(string);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        this.buffer = "";
        if (this.stateOverride) {
          return false;
        }
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
          !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file") {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = new Buffer(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output = url.scheme + ":";
      if (url.host !== null) {
        output += "//";
        if (url.username !== "" || url.password !== "") {
          output += url.username;
          if (url.password !== "") {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += serializeHost(url.host);
        if (url.port !== null) {
          output += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output += "//";
      }
      if (url.cannotBeABaseURL) {
        output += url.path[0];
      } else {
        for (const string of url.path) {
          output += "/" + string;
        }
      }
      if (url.query !== null) {
        output += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output += "#" + url.fragment;
      }
      return output;
    }
    function serializeOrigin(tuple) {
      let result = tuple.scheme + "://";
      result += serializeHost(tuple.host);
      if (tuple.port !== null) {
        result += ":" + tuple.port;
      }
      return result;
    }
    module2.exports.serializeURL = serializeURL;
    module2.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "gopher":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "file://";
        default:
          return "null";
      }
    };
    module2.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return "failure";
      }
      return usm.url;
    };
    module2.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module2.exports.serializeHost = serializeHost;
    module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module2.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module2.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
    "use strict";
    var usm = require_url_state_machine();
    exports2.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === "failure") {
            throw new TypeError("Invalid base URL");
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === "failure") {
          throw new TypeError("Invalid URL");
        }
        this._url = parsedURL;
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
    "use strict";
    var conversions = require_lib4();
    var utils = require_utils6();
    var Impl = require_URL_impl();
    var impl = utils.implSymbol;
    function URL2(url) {
      if (!this || this[impl] || !(this instanceof URL2)) {
        throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
      }
      if (arguments.length < 1) {
        throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 2; ++i) {
        args[i] = arguments[i];
      }
      args[0] = conversions["USVString"](args[0]);
      if (args[1] !== void 0) {
        args[1] = conversions["USVString"](args[1]);
      }
      module2.exports.setup(this, args);
    }
    URL2.prototype.toJSON = function toJSON() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      const args = [];
      for (let i = 0; i < arguments.length && i < 0; ++i) {
        args[i] = arguments[i];
      }
      return this[impl].toJSON.apply(this[impl], args);
    };
    Object.defineProperty(URL2.prototype, "href", {
      get() {
        return this[impl].href;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].href = V;
      },
      enumerable: true,
      configurable: true
    });
    URL2.prototype.toString = function() {
      if (!this || !module2.exports.is(this)) {
        throw new TypeError("Illegal invocation");
      }
      return this.href;
    };
    Object.defineProperty(URL2.prototype, "origin", {
      get() {
        return this[impl].origin;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "protocol", {
      get() {
        return this[impl].protocol;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].protocol = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "username", {
      get() {
        return this[impl].username;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].username = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "password", {
      get() {
        return this[impl].password;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].password = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "host", {
      get() {
        return this[impl].host;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].host = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hostname", {
      get() {
        return this[impl].hostname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hostname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "port", {
      get() {
        return this[impl].port;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].port = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "pathname", {
      get() {
        return this[impl].pathname;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].pathname = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "search", {
      get() {
        return this[impl].search;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].search = V;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(URL2.prototype, "hash", {
      get() {
        return this[impl].hash;
      },
      set(V) {
        V = conversions["USVString"](V);
        this[impl].hash = V;
      },
      enumerable: true,
      configurable: true
    });
    module2.exports = {
      is(obj) {
        return !!obj && obj[impl] instanceof Impl.implementation;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL2.prototype);
        this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        obj[impl] = new Impl.implementation(constructorArgs, privateData);
        obj[impl][utils.wrapperSymbol] = obj;
      },
      interface: URL2,
      expose: {
        Window: { URL: URL2 },
        Worker: { URL: URL2 }
      }
    };
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports2) {
    "use strict";
    exports2.URL = require_URL().interface;
    exports2.serializeURL = require_url_state_machine().serializeURL;
    exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports2.basicURLParse = require_url_state_machine().basicURLParse;
    exports2.setTheUsername = require_url_state_machine().setTheUsername;
    exports2.setThePassword = require_url_state_machine().setThePassword;
    exports2.serializeHost = require_url_state_machine().serializeHost;
    exports2.serializeInteger = require_url_state_machine().serializeInteger;
    exports2.parseURL = require_url_state_machine().parseURL;
  }
});

// node_modules/node-fetch/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/node-fetch/lib/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var Stream = _interopDefault(require("stream"));
    var http = _interopDefault(require("http"));
    var Url = _interopDefault(require("url"));
    var whatwgUrl = _interopDefault(require_public_api());
    var https = _interopDefault(require("https"));
    var zlib = _interopDefault(require("zlib"));
    var Readable = Stream.Readable;
    var BUFFER = Symbol("buffer");
    var TYPE = Symbol("type");
    var Blob = class _Blob {
      constructor() {
        this[TYPE] = "";
        const blobParts = arguments[0];
        const options = arguments[1];
        const buffers = [];
        let size = 0;
        if (blobParts) {
          const a = blobParts;
          const length = Number(a.length);
          for (let i = 0; i < length; i++) {
            const element = a[i];
            let buffer;
            if (element instanceof Buffer) {
              buffer = element;
            } else if (ArrayBuffer.isView(element)) {
              buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
            } else if (element instanceof ArrayBuffer) {
              buffer = Buffer.from(element);
            } else if (element instanceof _Blob) {
              buffer = element[BUFFER];
            } else {
              buffer = Buffer.from(typeof element === "string" ? element : String(element));
            }
            size += buffer.length;
            buffers.push(buffer);
          }
        }
        this[BUFFER] = Buffer.concat(buffers);
        let type = options && options.type !== void 0 && String(options.type).toLowerCase();
        if (type && !/[^\u0020-\u007E]/.test(type)) {
          this[TYPE] = type;
        }
      }
      get size() {
        return this[BUFFER].length;
      }
      get type() {
        return this[TYPE];
      }
      text() {
        return Promise.resolve(this[BUFFER].toString());
      }
      arrayBuffer() {
        const buf = this[BUFFER];
        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        return Promise.resolve(ab);
      }
      stream() {
        const readable = new Readable();
        readable._read = function() {
        };
        readable.push(this[BUFFER]);
        readable.push(null);
        return readable;
      }
      toString() {
        return "[object Blob]";
      }
      slice() {
        const size = this.size;
        const start = arguments[0];
        const end = arguments[1];
        let relativeStart, relativeEnd;
        if (start === void 0) {
          relativeStart = 0;
        } else if (start < 0) {
          relativeStart = Math.max(size + start, 0);
        } else {
          relativeStart = Math.min(start, size);
        }
        if (end === void 0) {
          relativeEnd = size;
        } else if (end < 0) {
          relativeEnd = Math.max(size + end, 0);
        } else {
          relativeEnd = Math.min(end, size);
        }
        const span = Math.max(relativeEnd - relativeStart, 0);
        const buffer = this[BUFFER];
        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
        const blob = new _Blob([], { type: arguments[2] });
        blob[BUFFER] = slicedBuffer;
        return blob;
      }
    };
    Object.defineProperties(Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
      value: "Blob",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function FetchError(message, type, systemError) {
      Error.call(this, message);
      this.message = message;
      this.type = type;
      if (systemError) {
        this.code = this.errno = systemError.code;
      }
      Error.captureStackTrace(this, this.constructor);
    }
    FetchError.prototype = Object.create(Error.prototype);
    FetchError.prototype.constructor = FetchError;
    FetchError.prototype.name = "FetchError";
    var convert;
    try {
      convert = require("encoding").convert;
    } catch (e) {
    }
    var INTERNALS = Symbol("Body internals");
    var PassThrough = Stream.PassThrough;
    function Body(body) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
      let size = _ref$size === void 0 ? 0 : _ref$size;
      var _ref$timeout = _ref.timeout;
      let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
      if (body == null) {
        body = null;
      } else if (isURLSearchParams(body)) {
        body = Buffer.from(body.toString());
      } else if (isBlob(body))
        ;
      else if (Buffer.isBuffer(body))
        ;
      else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        body = Buffer.from(body);
      } else if (ArrayBuffer.isView(body)) {
        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
      } else if (body instanceof Stream)
        ;
      else {
        body = Buffer.from(String(body));
      }
      this[INTERNALS] = {
        body,
        disturbed: false,
        error: null
      };
      this.size = size;
      this.timeout = timeout;
      if (body instanceof Stream) {
        body.on("error", function(err) {
          const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
          _this[INTERNALS].error = error;
        });
      }
    }
    Body.prototype = {
      get body() {
        return this[INTERNALS].body;
      },
      get bodyUsed() {
        return this[INTERNALS].disturbed;
      },
      /**
       * Decode response as ArrayBuffer
       *
       * @return  Promise
       */
      arrayBuffer() {
        return consumeBody.call(this).then(function(buf) {
          return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
        });
      },
      /**
       * Return raw response as Blob
       *
       * @return Promise
       */
      blob() {
        let ct = this.headers && this.headers.get("content-type") || "";
        return consumeBody.call(this).then(function(buf) {
          return Object.assign(
            // Prevent copying
            new Blob([], {
              type: ct.toLowerCase()
            }),
            {
              [BUFFER]: buf
            }
          );
        });
      },
      /**
       * Decode response as json
       *
       * @return  Promise
       */
      json() {
        var _this2 = this;
        return consumeBody.call(this).then(function(buffer) {
          try {
            return JSON.parse(buffer.toString());
          } catch (err) {
            return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
          }
        });
      },
      /**
       * Decode response as text
       *
       * @return  Promise
       */
      text() {
        return consumeBody.call(this).then(function(buffer) {
          return buffer.toString();
        });
      },
      /**
       * Decode response as buffer (non-spec api)
       *
       * @return  Promise
       */
      buffer() {
        return consumeBody.call(this);
      },
      /**
       * Decode response as text, while automatically detecting the encoding and
       * trying to decode to UTF-8 (non-spec api)
       *
       * @return  Promise
       */
      textConverted() {
        var _this3 = this;
        return consumeBody.call(this).then(function(buffer) {
          return convertBody(buffer, _this3.headers);
        });
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    Body.mixIn = function(proto) {
      for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {
        if (!(name2 in proto)) {
          const desc = Object.getOwnPropertyDescriptor(Body.prototype, name2);
          Object.defineProperty(proto, name2, desc);
        }
      }
    };
    function consumeBody() {
      var _this4 = this;
      if (this[INTERNALS].disturbed) {
        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
      }
      this[INTERNALS].disturbed = true;
      if (this[INTERNALS].error) {
        return Body.Promise.reject(this[INTERNALS].error);
      }
      let body = this.body;
      if (body === null) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      if (isBlob(body)) {
        body = body.stream();
      }
      if (Buffer.isBuffer(body)) {
        return Body.Promise.resolve(body);
      }
      if (!(body instanceof Stream)) {
        return Body.Promise.resolve(Buffer.alloc(0));
      }
      let accum = [];
      let accumBytes = 0;
      let abort = false;
      return new Body.Promise(function(resolve, reject) {
        let resTimeout;
        if (_this4.timeout) {
          resTimeout = setTimeout(function() {
            abort = true;
            reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
          }, _this4.timeout);
        }
        body.on("error", function(err) {
          if (err.name === "AbortError") {
            abort = true;
            reject(err);
          } else {
            reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
          }
        });
        body.on("data", function(chunk) {
          if (abort || chunk === null) {
            return;
          }
          if (_this4.size && accumBytes + chunk.length > _this4.size) {
            abort = true;
            reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
            return;
          }
          accumBytes += chunk.length;
          accum.push(chunk);
        });
        body.on("end", function() {
          if (abort) {
            return;
          }
          clearTimeout(resTimeout);
          try {
            resolve(Buffer.concat(accum, accumBytes));
          } catch (err) {
            reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
          }
        });
      });
    }
    function convertBody(buffer, headers) {
      if (typeof convert !== "function") {
        throw new Error("The package `encoding` must be installed to use the textConverted() function");
      }
      const ct = headers.get("content-type");
      let charset = "utf-8";
      let res, str;
      if (ct) {
        res = /charset=([^;]*)/i.exec(ct);
      }
      str = buffer.slice(0, 1024).toString();
      if (!res && str) {
        res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
      }
      if (!res && str) {
        res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
        if (!res) {
          res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
          if (res) {
            res.pop();
          }
        }
        if (res) {
          res = /charset=(.*)/i.exec(res.pop());
        }
      }
      if (!res && str) {
        res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
      }
      if (res) {
        charset = res.pop();
        if (charset === "gb2312" || charset === "gbk") {
          charset = "gb18030";
        }
      }
      return convert(buffer, "UTF-8", charset).toString();
    }
    function isURLSearchParams(obj) {
      if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
        return false;
      }
      return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
    }
    function isBlob(obj) {
      return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
    }
    function clone(instance) {
      let p1, p2;
      let body = instance.body;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof Stream && typeof body.getBoundary !== "function") {
        p1 = new PassThrough();
        p2 = new PassThrough();
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS].body = p1;
        body = p2;
      }
      return body;
    }
    function extractContentType(body) {
      if (body === null) {
        return null;
      } else if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      } else if (isURLSearchParams(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isBlob(body)) {
        return body.type || null;
      } else if (Buffer.isBuffer(body)) {
        return null;
      } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
        return null;
      } else if (ArrayBuffer.isView(body)) {
        return null;
      } else if (typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      } else if (body instanceof Stream) {
        return null;
      } else {
        return "text/plain;charset=UTF-8";
      }
    }
    function getTotalBytes(instance) {
      const body = instance.body;
      if (body === null) {
        return 0;
      } else if (isBlob(body)) {
        return body.size;
      } else if (Buffer.isBuffer(body)) {
        return body.length;
      } else if (body && typeof body.getLengthSync === "function") {
        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
        body.hasKnownLength && body.hasKnownLength()) {
          return body.getLengthSync();
        }
        return null;
      } else {
        return null;
      }
    }
    function writeToStream(dest, instance) {
      const body = instance.body;
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        body.stream().pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    }
    Body.Promise = global.Promise;
    var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
    var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    function validateName(name2) {
      name2 = `${name2}`;
      if (invalidTokenRegex.test(name2) || name2 === "") {
        throw new TypeError(`${name2} is not a legal HTTP header name`);
      }
    }
    function validateValue(value) {
      value = `${value}`;
      if (invalidHeaderCharRegex.test(value)) {
        throw new TypeError(`${value} is not a legal HTTP header value`);
      }
    }
    function find(map, name2) {
      name2 = name2.toLowerCase();
      for (const key in map) {
        if (key.toLowerCase() === name2) {
          return key;
        }
      }
      return void 0;
    }
    var MAP = Symbol("map");
    var Headers3 = class _Headers {
      /**
       * Headers class
       *
       * @param   Object  headers  Response headers
       * @return  Void
       */
      constructor() {
        let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
        this[MAP] = /* @__PURE__ */ Object.create(null);
        if (init instanceof _Headers) {
          const rawHeaders = init.raw();
          const headerNames = Object.keys(rawHeaders);
          for (const headerName of headerNames) {
            for (const value of rawHeaders[headerName]) {
              this.append(headerName, value);
            }
          }
          return;
        }
        if (init == null)
          ;
        else if (typeof init === "object") {
          const method = init[Symbol.iterator];
          if (method != null) {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            const pairs = [];
            for (const pair of init) {
              if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                throw new TypeError("Each header pair must be iterable");
              }
              pairs.push(Array.from(pair));
            }
            for (const pair of pairs) {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              this.append(pair[0], pair[1]);
            }
          } else {
            for (const key of Object.keys(init)) {
              const value = init[key];
              this.append(key, value);
            }
          }
        } else {
          throw new TypeError("Provided initializer must be an object");
        }
      }
      /**
       * Return combined header value given name
       *
       * @param   String  name  Header name
       * @return  Mixed
       */
      get(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key = find(this[MAP], name2);
        if (key === void 0) {
          return null;
        }
        return this[MAP][key].join(", ");
      }
      /**
       * Iterate over all headers
       *
       * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
       * @param   Boolean   thisArg   `this` context for callback function
       * @return  Void
       */
      forEach(callback) {
        let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        let pairs = getHeaders(this);
        let i = 0;
        while (i < pairs.length) {
          var _pairs$i = pairs[i];
          const name2 = _pairs$i[0], value = _pairs$i[1];
          callback.call(thisArg, value, name2, this);
          pairs = getHeaders(this);
          i++;
        }
      }
      /**
       * Overwrite header values given name
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      set(name2, value) {
        name2 = `${name2}`;
        value = `${value}`;
        validateName(name2);
        validateValue(value);
        const key = find(this[MAP], name2);
        this[MAP][key !== void 0 ? key : name2] = [value];
      }
      /**
       * Append a value onto existing header
       *
       * @param   String  name   Header name
       * @param   String  value  Header value
       * @return  Void
       */
      append(name2, value) {
        name2 = `${name2}`;
        value = `${value}`;
        validateName(name2);
        validateValue(value);
        const key = find(this[MAP], name2);
        if (key !== void 0) {
          this[MAP][key].push(value);
        } else {
          this[MAP][name2] = [value];
        }
      }
      /**
       * Check for header name existence
       *
       * @param   String   name  Header name
       * @return  Boolean
       */
      has(name2) {
        name2 = `${name2}`;
        validateName(name2);
        return find(this[MAP], name2) !== void 0;
      }
      /**
       * Delete all header values given name
       *
       * @param   String  name  Header name
       * @return  Void
       */
      delete(name2) {
        name2 = `${name2}`;
        validateName(name2);
        const key = find(this[MAP], name2);
        if (key !== void 0) {
          delete this[MAP][key];
        }
      }
      /**
       * Return raw headers (non-spec api)
       *
       * @return  Object
       */
      raw() {
        return this[MAP];
      }
      /**
       * Get an iterator on keys.
       *
       * @return  Iterator
       */
      keys() {
        return createHeadersIterator(this, "key");
      }
      /**
       * Get an iterator on values.
       *
       * @return  Iterator
       */
      values() {
        return createHeadersIterator(this, "value");
      }
      /**
       * Get an iterator on entries.
       *
       * This is the default iterator of the Headers object.
       *
       * @return  Iterator
       */
      [Symbol.iterator]() {
        return createHeadersIterator(this, "key+value");
      }
    };
    Headers3.prototype.entries = Headers3.prototype[Symbol.iterator];
    Object.defineProperty(Headers3.prototype, Symbol.toStringTag, {
      value: "Headers",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Headers3.prototype, {
      get: { enumerable: true },
      forEach: { enumerable: true },
      set: { enumerable: true },
      append: { enumerable: true },
      has: { enumerable: true },
      delete: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true }
    });
    function getHeaders(headers) {
      let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
      const keys = Object.keys(headers[MAP]).sort();
      return keys.map(kind === "key" ? function(k) {
        return k.toLowerCase();
      } : kind === "value" ? function(k) {
        return headers[MAP][k].join(", ");
      } : function(k) {
        return [k.toLowerCase(), headers[MAP][k].join(", ")];
      });
    }
    var INTERNAL = Symbol("internal");
    function createHeadersIterator(target, kind) {
      const iterator = Object.create(HeadersIteratorPrototype);
      iterator[INTERNAL] = {
        target,
        kind,
        index: 0
      };
      return iterator;
    }
    var HeadersIteratorPrototype = Object.setPrototypeOf({
      next() {
        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
          throw new TypeError("Value of `this` is not a HeadersIterator");
        }
        var _INTERNAL = this[INTERNAL];
        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
        const values = getHeaders(target, kind);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        this[INTERNAL].index = index + 1;
        return {
          value: values[index],
          done: false
        };
      }
    }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
    Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
      value: "HeadersIterator",
      writable: false,
      enumerable: false,
      configurable: true
    });
    function exportNodeCompatibleHeaders(headers) {
      const obj = Object.assign({ __proto__: null }, headers[MAP]);
      const hostHeaderKey = find(headers[MAP], "Host");
      if (hostHeaderKey !== void 0) {
        obj[hostHeaderKey] = obj[hostHeaderKey][0];
      }
      return obj;
    }
    function createHeadersLenient(obj) {
      const headers = new Headers3();
      for (const name2 of Object.keys(obj)) {
        if (invalidTokenRegex.test(name2)) {
          continue;
        }
        if (Array.isArray(obj[name2])) {
          for (const val of obj[name2]) {
            if (invalidHeaderCharRegex.test(val)) {
              continue;
            }
            if (headers[MAP][name2] === void 0) {
              headers[MAP][name2] = [val];
            } else {
              headers[MAP][name2].push(val);
            }
          }
        } else if (!invalidHeaderCharRegex.test(obj[name2])) {
          headers[MAP][name2] = [obj[name2]];
        }
      }
      return headers;
    }
    var INTERNALS$1 = Symbol("Response internals");
    var STATUS_CODES = http.STATUS_CODES;
    var Response = class _Response {
      constructor() {
        let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        Body.call(this, body, opts);
        const status = opts.status || 200;
        const headers = new Headers3(opts.headers);
        if (body != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          url: opts.url,
          status,
          statusText: opts.statusText || STATUS_CODES[status],
          headers,
          counter: opts.counter
        };
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      /**
       * Convenience property representing if the request ended normally
       */
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      /**
       * Clone this response
       *
       * @return  Response
       */
      clone() {
        return new _Response(clone(this), {
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected
        });
      }
    };
    Body.mixIn(Response.prototype);
    Object.defineProperties(Response.prototype, {
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    Object.defineProperty(Response.prototype, Symbol.toStringTag, {
      value: "Response",
      writable: false,
      enumerable: false,
      configurable: true
    });
    var INTERNALS$2 = Symbol("Request internals");
    var URL2 = Url.URL || whatwgUrl.URL;
    var parse_url = Url.parse;
    var format_url = Url.format;
    function parseURL(urlStr) {
      if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
        urlStr = new URL2(urlStr).toString();
      }
      return parse_url(urlStr);
    }
    var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
    function isRequest(input) {
      return typeof input === "object" && typeof input[INTERNALS$2] === "object";
    }
    function isAbortSignal(signal) {
      const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
      return !!(proto && proto.constructor.name === "AbortSignal");
    }
    var Request3 = class _Request {
      constructor(input) {
        let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsedURL;
        if (!isRequest(input)) {
          if (input && input.href) {
            parsedURL = parseURL(input.href);
          } else {
            parsedURL = parseURL(`${input}`);
          }
          input = {};
        } else {
          parsedURL = parseURL(input.url);
        }
        let method = init.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
        Body.call(this, inputBody, {
          timeout: init.timeout || input.timeout || 0,
          size: init.size || input.size || 0
        });
        const headers = new Headers3(init.headers || input.headers || {});
        if (inputBody != null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init)
          signal = init.signal;
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal");
        }
        this[INTERNALS$2] = {
          method,
          redirect: init.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
        this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
        this.counter = init.counter || input.counter || 0;
        this.agent = init.agent || input.agent;
      }
      get method() {
        return this[INTERNALS$2].method;
      }
      get url() {
        return format_url(this[INTERNALS$2].parsedURL);
      }
      get headers() {
        return this[INTERNALS$2].headers;
      }
      get redirect() {
        return this[INTERNALS$2].redirect;
      }
      get signal() {
        return this[INTERNALS$2].signal;
      }
      /**
       * Clone this request
       *
       * @return  Request
       */
      clone() {
        return new _Request(this);
      }
    };
    Body.mixIn(Request3.prototype);
    Object.defineProperty(Request3.prototype, Symbol.toStringTag, {
      value: "Request",
      writable: false,
      enumerable: false,
      configurable: true
    });
    Object.defineProperties(Request3.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    function getNodeRequestOptions(request) {
      const parsedURL = request[INTERNALS$2].parsedURL;
      const headers = new Headers3(request[INTERNALS$2].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      if (!parsedURL.protocol || !parsedURL.hostname) {
        throw new TypeError("Only absolute URLs are supported");
      }
      if (!/^https?:$/.test(parsedURL.protocol)) {
        throw new TypeError("Only HTTP(S) protocols are supported");
      }
      if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
        throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
      }
      let contentLengthValue = null;
      if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body != null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number") {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate");
      }
      let agent = request.agent;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      return Object.assign({}, parsedURL, {
        method: request.method,
        headers: exportNodeCompatibleHeaders(headers),
        agent
      });
    }
    function AbortError(message) {
      Error.call(this, message);
      this.type = "aborted";
      this.message = message;
      Error.captureStackTrace(this, this.constructor);
    }
    AbortError.prototype = Object.create(Error.prototype);
    AbortError.prototype.constructor = AbortError;
    AbortError.prototype.name = "AbortError";
    var URL$1 = Url.URL || whatwgUrl.URL;
    var PassThrough$1 = Stream.PassThrough;
    var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
      const orig = new URL$1(original).hostname;
      const dest = new URL$1(destination).hostname;
      return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
    };
    var isSameProtocol = function isSameProtocol2(destination, original) {
      const orig = new URL$1(original).protocol;
      const dest = new URL$1(destination).protocol;
      return orig === dest;
    };
    function fetch2(url, opts) {
      if (!fetch2.Promise) {
        throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
      }
      Body.Promise = fetch2.Promise;
      return new fetch2.Promise(function(resolve, reject) {
        const request = new Request3(url, opts);
        const options = getNodeRequestOptions(request);
        const send = (options.protocol === "https:" ? https : http).request;
        const signal = request.signal;
        let response = null;
        const abort = function abort2() {
          let error = new AbortError("The user aborted a request.");
          reject(error);
          if (request.body && request.body instanceof Stream.Readable) {
            destroyStream(request.body, error);
          }
          if (!response || !response.body)
            return;
          response.body.emit("error", error);
        };
        if (signal && signal.aborted) {
          abort();
          return;
        }
        const abortAndFinalize = function abortAndFinalize2() {
          abort();
          finalize();
        };
        const req = send(options);
        let reqTimeout;
        if (signal) {
          signal.addEventListener("abort", abortAndFinalize);
        }
        function finalize() {
          req.abort();
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
          clearTimeout(reqTimeout);
        }
        if (request.timeout) {
          req.once("socket", function(socket) {
            reqTimeout = setTimeout(function() {
              reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
              finalize();
            }, request.timeout);
          });
        }
        req.on("error", function(err) {
          reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
          if (response && response.body) {
            destroyStream(response.body, err);
          }
          finalize();
        });
        fixResponseChunkedTransferBadEnding(req, function(err) {
          if (signal && signal.aborted) {
            return;
          }
          if (response && response.body) {
            destroyStream(response.body, err);
          }
        });
        if (parseInt(process.version.substring(1)) < 14) {
          req.on("socket", function(s) {
            s.addListener("close", function(hadError) {
              const hasDataListener = s.listenerCount("data") > 0;
              if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
                const err = new Error("Premature close");
                err.code = "ERR_STREAM_PREMATURE_CLOSE";
                response.body.emit("error", err);
              }
            });
          });
        }
        req.on("response", function(res) {
          clearTimeout(reqTimeout);
          const headers = createHeadersLenient(res.headers);
          if (fetch2.isRedirect(res.statusCode)) {
            const location2 = headers.get("Location");
            let locationURL = null;
            try {
              locationURL = location2 === null ? null : new URL$1(location2, request.url).toString();
            } catch (err) {
              if (request.redirect !== "manual") {
                reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location2}`, "invalid-redirect"));
                finalize();
                return;
              }
            }
            switch (request.redirect) {
              case "error":
                reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                finalize();
                return;
              case "manual":
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
                break;
              case "follow":
                if (locationURL === null) {
                  break;
                }
                if (request.counter >= request.follow) {
                  reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                  finalize();
                  return;
                }
                const requestOpts = {
                  headers: new Headers3(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                  size: request.size
                };
                if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                  for (const name2 of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                    requestOpts.headers.delete(name2);
                  }
                }
                if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                  reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                  finalize();
                  return;
                }
                if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                  requestOpts.method = "GET";
                  requestOpts.body = void 0;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch2(new Request3(locationURL, requestOpts)));
                finalize();
                return;
            }
          }
          res.once("end", function() {
            if (signal)
              signal.removeEventListener("abort", abortAndFinalize);
          });
          let body = res.pipe(new PassThrough$1());
          const response_options = {
            url: request.url,
            status: res.statusCode,
            statusText: res.statusMessage,
            headers,
            size: request.size,
            timeout: request.timeout,
            counter: request.counter
          };
          const codings = headers.get("Content-Encoding");
          if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          const zlibOptions = {
            flush: zlib.Z_SYNC_FLUSH,
            finishFlush: zlib.Z_SYNC_FLUSH
          };
          if (codings == "gzip" || codings == "x-gzip") {
            body = body.pipe(zlib.createGunzip(zlibOptions));
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          if (codings == "deflate" || codings == "x-deflate") {
            const raw = res.pipe(new PassThrough$1());
            raw.once("data", function(chunk) {
              if ((chunk[0] & 15) === 8) {
                body = body.pipe(zlib.createInflate());
              } else {
                body = body.pipe(zlib.createInflateRaw());
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            raw.on("end", function() {
              if (!response) {
                response = new Response(body, response_options);
                resolve(response);
              }
            });
            return;
          }
          if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
            body = body.pipe(zlib.createBrotliDecompress());
            response = new Response(body, response_options);
            resolve(response);
            return;
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        writeToStream(req, request);
      });
    }
    function fixResponseChunkedTransferBadEnding(request, errorCallback) {
      let socket;
      request.on("socket", function(s) {
        socket = s;
      });
      request.on("response", function(response) {
        const headers = response.headers;
        if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
          response.once("close", function(hadError) {
            const hasDataListener = socket && socket.listenerCount("data") > 0;
            if (hasDataListener && !hadError) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              errorCallback(err);
            }
          });
        }
      });
    }
    function destroyStream(stream, err) {
      if (stream.destroy) {
        stream.destroy(err);
      } else {
        stream.emit("error", err);
        stream.end();
      }
    }
    fetch2.isRedirect = function(code) {
      return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
    };
    fetch2.Promise = global.Promise;
    module2.exports = exports2 = fetch2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = exports2;
    exports2.Headers = Headers3;
    exports2.Request = Request3;
    exports2.Response = Response;
    exports2.FetchError = FetchError;
    exports2.AbortError = AbortError;
  }
});

// node_modules/isomorphic-ws/node.js
var require_node6 = __commonJS({
  "node_modules/isomorphic-ws/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// src/extension.node.ts
var extension_node_exports = {};
__export(extension_node_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(extension_node_exports);
var import_vscode13 = require("vscode");

// src/common/lifecycle.ts
function isIterable(thing) {
  return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
}
function dispose(arg) {
  if (isIterable(arg)) {
    for (const d of arg) {
      if (d) {
        try {
          d.dispose();
        } catch {
        }
      }
    }
  } else if (arg) {
    try {
      arg.dispose();
    } catch {
    }
  }
}
var DisposableStore = class {
  constructor() {
    this.disposables = [];
  }
  add(disposable) {
    this.disposables.push(disposable);
    return disposable;
  }
  dispose() {
    dispose(this.disposables);
  }
};
var disposableStore = new DisposableStore();

// src/urlCapture.ts
var import_vscode9 = require("vscode");

// src/common/localize.ts
var import_vscode = require("vscode");
var Localized;
((Localized2) => {
  Localized2.OutputChannelName = import_vscode.l10n.t("JupyterHub");
  Localized2.ConnectingToJupyterServer = import_vscode.l10n.t("Connecting to JupyterHub Server");
  Localized2.startingJupyterServer = import_vscode.l10n.t("Starting Server");
  Localized2.KernelActionSourceTitle = import_vscode.l10n.t("Existing JupyterHub Server...");
  Localized2.labelOfCommandToEnterUrl = import_vscode.l10n.t("Enter the URL of the running JupyterHub Server...");
  Localized2.placeholderOfInputBoxToEnterUrl = import_vscode.l10n.t("Enter the URL of the running JupyterHub Server");
  Localized2.titleOfInputBoxToEnterUrl = import_vscode.l10n.t("Enter the URL of the running JupyterHub Server");
  Localized2.captureUserNameTitle = "Enter your username";
  Localized2.captureUserNamePrompt = "username";
  Localized2.capturePasswordTitle = "Enter your password or API token";
  Localized2.capturePasswordPrompt = "password or token";
  Localized2.usernamePasswordAuthFailure = import_vscode.l10n.t("Invalid username or password.");
  Localized2.jupyterSelfCertFail = (errorMessage) => import_vscode.l10n.t(
    "The security certificate used by server {0} was not issued by a trusted certificate authority.\r\nThis may indicate an attempt to steal your information.\r\nDo you want to enable the Allow Unauthorized Remote Connection setting for this workspace to allow you to connect?",
    errorMessage
  );
  Localized2.jupyterExpiredCertFail = (errorMessage) => import_vscode.l10n.t(
    "The security certificate used by server {0} has expired.\r\nThis may indicate an attempt to steal your information.\r\nDo you want to enable the Allow Unauthorized Remote Connection setting for this workspace to allow you to connect?",
    errorMessage
  );
  Localized2.jupyterSelfCertFailErrorMessageOnly = import_vscode.l10n.t(
    "The security certificate used by server was not issued by a trusted certificate authority.\r\nThis may indicate an attempt to steal your information."
  );
  Localized2.jupyterSelfCertExpiredErrorMessageOnly = import_vscode.l10n.t(
    "The security certificate used by server has expired.\r\nThis may indicate an attempt to steal your information."
  );
  Localized2.jupyterSelfCertEnable = import_vscode.l10n.t("Yes, connect anyway");
  Localized2.jupyterSelfCertClose = import_vscode.l10n.t("No, close the connection");
  Localized2.connectToToTheJupyterServer = (url) => import_vscode.l10n.t("Connect to the JupyterHub server {0}", url);
  Localized2.jupyterSelectURIInvalidURI = import_vscode.l10n.t("Invalid URL specified");
  Localized2.invalidJupyterHubUrl = import_vscode.l10n.t("Invalid JupyterHub URL specified");
  Localized2.jupyterRenameServer = import_vscode.l10n.t("Change server name");
  Localized2.remoteJupyterConnectionFailedWithoutServerWithError = (errorMessage) => import_vscode.l10n.t("Connection failure. Verify the server is running and reachable. ({0}).", errorMessage);
  Localized2.emptyUserNameErrorMessage = import_vscode.l10n.t("Username cannot be empty");
  Localized2.emptyPasswordErrorMessage = import_vscode.l10n.t("Password/API token cannot be empty");
  Localized2.authMethodApiTokenMoreInfoTooltip = import_vscode.l10n.t("More Info");
})(Localized || (Localized = {}));

// src/common/utils.ts
var noop = () => {
};
function uuid() {
  const id = [];
  const chars = "0123456789abcdef";
  for (var i = 0; i < 36; i++) {
    id[i] = chars.substring(Math.floor(Math.random() * 16))[0];
  }
  id[8] = id[13] = id[18] = id[23] = "-";
  return id.join("");
}

// src/common/logging.ts
var import_vscode2 = require("vscode");
var outputChannel = disposableStore.add(import_vscode2.window.createOutputChannel(Localized.OutputChannelName, "log"));
var loggingLevel = import_vscode2.workspace.getConfiguration("jupyterhub").get("log", "error");
disposableStore.add(
  import_vscode2.workspace.onDidChangeConfiguration((e) => {
    if (e.affectsConfiguration("jupyterhub.log")) {
      let setting = import_vscode2.workspace.getConfiguration("jupyterhub").log;
      setting = setting.toLowerCase();
      if (setting === "error" || setting === "debug" || setting === "off") {
        loggingLevel = setting;
      } else {
        console.error(`Invalid Error Level for JupyterHub ${setting}`);
      }
    }
  })
);
function traceWarn(..._args) {
  if (loggingLevel === "off") {
    return;
  }
  logMessage("warn", ..._args);
}
function traceError(..._args) {
  if (loggingLevel === "off") {
    return;
  }
  logMessage("error", ..._args);
}
function traceDebug(_message, ..._args) {
  if (loggingLevel !== "debug") {
    return;
  }
  logMessage("debug", ..._args);
}
function logMessage(level, ...data) {
  outputChannel.appendLine(`${getTimeForLogging()} [${level}] ${formatErrors(...data).join(" ")}`);
}
function getTimeForLogging() {
  const date = /* @__PURE__ */ new Date();
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  const millis = String(date.getMilliseconds()).padStart(3, "0");
  return `${hours}:${minutes}:${seconds}.${millis}`;
}
function formatErrors(...args) {
  return args.map((arg) => {
    if (!(arg instanceof Error)) {
      return arg;
    }
    const info = [`${arg.name}: ${arg.message}`.trim()];
    if (arg.stack) {
      const stack = (arg.stack || "").split(/\r?\n/g).map((l) => l.trim());
      const firstStackLine = stack.find((l) => l.indexOf("at ") === 0);
      if (stack.length === 1) {
      } else if (stack.length === 1) {
        info.push(stack[0]);
      } else if (stack.length > 1 && firstStackLine?.length) {
        info.push(firstStackLine);
      } else {
        info.push(stack[0]);
      }
    }
    const propertiesToIgnore = ["stack", "message", "name"];
    Object.keys(arg).filter((key) => propertiesToIgnore.indexOf(key) === -1).forEach((key) => info.push(`${key} = ${String(arg[key]).trim()}`));
    return info.filter((l) => l.trim().length).map((l, i) => i === 0 ? l : `    > ${l}`).join("\n");
  });
}

// src/validator.ts
var import_services2 = __toESM(require_lib3());
var import_vscode6 = require("vscode");

// src/common/async.ts
var import_vscode3 = require("vscode");
async function sleep(timeout, token) {
  let disposables = [];
  const promise = new Promise((resolve) => {
    const timer = setTimeout(resolve, timeout);
    disposables.push(new import_vscode3.Disposable(() => clearTimeout(timer)));
  });
  await raceCancellation(token, promise).finally(() => {
    disposables.forEach((d) => d.dispose());
  });
}
function isPromiseLike(v) {
  return typeof v?.then === "function";
}
function raceTimeout(timeout, defaultValue, ...promises) {
  const resolveValue = isPromiseLike(defaultValue) ? void 0 : defaultValue;
  if (isPromiseLike(defaultValue)) {
    promises.push(defaultValue);
  }
  let promiseResolve = void 0;
  const timer = setTimeout(() => promiseResolve?.(resolveValue), timeout);
  return Promise.race([
    Promise.race(promises).finally(() => clearTimeout(timer)),
    new Promise((resolve) => promiseResolve = resolve)
  ]);
}
async function raceCancellation(token, defaultValue, ...promises) {
  let value;
  if (isPromiseLike(defaultValue)) {
    promises.push(defaultValue);
    value = void 0;
  } else {
    value = defaultValue;
  }
  if (!token) {
    return await Promise.race(promises);
  }
  if (token.isCancellationRequested) {
    return value;
  }
  return new Promise((resolve, reject) => {
    if (token.isCancellationRequested) {
      return resolve(value);
    }
    const disposable = token.onCancellationRequested(() => {
      disposable.dispose();
      resolve(value);
    });
    Promise.race(promises).then(resolve, reject).finally(() => disposable.dispose());
  });
}
async function raceCancellationError(token, ...promises) {
  if (!token) {
    return Promise.race(promises);
  }
  if (token.isCancellationRequested) {
    throw new import_vscode3.CancellationError();
  }
  return new Promise((resolve, reject) => {
    if (token.isCancellationRequested) {
      return reject(new import_vscode3.CancellationError());
    }
    const disposable = token.onCancellationRequested(() => {
      disposable.dispose();
      reject(new import_vscode3.CancellationError());
    });
    Promise.race(promises).then(resolve, reject).finally(() => disposable.dispose());
  });
}

// src/validator.ts
var import_vscode7 = require("vscode");

// src/jupyterHubApi.ts
var import_vscode5 = require("vscode");
var import_services = __toESM(require_lib3());

// src/utils.ts
var import_vscode4 = require("vscode");

// src/common/constants.ts
var AppInsightsKey = "0c6ae279ed8443289764825290e4f9e2-1a736e7c-1324-4338-be46-fc2a58ae4d14-7255";
var JUPYTER_EXTENSION_ID = "ms-toolsai.jupyter";

// src/utils.ts
function appendUrlPath(baseUrl, path2) {
  return new URL(path2, baseUrl.endsWith("/") ? baseUrl : `${baseUrl}/`).toString();
}
var isWebExt = false;
function isWebExtension() {
  return isWebExt;
}
async function getJupyterApi() {
  const ext = import_vscode4.extensions.getExtension(JUPYTER_EXTENSION_ID);
  if (!ext) {
    throw new Error("Jupyter Extension not installed");
  }
  if (!ext.isActive) {
    await ext.activate();
  }
  return ext;
}

// src/common/telemetry.ts
var import_extension_telemetry = __toESM(require_telemetryReporter());

// src/common/crypto.ts
var computedHashes = {};
var stopStoringHashes = false;
var cryptoProvider;
if (typeof window === "object") {
  cryptoProvider = window.crypto;
} else if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
  cryptoProvider = self.crypto;
} else {
  cryptoProvider = require("node:crypto").webcrypto;
}
async function computeHash(data, algorithm) {
  const isCandidateForCaching = data.includes("/") || data.includes("\\") || data.endsWith(".interactive");
  if (isCandidateForCaching && computedHashes[data]) {
    return computedHashes[data];
  }
  const hash = await computeHashInternal(data, algorithm);
  if (isCandidateForCaching && !stopStoringHashes) {
    if (Object.keys(computedHashes).length > 1e4) {
      stopStoringHashes = true;
    }
    computedHashes[data] = hash;
  }
  return hash;
}
async function computeHashInternal(data, algorithm) {
  const inputBuffer = new TextEncoder().encode(data);
  const hashBuffer = await cryptoProvider.subtle.digest({ name: algorithm }, inputBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
}

// src/common/telemetry.ts
var telemetryReporter;
function publicLog2(eventName, data) {
  telemetryReporter = telemetryReporter ? telemetryReporter : disposableStore.add(new import_extension_telemetry.default(AppInsightsKey));
  telemetryReporter.sendTelemetryEvent(eventName, data);
}
var urlsAndVersion = /* @__PURE__ */ new Map();
function getHostName(url) {
  try {
    return new URL(url).hostname;
  } catch {
    return "";
  }
}
function stripPIIFromVersion(version) {
  const parts = version.split(".");
  if (parts.length < 2) {
    return 0;
  }
  return parseFloat(`${parseInt(parts[0], 10)}.${parseInt(parts[1], 10)}`);
}
async function getTelemetrySafeHashedString(data) {
  return computeHash(data, "SHA-256");
}
function sendJupyterHubUrlAdded(baseUrl, version, serverId) {
  urlsAndVersion.set(baseUrl, version);
  Promise.all([getTelemetrySafeHashedString(getHostName(baseUrl)), getTelemetrySafeHashedString(baseUrl)]).then(([hostNameHash, baseUrlHash]) => {
    publicLog2("addJupyterHubUrl", {
      serverId,
      hostNameHash,
      baseUrlHash,
      version: stripPIIFromVersion(version)
    });
  }).catch(noop);
}
function sendJupyterHubUrlNotAdded(reason, lastStep) {
  publicLog2("addJupyterHubUrl", {
    failed: true,
    reason,
    lastStep
  });
}
function trackUsageOfOldApiGeneration(baseUrl) {
  Promise.all([getTelemetrySafeHashedString(getHostName(baseUrl)), getTelemetrySafeHashedString(baseUrl)]).then(([hostNameHash, baseUrlHash]) => {
    publicLog2(
      "generateTokenWithOldApi",
      {
        hostNameHash,
        baseUrlHash
      }
    );
  }).catch(noop);
}
function trackInstallOfExtension() {
  publicLog2("activated", {});
}
function solveCertificateProblem(problem, solution) {
  publicLog2(
    "addJupyterHubUrlWithCertProblem",
    {
      solution,
      problem
    }
  );
}

// src/jupyterHubApi.ts
async function getVersion(url, fetch2, token) {
  const apiUrl = appendUrlPath(url, "hub/api");
  let response;
  let messageTemplate = `Invalid Jupyter Hub Url ${apiUrl} (failed to get version)`;
  try {
    const response2 = await fetch2.send(
      apiUrl,
      {
        method: "get",
        redirect: "manual",
        headers: { Connection: "keep-alive" }
      },
      token
    );
    if (response2.status === 200) {
      messageTemplate = `Invalid Jupyter Hub Url ${apiUrl} (failed to parse response)`;
      const { version } = await response2.json();
      return version;
    }
    throw new Error("Non 200 response");
  } catch (ex) {
    throw new Error(await getResponseErrorMessageToThrowOrLog(messageTemplate, response));
  }
}
async function deleteApiToken(baseUrl, username, tokenId, token, fetch2, cancellationToken) {
  const url = appendUrlPath(baseUrl, `hub/api/users/${username}/tokens/${tokenId}`);
  const options = { method: "DELETE", headers: { Authorization: `token ${token}` } };
  await fetch2.send(url, options, cancellationToken);
}
async function verifyApiToken(baseUrl, username, token, fetch2, cancellationToken) {
  try {
    await getUserInfo(baseUrl, username, token, fetch2, cancellationToken);
    return true;
  } catch (ex) {
    traceDebug(`Token is no longer valid`, ex);
    return false;
  }
}
async function generateNewApiToken(baseUrl, username, password, fetch2, cancellationToken) {
  let response;
  try {
    const url = appendUrlPath(baseUrl, `hub/api/users/${username}/tokens`);
    const body = {
      auth: { username, password },
      note: `Requested by JupyterHub extension in VSCode`
    };
    response = await fetch2.send(url, { method: "POST", body: JSON.stringify(body) }, cancellationToken);
    const json = await response.json();
    traceDebug(`Generated new token for user using the new way`);
    return { token: json.token, tokenId: json.id };
  } catch (ex) {
    traceError(await getResponseErrorMessageToThrowOrLog(`Failed to generate token, trying old way`, response), ex);
    return generateNewApiTokenOldWay(baseUrl, username, password, fetch2, cancellationToken);
  }
}
async function generateNewApiTokenOldWay(baseUrl, username, password, fetch2, cancellationToken) {
  try {
    const url = appendUrlPath(baseUrl, `hub/api/authorizations/token`);
    const body = { username, password };
    const response = await fetch2.send(url, { method: "POST", body: JSON.stringify(body) }, cancellationToken);
    const json = await response.json();
    if (json.token) {
      traceDebug(`Generated new token for user using the old way`);
      trackUsageOfOldApiGeneration(baseUrl);
      return { token: json.token, tokenId: "" };
    }
    throw new Error("Unable to generate Token using the old api route");
  } catch (ex) {
    traceError(`Failed to generate token, trying old way`, ex);
    throw ex;
  }
}
async function getUserInfo(baseUrl, username, token, fetch2, cancellationToken, includeStoppedServers) {
  traceDebug(`Getting user info for user ${baseUrl}, token length = ${token.length} && ${token.trim().length}`);
  const path2 = includeStoppedServers ? `hub/api/users/${username}?include_stopped_servers` : `hub/api/users/${username}`;
  const url = appendUrlPath(baseUrl, path2);
  const headers = { Authorization: `token ${token}` };
  const response = await fetch2.send(url, { method: "GET", headers }, cancellationToken);
  if (response.status === 200) {
    return response.json();
  }
  throw new Error(await getResponseErrorMessageToThrowOrLog(`Failed to get user info`, response));
}
async function getUserJupyterUrl(baseUrl, username, serverName, token, fetch2, cancelToken) {
  const includeStoppedServers = !!serverName;
  const info = await getUserInfo(baseUrl, username, token, fetch2, cancelToken, includeStoppedServers);
  if (serverName) {
    const server = (info.servers || {})[serverName];
    if (server?.url) {
      return appendUrlPath(baseUrl, server.url);
    }
    const servers = Object.keys(info.servers || {});
    traceError(
      `Failed to get the user Jupyter Url for ${serverName} existing servers include ${JSON.stringify(info)}`
    );
    throw new Error(
      `Named Jupyter Server '${serverName}' not found, existing servers include ${servers.join(", ")}`
    );
  } else {
    const defaultServer = (info.servers || {})[""]?.url || info.server;
    if (defaultServer) {
      return appendUrlPath(baseUrl, defaultServer);
    }
    traceError(
      `Failed to get the user Jupyter Url as there is no default server for the user ${JSON.stringify(info)}`
    );
    return appendUrlPath(baseUrl, `user/${username}/`);
  }
}
async function listServers(baseUrl, username, token, fetch2, cancelToken) {
  try {
    const info = await getUserInfo(baseUrl, username, token, fetch2, cancelToken, true).catch((ex) => {
      traceWarn(`Failed to get user info with stopped servers, defaulting without`, ex);
      return getUserInfo(baseUrl, username, token, fetch2, cancelToken);
    });
    return Object.values(info.servers || {});
  } catch (ex) {
    traceError(`Failed to get a list of servers for the user ${username}`, ex);
    return [];
  }
}
async function startServer(baseUrl, username, serverName, token, fetch2, cancellationToken) {
  const url = serverName ? appendUrlPath(baseUrl, `hub/api/users/${username}/servers/${encodeURIComponent(serverName)}`) : appendUrlPath(baseUrl, `hub/api/users/${username}/server`);
  const headers = { Authorization: `token ${token}` };
  const response = await fetch2.send(url, { method: "POST", headers }, cancellationToken);
  if (response.status === 201 || response.status === 202) {
    return;
  }
  throw new Error(await getResponseErrorMessageToThrowOrLog(`Failed to fetch user info`, response));
}
async function getResponseErrorMessageToThrowOrLog(message, response) {
  if (!response) {
    return message;
  }
  let responseText = "";
  try {
    responseText = await response.text();
  } catch (ex) {
    traceError(`Error fetching text from response to log error ${message}`, ex);
  }
  return `${message}, ${response.statusText} (${response.status}) with message  ${responseText}`;
}
async function createServerConnectSettings(baseUrl, serverName, authInfo, fetch2, cancelToken) {
  baseUrl = await getUserJupyterUrl(baseUrl, authInfo.username, serverName, authInfo.token, fetch2, cancelToken);
  let serverSettings = {
    baseUrl,
    appUrl: "",
    // A web socket is required to allow token authentication
    wsUrl: baseUrl.replace("http", "ws")
  };
  let requestInit = fetch2.requestCreator.getRequestInit();
  serverSettings = { ...serverSettings, token: authInfo.token, appendToken: true };
  const allowUnauthorized = import_vscode5.workspace.getConfiguration("jupyter").get("allowUnauthorizedRemoteConnection", false);
  if (baseUrl.startsWith("https") && allowUnauthorized && fetch2.requestCreator.createHttpRequestAgent) {
    const requestAgent = fetch2.requestCreator.createHttpRequestAgent();
    requestInit = { ...requestInit, agent: requestAgent };
  }
  serverSettings = {
    ...serverSettings,
    init: requestInit,
    fetch: fetch2.requestCreator.getFetchMethod(),
    Request: fetch2.requestCreator.getRequestCtor(void 0),
    Headers: fetch2.requestCreator.getHeadersCtor()
  };
  return import_services.ServerConnection.makeSettings(serverSettings);
}
var cacheOfBaseUrls = /* @__PURE__ */ new Map();
async function getJupyterHubBaseUrl(url, fetch2, token) {
  const cachedBaseUrl = cacheOfBaseUrls.get(url);
  if (cachedBaseUrl) {
    return cachedBaseUrl;
  }
  if (await getVersion(url, fetch2, token).catch(noop)) {
    cacheOfBaseUrls.set(url, url);
    return url;
  }
  if (url.toLowerCase().includes("/user/")) {
    try {
      const strippedUrl = url.substring(0, url.toLowerCase().indexOf("/user/"));
      if (await getVersion(strippedUrl, fetch2, token).catch(noop)) {
        cacheOfBaseUrls.set(url, strippedUrl);
        return strippedUrl;
      }
    } catch {
    }
  }
  if (await getVersion(new URL(url).origin, fetch2, token).catch(noop)) {
    cacheOfBaseUrls.set(url, new URL(url).origin);
    return new URL(url).origin;
  }
  throw new Error("Unable to determine base url of Jupyter Hub Server");
}
function extractUserNameFromUrl(url) {
  if (url.toLowerCase().includes("/user/")) {
    const parts = url.split("/");
    const userIndex = parts.findIndex((p) => p.toLowerCase() === "user");
    if (userIndex > 0 && parts.length >= userIndex + 1) {
      return parts[userIndex + 1].trim();
    }
  }
}
function extractTokenFromUrl(url) {
  try {
    const parsedUrl = new URL(url);
    const token = parsedUrl.searchParams.get("token");
    return token || "";
  } catch {
    return "";
  }
}

// src/common/stopwatch.ts
var StopWatch = class {
  constructor() {
    this.started = Date.now();
  }
  get elapsed() {
    return Date.now() - this.started;
  }
  reset() {
    this.started = Date.now();
  }
};

// src/validator.ts
var TIMEOUT_FOR_SESSION_MANAGER_READY = 1e4;
var JupyterHubConnectionValidator = class {
  constructor(fetch2) {
    this.fetch = fetch2;
  }
  async validateJupyterUri(baseUrl, authInfo, authenticator, mainCancel) {
    const disposable = new DisposableStore();
    const masterCancel = disposable.add(new import_vscode6.CancellationTokenSource());
    const token = masterCancel.token;
    disposable.add(mainCancel.onCancellationRequested(() => masterCancel.cancel()));
    try {
      const info = await getUserInfo(baseUrl, authInfo.username, authInfo.token, this.fetch, token);
      if (info.name) {
        return;
      } else {
        traceError(`Failed to get user info, got ${JSON.stringify(info)}`);
        throw new Error("Failed to get user info");
      }
    } catch (err) {
      if (isSelfCertsError(err)) {
        const handled = await handleSelfCertsError(err.message);
        if (handled) {
          return await this.validateJupyterUri(baseUrl, authInfo, authenticator, token);
        }
      } else if (isSelfCertsExpiredError(err)) {
        const handled = await handleExpiredCertsError(err.message);
        if (handled) {
          return await this.validateJupyterUri(baseUrl, authInfo, authenticator, token);
        }
      }
      throw err;
    } finally {
      disposable.dispose();
    }
  }
  async ensureServerIsRunning(baseUrl, serverName, authInfo, authenticator, mainCancel) {
    await import_vscode6.window.withProgress(
      {
        location: import_vscode6.ProgressLocation.Notification,
        title: Localized.ConnectingToJupyterServer,
        cancellable: true
      },
      async (progress, progressCancel) => {
        const disposable = new DisposableStore();
        const masterCancel = disposable.add(new import_vscode6.CancellationTokenSource());
        const token = masterCancel.token;
        disposable.add(mainCancel.onCancellationRequested(() => masterCancel.cancel()));
        disposable.add(progressCancel.onCancellationRequested(() => masterCancel.cancel()));
        try {
          const didStartServer = await this.startIfServerNotStarted(
            baseUrl,
            serverName,
            authInfo,
            progress,
            token
          ).catch((ex) => traceError(`Failed to start server`, ex));
          const started = new StopWatch();
          const jupyterAuth = await authenticator.getJupyterAuthInfo({ baseUrl, authInfo }, token);
          if (!jupyterAuth) {
            throw new Error("Failed to get Jupyter Auth Info");
          }
          let retries = 0;
          while (true) {
            const settings = await createServerConnectSettings(
              baseUrl,
              serverName,
              { username: authInfo.username, token: jupyterAuth.token },
              this.fetch,
              token
            );
            const gotKernelSpecs = await getKernelSpecs(settings, token);
            if (gotKernelSpecs) {
              return;
            }
            if (didStartServer == "didStartServer") {
              await sleep(1e3, token);
              if (retries > 0 && started.elapsed > TIMEOUT_FOR_SESSION_MANAGER_READY) {
                throw new Error("Failed to enumeration kernel Specs");
              } else {
                retries += 1;
                traceDebug(`Waiting for Jupyter Server to start ${baseUrl}`);
                continue;
              }
            } else {
              throw new Error("Failed to enumeration kernel Specs");
            }
          }
        } catch (err) {
          if (isSelfCertsError(err)) {
            const handled = await handleSelfCertsError(err.message);
            if (handled) {
              return await this.validateJupyterUri(baseUrl, authInfo, authenticator, token);
            }
          } else if (isSelfCertsExpiredError(err)) {
            const handled = await handleExpiredCertsError(err.message);
            if (handled) {
              return await this.validateJupyterUri(baseUrl, authInfo, authenticator, token);
            }
          }
          throw err;
        } finally {
          disposable.dispose();
        }
      }
    );
  }
  /**
   * If the Jupyter (lab/notebook) server has not already been started, then start it.
   * This is required, else we cannot connect to it (after all without a Jupyter Server running, there's nothing to connect to)
   */
  async startIfServerNotStarted(baseUrl, serverName, authInfo, progress, token) {
    const includeStoppedServers = !!serverName;
    try {
      const status = await getUserInfo(
        baseUrl,
        authInfo.username,
        authInfo.token,
        this.fetch,
        token,
        includeStoppedServers
      );
      if (!serverName && (status.servers || {})[""]?.ready) {
        return;
      }
      if (serverName && (status.servers || {})[serverName]?.ready) {
        return;
      }
    } catch (ex) {
      traceError(`Failed to get user info`, ex);
      return;
    }
    progress.report({ message: Localized.startingJupyterServer });
    await startServer(baseUrl, authInfo.username, serverName, authInfo.token, this.fetch, token).catch(
      (ex) => ex instanceof import_vscode6.CancellationError ? void 0 : traceError(`Failed to start the Jupyter Server`, ex)
    );
    try {
      const started = Date.now();
      while (true) {
        const status = await getUserInfo(
          baseUrl,
          authInfo.username,
          authInfo.token,
          this.fetch,
          token,
          includeStoppedServers
        );
        if (!serverName && (status.servers || {})[""]?.ready) {
          return "didStartServer";
        }
        if (serverName && (status.servers || {})[serverName]?.ready) {
          return "didStartServer";
        }
        if (Date.now() - started > TIMEOUT_FOR_SESSION_MANAGER_READY) {
          if (!serverName && status.server) {
            const server = (status.servers || {})[""];
            traceDebug(
              `Default server status used from status.server 5 ${status.server}, as server status is ${JSON.stringify(server)}`
            );
            return "didStartServer";
          }
          traceError(`Timeout waiting for Jupyter Server to start, current status = ${status.pending}`);
          return;
        }
        await sleep(1e3, token);
      }
    } catch (ex) {
      traceError(`Failed to get user info for user`, ex);
      return;
    }
  }
};
async function getKernelSpecs(serverSettings, token) {
  const specsManager = new import_services2.KernelSpecManager({ serverSettings });
  const kernelManager = new import_services2.KernelManager({ serverSettings });
  const sessionManager = new import_services2.SessionManager({
    serverSettings,
    kernelManager
  });
  const disposables = [];
  try {
    const hasKernelSpecs = () => specsManager.specs && Object.keys(specsManager.specs.kernelspecs).length > 0;
    if (hasKernelSpecs()) {
      return specsManager.specs;
    }
    await raceCancellationError(token, raceTimeout(TIMEOUT_FOR_SESSION_MANAGER_READY, sessionManager.ready));
    if (hasKernelSpecs()) {
      return specsManager.specs;
    }
    await raceCancellationError(token, raceTimeout(TIMEOUT_FOR_SESSION_MANAGER_READY, specsManager.refreshSpecs()));
    if (hasKernelSpecs()) {
      return specsManager.specs;
    }
    const promise = new Promise((resolve) => {
      specsManager.specsChanged.connect(resolve);
      disposables.push(
        new import_vscode6.Disposable(() => {
          try {
            specsManager.specsChanged.disconnect(resolve);
          } catch {
          }
        })
      );
    });
    await raceCancellationError(
      token,
      raceTimeout(
        TIMEOUT_FOR_SESSION_MANAGER_READY,
        promise,
        specsManager.ready,
        specsManager.refreshSpecs(),
        sessionManager.ready
      )
    );
    if (hasKernelSpecs()) {
      return specsManager.specs;
    }
    traceError(
      `SessionManager cannot enumerate kernelSpecs. Specs ${JSON.stringify(specsManager.specs?.kernelspecs)}.`
    );
    return;
  } catch (e) {
    if (!(e instanceof import_vscode6.CancellationError)) {
      traceError(`SessionManager:getKernelSpecs failure: `, e);
    }
    return;
  } finally {
    dispose(disposables);
    try {
      await raceTimeout(1e4, sessionManager.ready);
    } catch (e) {
      traceError(`Exception on session manager shutdown: `, e);
    } finally {
      try {
        sessionManager.dispose();
      } catch {
      }
      try {
        kernelManager.dispose();
      } catch {
      }
      try {
        specsManager.dispose();
      } catch {
      }
    }
  }
}
function isUnableToGetIssuerCertError(err) {
  return err.message.indexOf("reason: unable to get issuer certificate") >= 0 || err.message.includes("UNABLE_TO_GET_ISSUER_CERT") || err.name.includes("UNABLE_TO_GET_ISSUER_CERT") || err.toString().includes("UNABLE_TO_GET_ISSUER_CERT");
}
function isSelfCertsError(err) {
  return err.message.indexOf("reason: self signed certificate") >= 0 || isUnableToGetIssuerCertError(err);
}
async function handleSelfCertsError(message) {
  const enableOption = Localized.jupyterSelfCertEnable;
  const closeOption = Localized.jupyterSelfCertClose;
  const value = await import_vscode6.window.showErrorMessage(
    Localized.jupyterSelfCertFail(message),
    { modal: true },
    enableOption,
    closeOption
  );
  if (value === enableOption) {
    solveCertificateProblem("self-signed", "allow");
    await import_vscode7.workspace.getConfiguration("jupyter").update("allowUnauthorizedRemoteConnection", true, import_vscode6.ConfigurationTarget.Workspace);
    return true;
  } else {
    solveCertificateProblem("self-signed", "cancel");
  }
  return false;
}
function isSelfCertsExpiredError(err) {
  return err.message.indexOf("reason: certificate has expired") >= 0;
}
async function handleExpiredCertsError(message) {
  const enableOption = Localized.jupyterSelfCertEnable;
  const closeOption = Localized.jupyterSelfCertClose;
  const value = await import_vscode6.window.showErrorMessage(
    Localized.jupyterExpiredCertFail(message),
    { modal: true },
    enableOption,
    closeOption
  );
  if (value === enableOption) {
    solveCertificateProblem("expired", "allow");
    await import_vscode7.workspace.getConfiguration("jupyter").update("allowUnauthorizedRemoteConnection", true, import_vscode6.ConfigurationTarget.Workspace);
    return true;
  } else {
    solveCertificateProblem("expired", "cancel");
  }
  return false;
}

// src/common/inputCapture.ts
var import_vscode8 = require("vscode");
var WorkflowInputCapture = class {
  constructor() {
    this.disposables = [];
  }
  dispose() {
    dispose(this.disposables);
  }
  async getValue(options, token) {
    return new Promise((resolve, reject) => {
      const input = import_vscode8.window.createInputBox();
      this.disposables.push(new import_vscode8.Disposable(() => input.hide()));
      this.disposables.push(input);
      input.ignoreFocusOut = true;
      input.title = options.title;
      input.ignoreFocusOut = true;
      input.value = options.value || "";
      input.placeholder = options.placeholder || "";
      input.password = options.password === true;
      input.validationMessage = options.validationMessage || "";
      input.buttons = [import_vscode8.QuickInputButtons.Back, ...options.buttons || []];
      input.show();
      input.onDidChangeValue(() => input.validationMessage = "", this, this.disposables);
      input.onDidTriggerButton((e) => options.onDidTriggerButton?.(e), this, this.disposables);
      input.onDidHide(() => reject(new import_vscode8.CancellationError()), this, this.disposables);
      input.onDidTriggerButton(
        (e) => {
          if (e === import_vscode8.QuickInputButtons.Back) {
            resolve(void 0);
          }
        },
        this,
        this.disposables
      );
      input.onDidAccept(
        async () => {
          if (options.validateInput) {
            input.validationMessage = await options.validateInput(input.value);
            if (input.validationMessage) {
              return;
            }
          }
          input.busy = true;
          resolve(input.value || options.value || "");
        },
        this,
        this.disposables
      );
      token.onCancellationRequested(() => reject(new import_vscode8.CancellationError()), this, this.disposables);
    });
  }
  async pickValue(options, token) {
    return new Promise((resolve, reject) => {
      const input = import_vscode8.window.createQuickPick();
      this.disposables.push(new import_vscode8.Disposable(() => input.hide()));
      this.disposables.push(input);
      input.ignoreFocusOut = true;
      input.title = options.title;
      input.ignoreFocusOut = true;
      input.placeholder = options.placeholder || "";
      input.buttons = [import_vscode8.QuickInputButtons.Back];
      input.items = options.quickPickItems;
      input.canSelectMany = false;
      input.show();
      input.onDidHide(() => reject(new import_vscode8.CancellationError()), this, this.disposables);
      input.onDidTriggerButton(
        (e) => {
          if (e === import_vscode8.QuickInputButtons.Back) {
            resolve(void 0);
          }
        },
        this,
        this.disposables
      );
      input.onDidAccept(
        async () => {
          input.busy = true;
          if (input.selectedItems.length === 1) {
            resolve(input.selectedItems[0]);
          } else {
            resolve(void 0);
          }
        },
        this,
        this.disposables
      );
      token.onCancellationRequested(() => reject(new import_vscode8.CancellationError()), this, this.disposables);
    });
  }
};

// src/authenticator.ts
var Authenticator = class {
  constructor(fetch2) {
    this.fetch = fetch2;
  }
  async getJupyterAuthInfo(options, token) {
    if (!options.authInfo.token) {
      const isApiTokenValid = await verifyApiToken(
        options.baseUrl,
        options.authInfo.username,
        options.authInfo.password,
        this.fetch,
        token
      );
      if (isApiTokenValid) {
        return { tokenId: "", token: options.authInfo.password };
      }
    }
    if (options.authInfo.token) {
      const isApiTokenValid = await verifyApiToken(
        options.baseUrl,
        options.authInfo.username,
        options.authInfo.token,
        this.fetch,
        token
      );
      if (isApiTokenValid) {
        return { tokenId: "", token: options.authInfo.token };
      }
    }
    return generateNewApiToken(
      options.baseUrl,
      options.authInfo.username,
      options.authInfo.password,
      this.fetch,
      token
    );
  }
};

// src/urlCapture.ts
var JupyterHubUrlCapture = class {
  constructor(fetch2, storage) {
    this.fetch = fetch2;
    this.storage = storage;
    this.displayNamesOfHandles = /* @__PURE__ */ new Map();
    this.disposable = new DisposableStore();
    this.newAuthenticator = new Authenticator(fetch2);
    this.jupyterConnection = new JupyterHubConnectionValidator(fetch2);
  }
  dispose() {
    this.disposable.dispose();
  }
  async captureRemoteJupyterUrl(token, initialUrl = "", displayName = "", validationErrorMessage = "", serverId = uuid(), reasonForCapture = "captureNewUrl") {
    try {
      return await this.captureRemoteJupyterUrlImpl(
        initialUrl,
        displayName,
        validationErrorMessage,
        serverId,
        reasonForCapture,
        token
      );
    } catch (ex) {
      if (!(ex instanceof import_vscode9.CancellationError)) {
        traceError("Failed to capture remote jupyter server", ex);
      }
      throw ex;
    }
  }
  async captureRemoteJupyterUrlImpl(url = "", displayName = "", validationErrorMessage = "", id = uuid(), reasonForCapture = "captureNewUrl", token) {
    const state = {
      auth: { username: "", password: "", token: "", tokenId: "" },
      baseUrl: "",
      serverName: void 0,
      hubVersion: "",
      urlWasPrePopulated: false,
      url,
      displayName,
      displayNamesOfHandles: this.displayNamesOfHandles,
      errorMessage: validationErrorMessage,
      serverId: id
    };
    const steps = [
      new GetUrlStep(this.fetch),
      new GetUserName(),
      new GetPassword(this.newAuthenticator),
      new VerifyConnection(this.jupyterConnection, this.newAuthenticator),
      new ServerSelector(this.fetch),
      new GetDisplayName(this.storage)
    ];
    const disposables = new DisposableStore();
    let nextStep = "Get Url";
    if (url) {
      if (isValidUrl(url)) {
        try {
          state.baseUrl = await getJupyterHubBaseUrl(url, this.fetch, token);
          const version = await getVersion(state.baseUrl, this.fetch, token);
          state.hubVersion = version;
          state.urlWasPrePopulated = true;
          nextStep = reasonForCapture === "captureNewUrl" ? "Get Username" : "Get Url";
        } catch {
          validationErrorMessage = Localized.invalidJupyterHubUrl;
        }
      } else {
        validationErrorMessage = Localized.jupyterSelectURIInvalidURI;
        nextStep = "Get Url";
      }
    }
    try {
      const stepsExecuted = [];
      while (true) {
        const step = steps.filter((s) => !s.disabled).find((s) => s.step === nextStep);
        if (!step) {
          traceError(`Step '${nextStep}' Not found`);
          throw new import_vscode9.CancellationError();
        }
        nextStep = await step.run(state, token);
        if (nextStep === "Before") {
          sendJupyterHubUrlNotAdded("back", step.step);
          return;
        }
        if (nextStep === "After") {
          sendJupyterHubUrlAdded(state.baseUrl, state.hubVersion, id);
          await this.storage.addServerOrUpdate(
            {
              id,
              baseUrl: state.baseUrl,
              displayName: state.displayName,
              serverName: state.serverName
            },
            {
              username: state.auth.username,
              password: state.auth.password,
              token: state.auth.token,
              tokenId: state.auth.tokenId
            }
          );
          return {
            id,
            label: state.displayName
          };
        }
        if (nextStep) {
          if (stepsExecuted.includes(nextStep)) {
            stepsExecuted.splice(stepsExecuted.indexOf(nextStep));
            continue;
          }
          if (step.canNavigateBackToThis) {
            stepsExecuted.push(step.step);
          }
          continue;
        }
        if (stepsExecuted.length) {
          nextStep = stepsExecuted.pop();
          continue;
        }
        sendJupyterHubUrlNotAdded("cancel", step.step);
        return;
      }
    } catch (ex) {
      if (ex instanceof import_vscode9.CancellationError) {
        sendJupyterHubUrlNotAdded("cancel", "");
      } else {
        traceError("Failed to capture remote jupyter server", ex);
        sendJupyterHubUrlNotAdded("error", "");
      }
      throw ex;
    } finally {
      dispose(disposables);
    }
  }
};
var GetUrlStep = class extends DisposableStore {
  constructor(fetch2) {
    super();
    this.fetch = fetch2;
    this.step = "Get Url";
    this.canNavigateBackToThis = true;
  }
  async run(state, token) {
    if (!state.url) {
      try {
        const text = isWebExtension() ? "" : await import_vscode9.env.clipboard.readText();
        const parsedUri = new URL(text.trim());
        state.url = text && parsedUri && parsedUri.protocol.toLowerCase().startsWith("http") ? text : "";
      } catch {
      }
    }
    const validationMessage = state.errorMessage;
    state.errorMessage = "";
    const url = await this.add(new WorkflowInputCapture()).getValue(
      {
        title: Localized.titleOfInputBoxToEnterUrl,
        placeholder: Localized.placeholderOfInputBoxToEnterUrl,
        value: state.url,
        validationMessage,
        validateInput: async (value) => {
          value = value.trim();
          if (!isValidUrl(value)) {
            return Localized.jupyterSelectURIInvalidURI;
          }
          try {
            await getJupyterHubBaseUrl(value, this.fetch, token);
          } catch (ex) {
            traceError(`Failed to determine base url for ${value}`, ex);
            return Localized.invalidJupyterHubUrl;
          }
        }
      },
      token
    );
    if (!url) {
      return;
    }
    state.url = url;
    state.baseUrl = await getJupyterHubBaseUrl(url, this.fetch, token);
    state.hubVersion = await getVersion(state.baseUrl, this.fetch, token);
    state.auth.username = state.auth.username || extractUserNameFromUrl(url) || "";
    state.auth.token = state.auth.token || extractTokenFromUrl(url) || "";
    return "Get Username";
  }
};
var GetUserName = class extends DisposableStore {
  constructor() {
    super(...arguments);
    this.step = "Get Username";
    this.canNavigateBackToThis = true;
  }
  async run(state, token) {
    const errorMessage = state.errorMessage;
    state.errorMessage = "";
    const username = await this.add(new WorkflowInputCapture()).getValue(
      {
        title: Localized.captureUserNameTitle,
        value: state.auth.username || extractUserNameFromUrl(state.url),
        placeholder: Localized.captureUserNamePrompt,
        validationMessage: errorMessage,
        validateInput: async (value) => value ? void 0 : Localized.emptyUserNameErrorMessage
      },
      token
    );
    if (!username) {
      return;
    }
    state.auth.username = username;
    return "Get Password";
  }
};
var GetPassword = class extends DisposableStore {
  constructor(authenticator) {
    super();
    this.authenticator = authenticator;
    this.step = "Get Password";
    this.canNavigateBackToThis = true;
  }
  async run(state, token) {
    const input = this.add(new WorkflowInputCapture());
    const moreInfo = {
      iconPath: new import_vscode9.ThemeIcon("info"),
      tooltip: Localized.authMethodApiTokenMoreInfoTooltip
    };
    const password = await input.getValue(
      {
        title: Localized.capturePasswordTitle,
        placeholder: Localized.capturePasswordPrompt,
        value: state.auth.password || state.auth.token || extractTokenFromUrl(state.url) || "",
        password: true,
        buttons: [moreInfo],
        onDidTriggerButton: (e) => {
          if (e === moreInfo) {
            import_vscode9.env.openExternal(import_vscode9.Uri.parse("https://aka.ms/vscodeJupyterHubApiToken")).then(noop, noop);
          }
        },
        validateInput: async (value) => {
          if (!value) {
            return Localized.emptyPasswordErrorMessage;
          }
          try {
            state.auth.password = value;
            const result = await this.authenticator.getJupyterAuthInfo(
              {
                baseUrl: state.baseUrl,
                authInfo: state.auth
              },
              token
            );
            state.auth.token = result.token || "";
            state.auth.tokenId = result.tokenId || "";
            traceDebug(
              `Got an Auth token = ${state.auth.token.length} && ${state.auth.token.trim().length}, tokenId = ${state.auth.tokenId.length} && ${state.auth.tokenId.trim().length} for ${state.baseUrl}`
            );
          } catch (err) {
            traceError("Failed to get Auth Info", err);
            if (err instanceof import_vscode9.CancellationError) {
              throw err;
            } else if (isSelfCertsError(err)) {
            } else if (isSelfCertsExpiredError(err)) {
            } else {
              traceError(`Failed to validate username and password for ${state.baseUrl}`, err);
              return Localized.usernamePasswordAuthFailure;
            }
          }
        }
      },
      token
    );
    if (!password) {
      return;
    }
    state.auth.password = password;
    return "Verify Connection";
  }
};
var VerifyConnection = class extends DisposableStore {
  constructor(jupyterConnection, authenticator) {
    super();
    this.jupyterConnection = jupyterConnection;
    this.authenticator = authenticator;
    this.step = "Verify Connection";
    this.canNavigateBackToThis = false;
  }
  async run(state, token) {
    try {
      await this.jupyterConnection.validateJupyterUri(state.baseUrl, state.auth, this.authenticator, token);
    } catch (err) {
      traceError("Uri verification error", err);
      if (err instanceof import_vscode9.CancellationError) {
        throw err;
      } else if (isSelfCertsError(err)) {
        state.errorMessage = Localized.jupyterSelfCertFailErrorMessageOnly;
        return "Get Url";
      } else if (isSelfCertsExpiredError(err)) {
        state.errorMessage = Localized.jupyterSelfCertExpiredErrorMessageOnly;
        return "Get Url";
      } else {
        state.errorMessage = Localized.usernamePasswordAuthFailure;
        return "Get Username";
      }
    }
    return "Server Selector";
  }
};
function getServerStatus(server) {
  switch (server.pending) {
    case "spawn":
      return import_vscode9.l10n.t("Starting");
    case "stop":
      return import_vscode9.l10n.t("Shutting down");
    default:
      return server.ready ? import_vscode9.l10n.t("Running") : import_vscode9.l10n.t("Stopped");
  }
}
var ServerSelector = class extends DisposableStore {
  constructor(fetch2) {
    super();
    this.fetch = fetch2;
    this.step = "Server Selector";
    this.canNavigateBackToThis = false;
  }
  async run(state, token) {
    try {
      const servers = await listServers(state.baseUrl, state.auth.username, state.auth.token, this.fetch, token);
      if (servers.length === 0 || servers.length === 1 && !servers[0].name) {
        traceDebug("No servers found for the user");
        this.disabled = true;
        return "Get Display Name";
      }
      const quickPickItems = servers.map((server) => ({
        label: server.name || "Default Server",
        description: `(${getServerStatus(server)})`,
        server
      }));
      const selection = await new WorkflowInputCapture().pickValue(
        {
          title: import_vscode9.l10n.t("Select a Server"),
          quickPickItems
        },
        token
      );
      if (!selection) {
        return;
      }
      state.serverName = selection.server.name;
    } catch (err) {
      if (err instanceof import_vscode9.CancellationError) {
        throw err;
      }
      this.disabled = true;
      traceWarn("Failed to list all of the servers for the user, assuming there aren't any", err);
    }
    return "Get Display Name";
  }
};
var GetDisplayName = class extends DisposableStore {
  constructor(storage) {
    super();
    this.storage = storage;
    this.step = "Get Display Name";
    this.canNavigateBackToThis = false;
  }
  async run(state, token) {
    const suggestedDisplayName = getSuggestedDisplayName(
      state.url,
      state.serverName,
      this.storage.all.map((s) => s.displayName)
    );
    const displayName = await this.add(new WorkflowInputCapture()).getValue(
      {
        title: Localized.jupyterRenameServer,
        value: state.displayName || suggestedDisplayName
      },
      token
    );
    if (!displayName) {
      return;
    }
    state.displayName = displayName;
    return "After";
  }
};
function getSuggestedDisplayName(baseUrl, serverName, usedNames) {
  const usedNamesSet = new Set(usedNames.map((s) => s.toLowerCase()));
  usedNamesSet.add("localhost");
  usedNamesSet.add("");
  const isIPAddress = typeof parseInt(new URL(baseUrl).hostname.charAt(0), 10) === "number";
  let hostName = isIPAddress ? "JupyterHub" : new URL(baseUrl).hostname;
  hostName = serverName ? `${hostName} (${serverName})` : hostName;
  if (!isIPAddress && !usedNamesSet.has(hostName.toLowerCase())) {
    return hostName;
  }
  for (let i = 0; i < 10; i++) {
    const name2 = i === 0 ? hostName : `${hostName} ${i}`;
    if (!usedNamesSet.has(name2.toLowerCase())) {
      return name2;
    }
  }
  return "JupyterHub";
}
function isValidUrl(value) {
  try {
    new URL(value);
    return true;
  } catch (err) {
    traceDebug(`Failed to parse URI`, err);
    return false;
  }
}

// src/common/requestCreator.node.ts
var import_https = require("https");
var nodeFetch = __toESM(require_lib5());
var JupyterRequestCreator = class {
  getRequestCtor(getAuthHeader) {
    class AuthorizingRequest extends nodeFetch.Request {
      constructor(input, init) {
        super(input, init);
        const origHeaders = this.headers;
        const authorizationHeader = getAuthHeader?.() || {};
        const keys = Object.keys(authorizationHeader);
        keys.forEach((k) => origHeaders.append(k, authorizationHeader[k].toString()));
        origHeaders.set("Content-Type", "application/json");
        const origAppend = origHeaders.append.bind(origHeaders);
        origHeaders.append = (k, v) => {
          if (k.toLowerCase() !== "authorization") {
            origAppend(k, v);
          }
        };
      }
    }
    return getAuthHeader && Object.keys(getAuthHeader() || {}).length ? AuthorizingRequest : nodeFetch.Request;
  }
  getFetchMethod() {
    return nodeFetch.default;
  }
  getHeadersCtor() {
    return nodeFetch.Headers;
  }
  getRequestInit() {
    return { cache: "no-store", credentials: "same-origin" };
  }
  createHttpRequestAgent() {
    return new import_https.Agent({ rejectUnauthorized: false });
  }
};

// src/storage.ts
var import_vscode10 = require("vscode");
var serverListStorageKey = "JupyterHubServers";
var AuthKeyPrefix = "JupyterHubServerAuthInfo_";
function getAuthInfoKey(serverId) {
  return `${AuthKeyPrefix}${serverId}`;
}
var JupyterHubServerStorage = class {
  constructor(secrets, globalMemento) {
    this.secrets = secrets;
    this.globalMemento = globalMemento;
    this.disposable = new DisposableStore();
    this._onDidRemove = new import_vscode10.EventEmitter();
    this.onDidRemove = this._onDidRemove.event;
  }
  dispose() {
    this.disposable.dispose();
  }
  get all() {
    return this.globalMemento.get(serverListStorageKey, []);
  }
  async getCredentials(serverId) {
    try {
      const js = await this.secrets.get(getAuthInfoKey(serverId));
      if (!js) {
        return;
      }
      return JSON.parse(js || "");
    } catch (ex) {
      traceError(`Failed to extract stored username/password ${serverId}`);
      return;
    }
  }
  async addServerOrUpdate(server, auth) {
    await Promise.all([
      this.globalMemento.update(serverListStorageKey, this.all.filter((s) => s.id !== server.id).concat(server)),
      this.secrets.store(getAuthInfoKey(server.id), JSON.stringify(auth))
    ]);
  }
  async removeServer(serverId) {
    const item = this.all.find((s) => s.id === serverId);
    await Promise.all([
      this.globalMemento.update(
        serverListStorageKey,
        this.all.filter((s) => s.id !== serverId)
      ),
      this.secrets.delete(getAuthInfoKey(serverId))
    ]);
    if (item) {
      this._onDidRemove.fire(item);
    }
  }
};

// src/common/request.ts
var import_vscode11 = require("vscode");
var SimpleFetch = class {
  constructor(requestCreator) {
    this.requestCreator = requestCreator;
  }
  async send(url, options, token) {
    const allowUnauthorized = import_vscode11.workspace.getConfiguration("jupyter").get("allowUnauthorizedRemoteConnection", false);
    try {
      return await raceCancellationError(
        token,
        this.requestCreator.getFetchMethod()(url, this.addAllowUnauthorized(url, allowUnauthorized, options))
      );
    } catch (e) {
      traceError(`Error sending request to ${url}`, e);
      if (e.message.indexOf("reason: self signed certificate") >= 0) {
        const value = await import_vscode11.window.showErrorMessage(
          Localized.jupyterSelfCertFail(e.message),
          { modal: true },
          Localized.jupyterSelfCertEnable,
          Localized.jupyterSelfCertClose
        );
        if (value === Localized.jupyterSelfCertEnable) {
          solveCertificateProblem("self-signed", "allow");
          await import_vscode11.workspace.getConfiguration("jupyter").updateSetting(
            "allowUnauthorizedRemoteConnection",
            true,
            void 0,
            import_vscode11.ConfigurationTarget.Workspace
          );
          return this.requestCreator.getFetchMethod()(url, this.addAllowUnauthorized(url, true, options));
        } else if (value === Localized.jupyterSelfCertClose) {
          solveCertificateProblem("self-signed", "cancel");
        }
      }
      throw e;
    }
  }
  /**
   * For HTTPS connections respect our allowUnauthorized setting by adding in an agent to enable that on the request
   */
  addAllowUnauthorized(url, allowUnauthorized, options) {
    if (url.startsWith("https") && allowUnauthorized && this.requestCreator.createHttpRequestAgent) {
      const requestAgent = this.requestCreator.createHttpRequestAgent();
      return { ...options, agent: requestAgent };
    }
    return options;
  }
};

// src/jupyterIntegration.ts
var nodeFetch2 = __toESM(require_lib5());
var import_isomorphic_ws = __toESM(require_node6());
var import_vscode12 = require("vscode");
var JupyterServerIntegration = class {
  constructor(fetch2, jupyterApi, storage, urlCapture, nodeFetchImpl = nodeFetch2) {
    this.fetch = fetch2;
    this.jupyterApi = jupyterApi;
    this.storage = storage;
    this.urlCapture = urlCapture;
    this.nodeFetchImpl = nodeFetchImpl;
    this.id = "UserJupyterServerPickerProviderId";
    this.documentation = import_vscode12.Uri.parse("https://aka.ms/vscodeJuptyerExtKernelPickerExistingServer");
    this.disposables = [];
    this._onDidChangeServers = new import_vscode12.EventEmitter();
    this.onDidChangeServers = this._onDidChangeServers.event;
    this.cachedOfAuthInfo = /* @__PURE__ */ new Map();
    this.jupyterConnectionValidator = new JupyterHubConnectionValidator(fetch2);
    this.newAuthenticator = new Authenticator(fetch2);
    const collection = this.jupyterApi.createJupyterServerCollection(
      this.id,
      Localized.KernelActionSourceTitle,
      this
    );
    this.disposables.push(collection);
    this.disposables.push(this._onDidChangeServers);
    collection.commandProvider = this;
    collection.documentation = import_vscode12.Uri.parse("https://aka.ms/vscodeJupyterHub");
  }
  dispose() {
    dispose(this.disposables);
  }
  async handleCommand(command, token) {
    try {
      const url = "url" in command ? command.url : void 0;
      let displayName = void 0;
      let serverId = void 0;
      let whyCaptureUrl = "captureNewUrl";
      if (url && this.previouslyEnteredUrlTypedIntoQuickPick === url && this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick) {
        whyCaptureUrl = "cameHereFromBackButton";
        serverId = this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick.id;
        displayName = this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick.label;
      }
      const server = await this.urlCapture.captureRemoteJupyterUrl(
        token,
        url,
        displayName,
        void 0,
        serverId,
        whyCaptureUrl
      );
      if (!server) {
        this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick = void 0;
        this.previouslyEnteredUrlTypedIntoQuickPick = void 0;
        return;
      }
      this._onDidChangeServers.fire();
      this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick = server;
      return server;
    } catch (ex) {
      if (!(ex instanceof import_vscode12.CancellationError)) {
        traceError(`Failed to select a Jupyter Server`, ex);
      }
      this.previouslyEnteredUrlTypedIntoQuickPick = void 0;
      this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick = void 0;
      throw ex;
    }
  }
  /**
   * @param value Value entered by the user in the quick pick
   */
  async provideCommands(value, _token) {
    this.previouslyEnteredJupyterServerBasedOnUrlTypedIntoQuickPick = void 0;
    this.previouslyEnteredUrlTypedIntoQuickPick = void 0;
    let url = "";
    try {
      value = (value || "").trim();
      if (["http:", "https:"].includes(new URL(value.trim()).protocol.toLowerCase())) {
        url = value;
      }
    } catch {
    }
    if (url) {
      this.previouslyEnteredUrlTypedIntoQuickPick = url;
      const label = Localized.connectToToTheJupyterServer(url);
      return [{ label, url }];
    }
    return [{ label: Localized.labelOfCommandToEnterUrl, canBeAutoSelected: true }];
  }
  async removeJupyterServer(server) {
    const tokenSource = new import_vscode12.CancellationTokenSource();
    try {
      const serverInfo = this.storage.all.find((s) => s.id === server.id);
      const authInfo = await this.storage.getCredentials(server.id).catch(noop);
      if (serverInfo && authInfo?.token && authInfo.tokenId) {
        await deleteApiToken(
          serverInfo.baseUrl,
          authInfo.username,
          authInfo.tokenId,
          authInfo.token,
          this.fetch,
          tokenSource.token
        ).catch((ex) => traceDebug(`Failed to delete token ${server.id}`, ex));
      }
      await this.storage.removeServer(server.id);
    } catch (ex) {
      traceDebug(`Failed to remove server ${server.id}`, ex);
    } finally {
      this._onDidChangeServers.fire();
    }
  }
  async provideJupyterServers(_token) {
    return this.storage.all.map((s) => {
      return {
        id: s.id,
        label: s.displayName
      };
    });
  }
  async resolveJupyterServer(server, token) {
    if (!this.cachedOfAuthInfo.get(server.id)) {
      const promise = this.resolveJupyterServerImpl(server, token);
      promise.catch((ex) => {
        if (this.cachedOfAuthInfo.get(server.id) === promise) {
          traceError(`Failed to get auth information for server ${server.id}`, ex);
          this.cachedOfAuthInfo.delete(server.id);
        }
      });
      this.cachedOfAuthInfo.set(server.id, promise);
    }
    return this.cachedOfAuthInfo.get(server.id);
  }
  async resolveJupyterServerImpl(server, cancelToken) {
    const serverInfo = this.storage.all.find((s) => s.id === server.id);
    if (!serverInfo) {
      throw new Error("Server not found");
    }
    const authInfo = await this.storage.getCredentials(server.id);
    if (!authInfo) {
      throw new Error(`Server ${server.id} not found`);
    }
    const result = await this.newAuthenticator.getJupyterAuthInfo(
      { baseUrl: serverInfo.baseUrl, authInfo },
      cancelToken
    );
    if (result.tokenId && authInfo?.token !== result.token) {
      try {
        await this.storage.addServerOrUpdate(
          {
            baseUrl: serverInfo.baseUrl,
            displayName: serverInfo.displayName,
            id: serverInfo.id,
            serverName: serverInfo.serverName
          },
          {
            password: authInfo.password || "",
            username: authInfo.username || "",
            token: result.token,
            tokenId: result.tokenId
          }
        );
      } catch (ex) {
        traceError(`Failed to update server with the latest token information ${server.id}`, ex);
      }
    }
    await this.jupyterConnectionValidator.validateJupyterUri(
      serverInfo.baseUrl,
      { username: authInfo.username, password: authInfo.password, token: result.token },
      this.newAuthenticator,
      cancelToken
    ).catch(noop);
    await this.jupyterConnectionValidator.ensureServerIsRunning(
      serverInfo.baseUrl,
      serverInfo.serverName,
      { username: authInfo.username, password: authInfo.password, token: result.token },
      this.newAuthenticator,
      cancelToken
    ).catch(noop);
    const rawBaseUrl = await getUserJupyterUrl(
      serverInfo.baseUrl,
      authInfo.username || "",
      serverInfo.serverName,
      authInfo.token,
      this.fetch,
      cancelToken
    );
    const baseUrl = import_vscode12.Uri.parse(rawBaseUrl);
    const brokenUrl = new this.nodeFetchImpl.Request(baseUrl.toString(true)).url;
    const correctUrl = new this.nodeFetchImpl.Request(rawBaseUrl).url;
    const brokenWsUrl = brokenUrl.replace("http", "ws");
    const brokenWsUrl2 = baseUrl.toString(true).replace("http", "ws");
    const correctWsUrl = correctUrl.replace("http", "ws");
    const ourFetch = async (input, init) => {
      const newUrl = input.url.replace(brokenUrl, correctUrl);
      init = init || {
        method: input.method,
        body: input.body,
        headers: input.headers,
        redirect: input.redirect,
        cache: input.cache,
        credentials: input.credentials,
        integrity: input.integrity,
        keepalive: input.keepalive,
        mode: input.mode,
        referrer: input.referrer,
        referrerPolicy: input.referrerPolicy,
        signal: input.signal
      };
      const newInput = new this.nodeFetchImpl.Request(newUrl, init);
      return this.nodeFetchImpl.default(newInput, init);
    };
    const headers = {
      Authorization: `token ${result.token}`
    };
    const addOurHeaders = (options) => {
      options = options || {};
      return {
        ...options,
        headers: {
          ...options.headers || {},
          ...headers
        }
      };
    };
    class OurWebSocket extends import_isomorphic_ws.default {
      constructor(url, protocols, options) {
        super(
          url.replace(brokenWsUrl, correctWsUrl).replace(brokenWsUrl2, correctWsUrl),
          protocols,
          addOurHeaders(options)
        );
      }
    }
    const connectionInformation = {
      baseUrl,
      token: result.token,
      headers
    };
    connectionInformation.fetch = ourFetch;
    connectionInformation.WebSocket = OurWebSocket;
    return {
      ...server,
      connectionInformation
    };
  }
};

// src/extension.node.ts
async function activate(context) {
  trackInstallOfExtension();
  context.subscriptions.push(disposableStore);
  getJupyterApi().then((api) => {
    const requestCreator = new JupyterRequestCreator();
    const fetch2 = new SimpleFetch(requestCreator);
    const storage = disposableStore.add(new JupyterHubServerStorage(context.secrets, context.globalState));
    const uriCapture = disposableStore.add(new JupyterHubUrlCapture(fetch2, storage));
    disposableStore.add(new JupyterServerIntegration(fetch2, api.exports, storage, uriCapture));
  }).catch((ex) => traceError("Failed to activate jupyter extension", ex));
  if (context.extensionMode === import_vscode13.ExtensionMode.Test) {
    return { RequestCreator: JupyterRequestCreator };
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
/*! Bundled license information:

@microsoft/applicationinsights-shims/dist/umd/applicationinsights-shims.js:
  (*!
   * Microsoft Application Insights JavaScript SDK - Shim functions, 2.0.2
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

@microsoft/applicationinsights-core-js/dist/applicationinsights-core-js.js:
  (*!
   * Application Insights JavaScript SDK - Core, 2.8.15
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)
  (*!
   * Microsoft Dynamic Proto Utility, 1.1.9
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

@microsoft/dynamicproto-js/lib/dist/node/dynamicproto-js.js:
  (*!
   * Microsoft Dynamic Proto Utility, 1.1.9
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

@microsoft/1ds-core-js/dist/ms.core.js:
  (*!
   * 1DS JS SDK Core, 3.2.13
   * Copyright (c) Microsoft and contributors. All rights reserved.
   * (Microsoft Internal Only)
   *)

@microsoft/1ds-post-js/dist/ms.post.js:
  (*!
   * 1DS JS SDK POST plugin, 3.2.13
   * Copyright (c) Microsoft and contributors. All rights reserved.
   * (Microsoft Internal Only)
   *)

@microsoft/applicationinsights-web-snippet/dist/node/applicationinsights-web-snippet.js:
  (*!
   * Application Insights JavaScript SDK - Web Snippet, 1.0.1
   * Copyright (c) Microsoft and contributors. All rights reserved.
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
